#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl, importMetaUrl;
var init_cjs_shims = __esm({
  "node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
    getImportMetaUrl = /* @__PURE__ */ __name(() => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href, "getImportMetaUrl");
    importMetaUrl = /* @__PURE__ */ getImportMetaUrl();
  }
});

// src/utils/config.ts
var import_node_fs, import_node_path, import_node_os, import_yaml, DEFAULT_CONFIG, _ConfigManager, ConfigManager;
var init_config = __esm({
  "src/utils/config.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_fs = require("fs");
    import_node_path = require("path");
    import_node_os = require("os");
    import_yaml = __toESM(require("yaml"), 1);
    DEFAULT_CONFIG = {
      projectName: "aitrackdown-project",
      outputFormat: "md",
      defaultAssignee: "unassigned",
      templatePath: "./templates",
      defaultTemplate: "standard",
      colorOutput: true,
      defaultPriority: "medium",
      autoAssign: true,
      rootDirectory: "tasks",
      // NEW DEFAULT: tasks/ instead of trackdown/
      migrateFromTrackdown: true,
      // NEW: enable migration by default
      customFields: [],
      integrations: {
        git: true,
        jira: false,
        slack: false
      },
      exportSettings: {
        includeCompleted: true,
        dateFormat: "YYYY-MM-DD",
        timezone: "UTC"
      }
    };
    _ConfigManager = class _ConfigManager {
      configPath;
      config;
      globalConfigPath;
      constructor(configPath) {
        this.configPath = configPath || this.findConfigFile();
        this.globalConfigPath = (0, import_node_path.join)((0, import_node_os.homedir)(), ".trackdown", "config.json");
        this.config = this.loadConfig();
      }
      findConfigFile() {
        const possibleFiles = [
          ".trackdownrc.json",
          ".trackdownrc.yaml",
          ".trackdownrc.yml",
          "trackdown.config.json",
          "trackdown.config.yaml",
          "trackdown.config.yml"
        ];
        for (const file of possibleFiles) {
          const fullPath = (0, import_node_path.join)(process.cwd(), file);
          if ((0, import_node_fs.existsSync)(fullPath)) {
            return fullPath;
          }
        }
        return (0, import_node_path.join)(process.cwd(), ".trackdownrc.json");
      }
      loadConfig() {
        let config = { ...DEFAULT_CONFIG };
        config = { ...config, ...this.loadConfigFile(this.globalConfigPath) };
        config = { ...config, ...this.loadConfigFile(this.configPath) };
        config = { ...config, ...this.loadEnvironmentConfig() };
        return config;
      }
      loadConfigFile(path31) {
        try {
          if (!(0, import_node_fs.existsSync)(path31)) {
            return {};
          }
          const fileContent = (0, import_node_fs.readFileSync)(path31, "utf-8");
          const ext = (0, import_node_path.extname)(path31);
          if (ext === ".yaml" || ext === ".yml") {
            return import_yaml.default.parse(fileContent);
          } else {
            return JSON.parse(fileContent);
          }
        } catch (error) {
          console.warn(`Warning: Could not load config from ${path31}, skipping`);
          return {};
        }
      }
      loadEnvironmentConfig() {
        const envConfig = {};
        if (process.env.TRACKDOWN_PROJECT_NAME) {
          envConfig.projectName = process.env.TRACKDOWN_PROJECT_NAME;
        }
        if (process.env.TRACKDOWN_OUTPUT_FORMAT) {
          envConfig.outputFormat = process.env.TRACKDOWN_OUTPUT_FORMAT;
        }
        if (process.env.TRACKDOWN_DEFAULT_ASSIGNEE) {
          envConfig.defaultAssignee = process.env.TRACKDOWN_DEFAULT_ASSIGNEE;
        }
        if (process.env.TRACKDOWN_DEFAULT_PRIORITY) {
          envConfig.defaultPriority = process.env.TRACKDOWN_DEFAULT_PRIORITY;
        }
        if (process.env.TRACKDOWN_TEMPLATE_PATH) {
          envConfig.templatePath = process.env.TRACKDOWN_TEMPLATE_PATH;
        }
        if (process.env.TRACKDOWN_COLOR_OUTPUT) {
          envConfig.colorOutput = process.env.TRACKDOWN_COLOR_OUTPUT === "true";
        }
        if (process.env.TRACKDOWN_AUTO_ASSIGN) {
          envConfig.autoAssign = process.env.TRACKDOWN_AUTO_ASSIGN === "true";
        }
        if (process.env.AITRACKDOWN_ROOT_DIR) {
          envConfig.rootDirectory = process.env.AITRACKDOWN_ROOT_DIR;
        }
        if (process.env.AITRACKDOWN_TASKS_DIR) {
          envConfig.rootDirectory = process.env.AITRACKDOWN_TASKS_DIR;
        }
        if (process.env.TRACKDOWN_MIGRATE_FROM_TRACKDOWN) {
          envConfig.migrateFromTrackdown = process.env.TRACKDOWN_MIGRATE_FROM_TRACKDOWN === "true";
        }
        return envConfig;
      }
      getConfig() {
        return { ...this.config };
      }
      updateConfig(updates) {
        this.config = { ...this.config, ...updates };
        this.saveConfig();
      }
      saveConfig(global = false) {
        const targetPath = global ? this.globalConfigPath : this.configPath;
        try {
          const dir = (0, import_node_path.join)(targetPath, "..");
          if (!(0, import_node_fs.existsSync)(dir)) {
            (0, import_node_fs.mkdirSync)(dir, { recursive: true });
          }
          const ext = (0, import_node_path.extname)(targetPath);
          let content;
          if (ext === ".yaml" || ext === ".yml") {
            content = import_yaml.default.stringify(this.config);
          } else {
            content = JSON.stringify(this.config, null, 2);
          }
          (0, import_node_fs.writeFileSync)(targetPath, content);
        } catch (error) {
          throw new Error(`Failed to save config to ${targetPath}: ${error}`);
        }
      }
      resetConfig() {
        this.config = { ...DEFAULT_CONFIG };
        this.saveConfig();
      }
      getConfigPath() {
        return this.configPath;
      }
      getGlobalConfigPath() {
        return this.globalConfigPath;
      }
      validateConfig() {
        const errors = [];
        if (this.config.outputFormat && !["json", "yaml", "md", "csv", "table"].includes(this.config.outputFormat)) {
          errors.push(`Invalid output format: ${this.config.outputFormat}`);
        }
        if (this.config.defaultPriority && !["low", "medium", "high", "critical"].includes(this.config.defaultPriority)) {
          errors.push(`Invalid default priority: ${this.config.defaultPriority}`);
        }
        if (this.config.customFields) {
          this.config.customFields.forEach((field, index) => {
            if (!field.name) {
              errors.push(`Custom field at index ${index} is missing a name`);
            }
            if (!["string", "number", "boolean", "date"].includes(field.type)) {
              errors.push(`Custom field '${field.name}' has invalid type: ${field.type}`);
            }
          });
        }
        return {
          valid: errors.length === 0,
          errors
        };
      }
      createDefaultConfigFile(format = "json") {
        const filename = format === "yaml" ? ".trackdownrc.yaml" : ".trackdownrc.json";
        const path31 = (0, import_node_path.join)(process.cwd(), filename);
        this.configPath = path31;
        this.config = { ...DEFAULT_CONFIG };
        this.saveConfig();
        return path31;
      }
    };
    __name(_ConfigManager, "ConfigManager");
    ConfigManager = _ConfigManager;
  }
});

// src/utils/path-resolver.ts
var import_node_path2, import_node_fs2, _PathResolver, PathResolver;
var init_path_resolver = __esm({
  "src/utils/path-resolver.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_path2 = require("path");
    import_node_fs2 = require("fs");
    _PathResolver = class _PathResolver {
      configManager;
      cliRootDir;
      constructor(configManager, cliRootDir) {
        this.configManager = configManager;
        this.cliRootDir = cliRootDir;
      }
      /**
       * Get the root directory with proper priority resolution:
       * 1. CLI option override (--root-dir, --tasks-dir)
       * 2. Environment variable (AITRACKDOWN_ROOT_DIR)
       * 3. Config file setting (rootDirectory)
       * 4. Default to "tasks/"
       */
      getRootDirectory() {
        if (this.cliRootDir) {
          return this.cliRootDir;
        }
        const envRootDir = process.env.AITRACKDOWN_ROOT_DIR || process.env.AITRACKDOWN_TASKS_DIR;
        if (envRootDir) {
          return envRootDir;
        }
        const config = this.configManager.getConfig();
        if (config.rootDirectory) {
          return config.rootDirectory;
        }
        return "tasks";
      }
      /**
       * Get the active tasks directory
       */
      getActiveDir() {
        return (0, import_node_path2.join)(this.getRootDirectory(), "active");
      }
      /**
       * Get the completed tasks directory
       */
      getCompletedDir() {
        return (0, import_node_path2.join)(this.getRootDirectory(), "completed");
      }
      /**
       * Get the templates directory
       */
      getTemplatesDir() {
        return (0, import_node_path2.join)(this.getRootDirectory(), "templates");
      }
      /**
       * Get the exports directory
       */
      getExportsDir() {
        return (0, import_node_path2.join)(this.getRootDirectory(), "exports");
      }
      /**
       * Get the documentation directory
       */
      getDocsDir() {
        return (0, import_node_path2.join)(this.getRootDirectory(), "docs");
      }
      /**
       * Get the archived tasks directory
       */
      getArchivedDir() {
        return (0, import_node_path2.join)(this.getRootDirectory(), "archived");
      }
      /**
       * Check if legacy "trackdown/" directory exists and root is still default
       */
      shouldMigrate() {
        const config = this.configManager.getConfig();
        const hasLegacyDir = (0, import_node_fs2.existsSync)((0, import_node_path2.join)(process.cwd(), "trackdown"));
        const usingDefaultRoot = this.getRootDirectory() === "tasks";
        const migrationEnabled = config.migrateFromTrackdown !== false;
        return hasLegacyDir && usingDefaultRoot && migrationEnabled;
      }
      /**
       * Get legacy trackdown directory for migration detection
       */
      getLegacyTrackdownDir() {
        return (0, import_node_path2.join)(process.cwd(), "trackdown");
      }
      /**
       * Get all standard directories that should be created
       */
      getStandardDirectories() {
        return [
          this.getActiveDir(),
          this.getCompletedDir(),
          this.getTemplatesDir(),
          this.getExportsDir(),
          this.getDocsDir(),
          this.getArchivedDir()
        ];
      }
      /**
       * Get template-specific directories based on project template
       */
      getTemplateDirectories(templateType) {
        const rootDir = this.getRootDirectory();
        const templates = {
          standard: [
            { path: (0, import_node_path2.join)(rootDir, "active"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "completed"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "templates"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "exports"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "docs"), type: "directory" }
          ],
          cli: [
            { path: (0, import_node_path2.join)(rootDir, "features"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "bugs"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "releases"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "documentation"), type: "directory" }
          ],
          web: [
            { path: (0, import_node_path2.join)(rootDir, "frontend"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "backend"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "testing"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "deployment"), type: "directory" }
          ],
          api: [
            { path: (0, import_node_path2.join)(rootDir, "endpoints"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "schemas"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "testing"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "documentation"), type: "directory" }
          ],
          mobile: [
            { path: (0, import_node_path2.join)(rootDir, "features"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "ui-ux"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "testing"), type: "directory" },
            { path: (0, import_node_path2.join)(rootDir, "releases"), type: "directory" }
          ]
        };
        return templates[templateType] || templates.standard;
      }
      /**
       * Update CLI root directory override
       */
      setCliRootDir(rootDir) {
        this.cliRootDir = rootDir;
      }
      /**
       * Clear CLI root directory override
       */
      clearCliRootDir() {
        this.cliRootDir = void 0;
      }
      /**
       * Show migration warning if legacy directory exists
       */
      showMigrationWarning() {
        if (this.shouldMigrate()) {
          console.warn(`
\u26A0\uFE0F  LEGACY DIRECTORY DETECTED

Found existing "trackdown/" directory. The CLI now defaults to "${this.getRootDirectory()}/" directory.

Migration Options:
1. Automatic: Set AITRACKDOWN_ROOT_DIR=trackdown to continue using the existing directory
2. Manual: Move files from trackdown/ to ${this.getRootDirectory()}/ manually
3. Configuration: Update .trackdownrc.json with "rootDirectory": "trackdown"

Examples:
  export AITRACKDOWN_ROOT_DIR=trackdown    # Use existing directory
  aitrackdown --root-dir trackdown init    # Specify directory per command
      `);
        }
      }
      /**
       * Get migration command suggestions
       */
      getMigrationCommands() {
        if (!this.shouldMigrate()) {
          return [];
        }
        const rootDir = this.getRootDirectory();
        return [
          `# Option 1: Set environment variable to use existing trackdown/ directory`,
          `export AITRACKDOWN_ROOT_DIR=trackdown`,
          ``,
          `# Option 2: Move files to new ${rootDir}/ directory`,
          `mkdir -p ${rootDir}`,
          `mv trackdown/active ${rootDir}/active 2>/dev/null || true`,
          `mv trackdown/completed ${rootDir}/completed 2>/dev/null || true`,
          `mv trackdown/templates ${rootDir}/templates 2>/dev/null || true`,
          `mv trackdown/exports ${rootDir}/exports 2>/dev/null || true`,
          ``,
          `# Option 3: Update configuration file`,
          `echo '{"rootDirectory": "trackdown"}' > .trackdownrc.json`
        ];
      }
    };
    __name(_PathResolver, "PathResolver");
    PathResolver = _PathResolver;
  }
});

// src/utils/colors.ts
var import_chalk, colors, _ColorTheme, ColorTheme;
var init_colors = __esm({
  "src/utils/colors.ts"() {
    "use strict";
    init_cjs_shims();
    import_chalk = __toESM(require("chalk"), 1);
    colors = {
      // Main brand color - cyan for professional tech feel
      primary: import_chalk.default.cyan,
      // Success operations and positive feedback
      success: import_chalk.default.green,
      // Warnings and cautionary messages
      warning: import_chalk.default.yellow,
      // Errors and critical issues
      error: import_chalk.default.red,
      // Informational messages and tips
      info: import_chalk.default.blue,
      // Secondary text and less important information
      muted: import_chalk.default.gray,
      // Important highlights and emphasis
      highlight: import_chalk.default.bold.white
    };
    _ColorTheme = class _ColorTheme {
      // Priority-based colors
      static priority(level) {
        switch (level.toLowerCase()) {
          case "low":
            return import_chalk.default.gray;
          case "medium":
            return import_chalk.default.yellow;
          case "high":
            return import_chalk.default.magenta;
          case "critical":
            return import_chalk.default.red.bold;
          default:
            return import_chalk.default.whiteBright;
        }
      }
      // Status-based colors
      static status(status) {
        switch (status.toLowerCase()) {
          case "todo":
            return import_chalk.default.gray;
          case "in-progress":
            return import_chalk.default.blue;
          case "done":
            return import_chalk.default.green;
          case "blocked":
            return import_chalk.default.red;
          default:
            return import_chalk.default.whiteBright;
        }
      }
      // Command-specific colors
      static command(command) {
        return import_chalk.default.cyan.bold(command);
      }
      // Option colors
      static option(option) {
        return import_chalk.default.yellow(option);
      }
      // Argument colors
      static argument(arg) {
        return import_chalk.default.green(arg);
      }
      // Header styling
      static header(text) {
        return import_chalk.default.bold.cyan(`
${text}
${"=".repeat(text.length)}`);
      }
      // Subheader styling
      static subheader(text) {
        return import_chalk.default.bold.white(`
${text}
${"-".repeat(text.length)}`);
      }
      // Badge styling for tags, labels, etc.
      static badge(text, variant = "info") {
        const colorFn = colors[variant];
        return colorFn(` ${text} `);
      }
      // Create a bordered box for important messages
      static box(text, variant = "info") {
        const lines = text.split("\n");
        const maxLength = Math.max(...lines.map((line) => line.length));
        const colorFn = colors[variant];
        const border = "\u2500".repeat(maxLength + 2);
        const top = `\u250C${border}\u2510`;
        const bottom = `\u2514${border}\u2518`;
        const content = lines.map((line) => `\u2502 ${line.padEnd(maxLength)} \u2502`).join("\n");
        return colorFn(`${top}
${content}
${bottom}`);
      }
      // Progress indicators
      static progress(current, total) {
        const percentage = Math.round(current / total * 100);
        const filled = Math.round(current / total * 20);
        const empty = 20 - filled;
        const bar = "\u2588".repeat(filled) + "\u2591".repeat(empty);
        if (percentage < 30) {
          return import_chalk.default.red(`[${bar}] ${percentage}%`);
        } else if (percentage < 70) {
          return import_chalk.default.yellow(`[${bar}] ${percentage}%`);
        } else {
          return import_chalk.default.green(`[${bar}] ${percentage}%`);
        }
      }
      // Create a separator line
      static separator(char = "\u2500", length = 50) {
        return import_chalk.default.gray(char.repeat(length));
      }
      // Timestamp formatting
      static timestamp(date) {
        return import_chalk.default.dim(date.toISOString().replace("T", " ").substring(0, 19));
      }
      // File path formatting
      static path(path31) {
        return import_chalk.default.cyan.underline(path31);
      }
      // Code formatting
      static code(code) {
        return import_chalk.default.gray.inverse(` ${code} `);
      }
      // URL formatting
      static url(url) {
        return import_chalk.default.blue.underline(url);
      }
      // Keyboard shortcut formatting
      static key(key) {
        return import_chalk.default.inverse(` ${key} `);
      }
    };
    __name(_ColorTheme, "ColorTheme");
    ColorTheme = _ColorTheme;
  }
});

// src/utils/formatter.ts
var import_boxen, import_figlet, _Formatter, Formatter;
var init_formatter = __esm({
  "src/utils/formatter.ts"() {
    "use strict";
    init_cjs_shims();
    import_boxen = __toESM(require("boxen"), 1);
    import_figlet = __toESM(require("figlet"), 1);
    init_colors();
    _Formatter = class _Formatter {
      static success(message) {
        return colors.success(`\u2705 ${message}`);
      }
      static error(message) {
        return colors.error(`\u274C ${message}`);
      }
      static warning(message) {
        return colors.warning(`\u26A0\uFE0F  ${message}`);
      }
      static info(message) {
        return colors.info(`\u2139\uFE0F  ${message}`);
      }
      static debug(message) {
        return colors.muted(`\u{1F50D} ${message}`);
      }
      static header(text) {
        return ColorTheme.header(text);
      }
      static subheader(text) {
        return ColorTheme.subheader(text);
      }
      static highlight(text) {
        return colors.highlight(text);
      }
      static dim(text) {
        return colors.muted(text);
      }
      // Enhanced banner for CLI startup
      static banner(text) {
        try {
          const ascii = import_figlet.default.textSync(text, {
            font: "ANSI Shadow",
            horizontalLayout: "default",
            verticalLayout: "default",
            width: 80,
            whitespaceBreak: true
          });
          return colors.primary(ascii);
        } catch {
          return ColorTheme.header(text);
        }
      }
      // Create beautiful notification boxes
      static box(message, variant = "info") {
        const borderColors = {
          info: "cyan",
          success: "green",
          warning: "yellow",
          error: "red"
        };
        return (0, import_boxen.default)(message, {
          padding: 1,
          margin: 1,
          borderStyle: "round",
          borderColor: borderColors[variant],
          backgroundColor: void 0
        });
      }
      // Professional item formatting with enhanced styling
      static formatItem(item, format = "detailed") {
        var _a, _b;
        const statusBadge = ColorTheme.badge(
          item.status.toUpperCase(),
          this.getStatusVariant(item.status)
        );
        const priorityBadge = ColorTheme.badge(
          item.priority.toUpperCase(),
          this.getPriorityVariant(item.priority)
        );
        if (format === "compact") {
          return [
            `${statusBadge} ${priorityBadge} ${colors.highlight(item.title)}`,
            colors.muted(`ID: ${item.id}`),
            item.assignee ? colors.info(`@${item.assignee}`) : "",
            ((_a = item.tags) == null ? void 0 : _a.length) ? colors.muted(`[${item.tags.join(", ")}]`) : ""
          ].filter(Boolean).join(" ");
        }
        const sections = [
          `${statusBadge} ${priorityBadge}`,
          colors.highlight(item.title),
          colors.muted(`ID: ${item.id}`),
          item.assignee ? colors.info(`\u{1F464} Assignee: ${item.assignee}`) : "",
          item.description ? colors.muted(`\u{1F4DD} ${item.description}`) : "",
          item.estimate ? colors.warning(`\u{1F4CA} ${item.estimate} story points`) : "",
          ((_b = item.tags) == null ? void 0 : _b.length) ? colors.primary(`\u{1F3F7}\uFE0F  Tags: ${item.tags.join(", ")}`) : "",
          ColorTheme.timestamp(item.createdAt)
        ];
        return sections.filter(Boolean).join("\n");
      }
      // Enhanced list formatting with statistics
      static formatList(items, showStats = true) {
        if (items.length === 0) {
          return this.box("No items found", "info");
        }
        const formatted = items.map((item, index) => {
          const prefix = colors.muted(`${(index + 1).toString().padStart(2, " ")}. `);
          return `${prefix}${this.formatItem(item, "compact")}`;
        }).join("\n");
        if (!showStats) {
          return formatted;
        }
        const stats = this.generateStats(items);
        return `${formatted}

${stats}`;
      }
      // Generate item statistics
      static generateStats(items) {
        const total = items.length;
        const byStatus = this.groupBy(items, "status");
        const byPriority = this.groupBy(items, "priority");
        const statusSection = Object.entries(byStatus).map(([status, count]) => {
          const color = ColorTheme.status(status);
          return color(`${status}: ${count}`);
        }).join(" | ");
        const prioritySection = Object.entries(byPriority).map(([priority, count]) => {
          const color = ColorTheme.priority(priority);
          return color(`${priority}: ${count}`);
        }).join(" | ");
        return [
          ColorTheme.separator(),
          colors.highlight(`\u{1F4CA} Statistics (${total} total)`),
          `Status: ${statusSection}`,
          `Priority: ${prioritySection}`,
          ColorTheme.separator()
        ].join("\n");
      }
      // Enhanced table formatting
      static formatTable(items) {
        if (items.length === 0) {
          return this.box("No items found", "info");
        }
        const headers = ["ID", "Title", "Status", "Priority", "Assignee", "Tags"];
        const maxWidths = this.calculateColumnWidths(items, headers);
        const headerRow = headers.map((header, i) => colors.highlight(header.padEnd(maxWidths[i]))).join(" | ");
        const separator = ColorTheme.separator("\u2500", headerRow.length);
        const rows = items.map((item) => {
          var _a;
          const cells = [
            item.id,
            item.title.length > 30 ? item.title.substring(0, 27) + "..." : item.title,
            item.status,
            item.priority,
            item.assignee || "unassigned",
            ((_a = item.tags) == null ? void 0 : _a.join(", ")) || ""
          ];
          return cells.map((cell, i) => {
            const colored = i === 2 ? ColorTheme.status(cell)(cell) : i === 3 ? ColorTheme.priority(cell)(cell) : cell;
            return colored.padEnd(maxWidths[i]);
          }).join(" | ");
        });
        return [headerRow, separator, ...rows].join("\n");
      }
      // Format export output
      static formatExport(items, format) {
        switch (format) {
          case "json":
            return JSON.stringify(items, null, 2);
          case "csv":
            return this.formatCSV(items);
          case "yaml":
            return this.formatYAML(items);
          case "markdown":
            return this.formatMarkdown(items);
          default:
            return this.formatTable(items);
        }
      }
      // Enhanced help formatting
      static formatHelp(command, description, usage, options, examples) {
        const sections = [
          ColorTheme.header(`${command.toUpperCase()} COMMAND`),
          `${colors.info("Description:")} ${description}`,
          "",
          `${colors.info("Usage:")} ${ColorTheme.command(usage)}`,
          "",
          colors.info("Options:"),
          ...options.map((opt) => `  ${ColorTheme.option(opt.flag.padEnd(20))} ${opt.description}`),
          "",
          colors.info("Examples:"),
          ...examples.map((ex) => `  ${colors.muted("$")} ${ex}`)
        ];
        return sections.join("\n");
      }
      // Enhanced logging with context
      static log(level, message, context) {
        const timestamp = ColorTheme.timestamp(/* @__PURE__ */ new Date());
        const contextStr = context ? ` ${colors.muted(JSON.stringify(context))}` : "";
        switch (level) {
          case "debug":
            console.log(`${timestamp} ${this.debug(message)}${contextStr}`);
            break;
          case "info":
            console.log(`${timestamp} ${this.info(message)}${contextStr}`);
            break;
          case "warn":
            console.warn(`${timestamp} ${this.warning(message)}${contextStr}`);
            break;
          case "error":
            console.error(`${timestamp} ${this.error(message)}${contextStr}`);
            break;
        }
      }
      // Helper methods
      static getStatusVariant(status) {
        switch (status) {
          case "done":
            return "success";
          case "blocked":
            return "error";
          case "in-progress":
            return "warning";
          default:
            return "info";
        }
      }
      static getPriorityVariant(priority) {
        switch (priority) {
          case "critical":
            return "error";
          case "high":
            return "warning";
          case "medium":
            return "info";
          default:
            return "success";
        }
      }
      static groupBy(items, key) {
        return items.reduce(
          (acc, item) => {
            const value = String(item[key]);
            acc[value] = (acc[value] || 0) + 1;
            return acc;
          },
          {}
        );
      }
      static calculateColumnWidths(items, headers) {
        const rows = items.map((item) => {
          var _a;
          return [
            item.id,
            item.title.length > 30 ? item.title.substring(0, 27) + "..." : item.title,
            item.status,
            item.priority,
            item.assignee || "unassigned",
            ((_a = item.tags) == null ? void 0 : _a.join(", ")) || ""
          ];
        });
        return headers.map((header, i) => {
          const columnValues = [header, ...rows.map((row) => row[i])];
          return Math.max(...columnValues.map((val) => val.length)) + 2;
        });
      }
      static formatCSV(items) {
        const headers = [
          "ID",
          "Title",
          "Description",
          "Status",
          "Priority",
          "Assignee",
          "Created",
          "Updated",
          "Tags"
        ];
        const rows = items.map((item) => [
          item.id,
          `"${item.title.replace(/"/g, '""')}"`,
          `"${(item.description || "").replace(/"/g, '""')}"`,
          item.status,
          item.priority,
          item.assignee || "",
          item.createdAt.toISOString(),
          item.updatedAt.toISOString(),
          `"${(item.tags || []).join(", ")}"`
        ]);
        return [headers.join(","), ...rows.map((row) => row.join(","))].join("\n");
      }
      static formatYAML(items) {
        return items.map((item) => {
          return [
            `- id: ${item.id}`,
            `  title: "${item.title}"`,
            `  description: "${item.description || ""}"`,
            `  status: ${item.status}`,
            `  priority: ${item.priority}`,
            `  assignee: ${item.assignee || ""}`,
            `  created: ${item.createdAt.toISOString()}`,
            `  updated: ${item.updatedAt.toISOString()}`,
            `  tags: [${(item.tags || []).map((t) => `"${t}"`).join(", ")}]`
          ].join("\n");
        }).join("\n");
      }
      static formatMarkdown(items) {
        const table = [
          "| ID | Title | Status | Priority | Assignee | Tags |",
          "|---|---|---|---|---|---|",
          ...items.map(
            (item) => `| ${item.id} | ${item.title} | ${item.status} | ${item.priority} | ${item.assignee || ""} | ${(item.tags || []).join(", ")} |`
          )
        ].join("\n");
        return `# Trackdown Items

${table}

*Generated at ${(/* @__PURE__ */ new Date()).toISOString()}*`;
      }
    };
    __name(_Formatter, "Formatter");
    Formatter = _Formatter;
  }
});

// src/utils/validation.ts
function validateRequired(value, fieldName) {
  if (!value || value.trim().length === 0) {
    throw new ValidationError(
      `${fieldName} is required`,
      `Please provide a valid ${fieldName.toLowerCase()}`,
      1,
      void 0,
      ["Provide a non-empty value", "Check the command usage with --help"]
    );
  }
  return value.trim();
}
function validatePriority(priority) {
  const normalizedPriority = priority.toLowerCase().trim();
  const validPriorities = ["low", "medium", "high", "critical"];
  if (!validPriorities.includes(normalizedPriority)) {
    throw new ValidationError(
      `Invalid priority: ${priority}`,
      `Valid priorities are: ${validPriorities.join(", ")}`,
      1,
      "track",
      validPriorities.map((p) => `--priority ${p}`)
    );
  }
  return normalizedPriority;
}
function validateStatus(status) {
  const normalizedStatus = status.toLowerCase().trim();
  const validStatuses = ["todo", "in-progress", "done", "blocked"];
  if (!validStatuses.includes(normalizedStatus)) {
    throw new ValidationError(
      `Invalid status: ${status}`,
      `Valid statuses are: ${validStatuses.join(", ")}`,
      1,
      "status",
      validStatuses.map((s) => `--filter status=${s}`)
    );
  }
  return normalizedStatus;
}
function validateStoryPoints(points) {
  const num = Number.parseFloat(points);
  if (Number.isNaN(num)) {
    throw new ValidationError(
      `Invalid story points: ${points}`,
      "Story points must be a valid number",
      1,
      "track",
      ["1", "2.5", "5", "8", "13"]
    );
  }
  if (num < 0) {
    throw new ValidationError(
      "Story points cannot be negative",
      "Please provide a positive number",
      1,
      "track"
    );
  }
  if (num > 100) {
    throw new ValidationError(
      "Story points seem unusually high",
      "Consider breaking this task into smaller pieces",
      1,
      "track"
    );
  }
  return num;
}
function validateTags2(tagsString) {
  if (!tagsString || tagsString.trim().length === 0) {
    return [];
  }
  const tags = tagsString.split(",").map((tag) => tag.trim()).filter(Boolean);
  const tagRegex = /^[a-zA-Z0-9-_]+$/;
  const invalidTags = tags.filter((tag) => !tagRegex.test(tag));
  if (invalidTags.length > 0) {
    throw new ValidationError(
      `Invalid tags: ${invalidTags.join(", ")}`,
      "Tags can only contain letters, numbers, hyphens, and underscores",
      1,
      "track",
      ["bug", "feature", "urgent", "frontend"]
    );
  }
  const uniqueTags = [...new Set(tags)];
  if (uniqueTags.length !== tags.length) {
    throw new ValidationError("Duplicate tags detected", "Each tag should be unique", 1, "track");
  }
  return uniqueTags;
}
function validateAssignee(assignee) {
  const validAssignee = validateRequired(assignee, "Assignee");
  if (validAssignee.includes("@")) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(validAssignee)) {
      throw new ValidationError(
        `Invalid email format: ${validAssignee}`,
        "Please provide a valid email address",
        1,
        "track",
        ["user@example.com", "john.doe@company.com"]
      );
    }
  }
  const usernameRegex = /^[a-zA-Z0-9._-]+$/;
  if (!usernameRegex.test(validAssignee)) {
    throw new ValidationError(
      `Invalid assignee format: ${validAssignee}`,
      "Assignee can contain letters, numbers, dots, hyphens, and underscores",
      1,
      "track",
      ["john.doe", "user123", "team-lead"]
    );
  }
  return validAssignee;
}
function validateId(id) {
  const validId = validateRequired(id, "ID");
  const idRegex = /^[a-zA-Z0-9-_]+$/;
  if (!idRegex.test(validId)) {
    throw new ValidationError(
      `Invalid ID format: ${validId}`,
      "IDs can only contain letters, numbers, hyphens, and underscores",
      1,
      "track",
      ["TD-123", "feature-login", "bug_fix_001"]
    );
  }
  if (validId.length > 50) {
    throw new ValidationError(
      "ID is too long",
      "Please use an ID with 50 characters or less",
      1,
      "track"
    );
  }
  if (validId.length < 2) {
    throw new ValidationError(
      "ID is too short",
      "Please use an ID with at least 2 characters",
      1,
      "track"
    );
  }
  return validId;
}
var import_node_fs3, import_node_path3, _ValidationError, ValidationError;
var init_validation = __esm({
  "src/utils/validation.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_fs3 = require("fs");
    import_node_path3 = require("path");
    _ValidationError = class _ValidationError extends Error {
      exitCode;
      suggestion;
      command;
      validOptions;
      constructor(message, suggestion, exitCode = 1, command, validOptions) {
        super(message);
        this.name = "ValidationError";
        this.exitCode = exitCode;
        this.suggestion = suggestion;
        this.command = command;
        this.validOptions = validOptions;
      }
    };
    __name(_ValidationError, "ValidationError");
    ValidationError = _ValidationError;
    __name(validateRequired, "validateRequired");
    __name(validatePriority, "validatePriority");
    __name(validateStatus, "validateStatus");
    __name(validateStoryPoints, "validateStoryPoints");
    __name(validateTags2, "validateTags");
    __name(validateAssignee, "validateAssignee");
    __name(validateId, "validateId");
  }
});

// src/commands/export.ts
function createExportCommand() {
  const command = new import_commander.Command("export");
  command.description("Export trackdown data with advanced filtering and professional output formats").option("-f, --format <type>", "export format (json, yaml, csv, md, table)", "json").option("-o, --output <file>", "output file path (auto-generated if not specified)").option("--filter <expr>", 'advanced filter expression (e.g., "status=todo,priority=high")').option("-s, --status <status>", "filter by status (todo, in-progress, done, blocked)").option("-p, --priority <priority>", "filter by priority (low, medium, high, critical)").option("-a, --assignee <name>", "filter by assignee name or email").option("-t, --tags <tags>", "filter by tags (comma-separated)").option("-i, --id <id>", "filter by specific item ID").option("--created-after <date>", "show items created after date (YYYY-MM-DD)").option("--created-before <date>", "show items created before date (YYYY-MM-DD)").option("--updated-after <date>", "show items updated after date (YYYY-MM-DD)").option("--updated-before <date>", "show items updated before date (YYYY-MM-DD)").option("--estimate-min <points>", "minimum story points").option("--estimate-max <points>", "maximum story points").option("--include-completed", "include completed items", false).option("--include-descriptions", "include full descriptions in export", true).option("--include-metadata", "include export metadata and statistics", true).option(
    "--sort <field>",
    "sort by field (created, updated, priority, status, title)",
    "updated"
  ).option("--order <direction>", "sort order (asc, desc)", "desc").option("--limit <count>", "limit number of results exported").option("--interactive", "interactive export configuration mode").option("--preview", "preview export without saving to file").option("--compress", "compress output for large exports").option("--template <name>", "use export template (summary, detailed, minimal)").addHelpText(
    "after",
    `
Examples:
  $ aitrackdown export
  $ aitrackdown export --format csv --output project-data.csv
  $ aitrackdown export --filter "status=todo,priority=high" --format json
  $ aitrackdown export --assignee john.doe --created-after 2024-01-01
  $ aitrackdown export --tags backend,security --format yaml
  $ aitrackdown export --interactive
  $ aitrackdown export --preview --format table
  $ aitrackdown export --template summary --format md

Export Formats:
  json          - Structured JSON with metadata
  yaml          - YAML format for configuration management
  csv           - Spreadsheet-compatible format
  md            - Markdown format for documentation
  table         - Human-readable table format

Filter Expressions:
  status=todo,blocked        - Multiple status values
  priority=high              - Single priority
  assignee=john.doe          - Specific assignee
  tags=backend,api           - Items with any of these tags
  estimate=5-13              - Story points range

Export Templates:
  summary       - Basic information only
  detailed      - Full item details with descriptions
  minimal       - ID, title, status only
`
  ).action(
    async (options) => {
      var _a, _b;
      try {
        let currentOptions = options;
        if (options == null ? void 0 : options.interactive) {
          currentOptions = await runInteractiveExportMode(options);
        }
        const parentCommand = command.parent;
        const rootDirOption = ((_a = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _a.rootDir) || ((_b = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _b.tasksDir);
        const configManager = new ConfigManager();
        const config = configManager.getConfig();
        const pathResolver = new PathResolver(configManager, rootDirOption);
        const trackdownDir = (0, import_node_path4.join)(process.cwd(), pathResolver.getRootDirectory());
        if (!(0, import_node_fs4.existsSync)(trackdownDir)) {
          if (pathResolver.shouldMigrate()) {
            pathResolver.showMigrationWarning();
            console.log("\nMigration commands:");
            pathResolver.getMigrationCommands().forEach((cmd) => {
              console.log(Formatter.highlight(cmd));
            });
            process.exit(1);
          }
          console.error(Formatter.error(`No ${pathResolver.getRootDirectory()} project found in current directory`));
          console.log(Formatter.info('Run "aitrackdown init" to initialize a new project'));
          process.exit(1);
        }
        const exportConfig = await validateAndProcessExportOptions(currentOptions, config);
        console.log(Formatter.header("\u{1F680} Starting Export Process"));
        const spinner = (0, import_ora.default)("Collecting trackdown items...").start();
        try {
          const items = collectItems(trackdownDir, exportConfig.includeCompleted, pathResolver);
          spinner.text = `Processing ${items.length} items...`;
          const filters = parseAdvancedFilters(exportConfig);
          const filteredItems = applyAdvancedFilters(items, filters);
          if (filteredItems.length === 0) {
            spinner.fail("No items match the specified filters");
            console.log(
              Formatter.info("Try adjusting your filter criteria or use --interactive mode")
            );
            return;
          }
          const sortedItems = sortItems(filteredItems, exportConfig.sort, exportConfig.order);
          const finalItems = exportConfig.limit ? sortedItems.slice(0, parseInt(exportConfig.limit)) : sortedItems;
          spinner.succeed(`Prepared ${finalItems.length} items for export`);
          if (exportConfig.preview) {
            console.log(Formatter.header("\u{1F4CB} Export Preview"));
            await displayExportPreview(finalItems, exportConfig);
            return;
          }
          const progressSpinner = (0, import_ora.default)("Generating export data...").start();
          const exportedData = await generateAdvancedExportData(
            finalItems,
            exportConfig,
            config.projectName
          );
          if (exportConfig.output) {
            const outputPath = resolveOutputPath(exportConfig.output, trackdownDir, pathResolver);
            ensureDirectoryExists(outputPath);
            progressSpinner.text = "Writing export file...";
            (0, import_node_fs4.writeFileSync)(outputPath, exportedData);
            progressSpinner.succeed(`Export saved to ${outputPath}`);
            displayExportSummary(finalItems, exportConfig, outputPath);
          } else {
            progressSpinner.succeed("Export data generated");
            console.log(exportedData);
          }
        } catch (processingError) {
          spinner.fail("Export processing failed");
          throw processingError;
        }
      } catch (error) {
        console.error(
          Formatter.error(
            `Export failed: ${error instanceof Error ? error.message : "Unknown error"}`
          )
        );
        if (error instanceof ValidationError) {
          console.log(
            Formatter.info("Use --help for usage information or --interactive for guided setup")
          );
        }
        process.exit(1);
      }
    }
  );
  return command;
}
async function runInteractiveExportMode(currentOptions) {
  console.log(Formatter.header("\u{1F4E4} Interactive Export Configuration"));
  const answers = await import_inquirer.default.prompt([
    {
      type: "list",
      name: "format",
      message: "Select export format:",
      choices: [
        { name: "JSON - Structured data with metadata", value: "json" },
        { name: "CSV - Spreadsheet compatible", value: "csv" },
        { name: "YAML - Configuration friendly", value: "yaml" },
        { name: "Markdown - Documentation format", value: "md" },
        { name: "Table - Human readable", value: "table" }
      ],
      default: (currentOptions == null ? void 0 : currentOptions.format) || "json"
    },
    {
      type: "input",
      name: "output",
      message: "Output file path (leave empty for auto-generated):",
      default: (currentOptions == null ? void 0 : currentOptions.output) || ""
    },
    {
      type: "list",
      name: "template",
      message: "Choose export template:",
      choices: [
        { name: "Detailed - Full information with descriptions", value: "detailed" },
        { name: "Summary - Essential information only", value: "summary" },
        { name: "Minimal - ID, title, status only", value: "minimal" }
      ],
      default: (currentOptions == null ? void 0 : currentOptions.template) || "detailed"
    },
    {
      type: "checkbox",
      name: "statusFilter",
      message: "Filter by status (select multiple):",
      choices: [
        { name: "Todo", value: "todo" },
        { name: "In Progress", value: "in-progress" },
        { name: "Blocked", value: "blocked" },
        { name: "Done", value: "done" }
      ],
      default: (currentOptions == null ? void 0 : currentOptions.status) ? [currentOptions.status] : []
    },
    {
      type: "checkbox",
      name: "priorityFilter",
      message: "Filter by priority (select multiple):",
      choices: [
        { name: "Critical", value: "critical" },
        { name: "High", value: "high" },
        { name: "Medium", value: "medium" },
        { name: "Low", value: "low" }
      ],
      default: (currentOptions == null ? void 0 : currentOptions.priority) ? [currentOptions.priority] : []
    },
    {
      type: "input",
      name: "assignee",
      message: "Filter by assignee (leave empty for all):",
      default: (currentOptions == null ? void 0 : currentOptions.assignee) || ""
    },
    {
      type: "input",
      name: "tags",
      message: "Filter by tags (comma-separated):",
      default: (currentOptions == null ? void 0 : currentOptions.tags) || ""
    },
    {
      type: "input",
      name: "limit",
      message: "Limit number of items (leave empty for all):",
      default: (currentOptions == null ? void 0 : currentOptions.limit) || ""
    },
    {
      type: "list",
      name: "sort",
      message: "Sort by:",
      choices: [
        { name: "Last Updated", value: "updated" },
        { name: "Created Date", value: "created" },
        { name: "Priority", value: "priority" },
        { name: "Status", value: "status" },
        { name: "Title", value: "title" }
      ],
      default: (currentOptions == null ? void 0 : currentOptions.sort) || "updated"
    },
    {
      type: "list",
      name: "order",
      message: "Sort order:",
      choices: [
        { name: "Descending (newest first)", value: "desc" },
        { name: "Ascending (oldest first)", value: "asc" }
      ],
      default: (currentOptions == null ? void 0 : currentOptions.order) || "desc"
    },
    {
      type: "confirm",
      name: "includeCompleted",
      message: "Include completed items?",
      default: (currentOptions == null ? void 0 : currentOptions.includeCompleted) || false
    },
    {
      type: "confirm",
      name: "includeDescriptions",
      message: "Include item descriptions?",
      default: (currentOptions == null ? void 0 : currentOptions.includeDescriptions) !== false
    },
    {
      type: "confirm",
      name: "includeMetadata",
      message: "Include export metadata and statistics?",
      default: (currentOptions == null ? void 0 : currentOptions.includeMetadata) !== false
    },
    {
      type: "confirm",
      name: "preview",
      message: "Preview export without saving?",
      default: (currentOptions == null ? void 0 : currentOptions.preview) || false
    }
  ]);
  const processedOptions = {
    ...currentOptions,
    format: answers.format,
    output: answers.output || void 0,
    template: answers.template,
    status: answers.statusFilter.length > 0 ? answers.statusFilter.join(",") : void 0,
    priority: answers.priorityFilter.length > 0 ? answers.priorityFilter.join(",") : void 0,
    assignee: answers.assignee || void 0,
    tags: answers.tags || void 0,
    limit: answers.limit || void 0,
    sort: answers.sort,
    order: answers.order,
    includeCompleted: answers.includeCompleted,
    includeDescriptions: answers.includeDescriptions,
    includeMetadata: answers.includeMetadata,
    preview: answers.preview
  };
  console.log(Formatter.success("Export configuration completed!"));
  return processedOptions;
}
async function validateAndProcessExportOptions(options, config) {
  const exportConfig = {
    format: (options == null ? void 0 : options.format) || config.outputFormat || "json",
    output: options == null ? void 0 : options.output,
    includeCompleted: (options == null ? void 0 : options.includeCompleted) || false,
    includeDescriptions: (options == null ? void 0 : options.includeDescriptions) !== false,
    includeMetadata: (options == null ? void 0 : options.includeMetadata) !== false,
    sort: (options == null ? void 0 : options.sort) || "updated",
    order: (options == null ? void 0 : options.order) || "desc",
    limit: options == null ? void 0 : options.limit,
    template: (options == null ? void 0 : options.template) || "detailed",
    preview: (options == null ? void 0 : options.preview) || false,
    compress: (options == null ? void 0 : options.compress) || false,
    ...options
  };
  const supportedFormats = ["json", "yaml", "csv", "md", "table"];
  if (!supportedFormats.includes(exportConfig.format)) {
    throw new ValidationError(
      `Unsupported format: ${exportConfig.format}. Supported: ${supportedFormats.join(", ")}`
    );
  }
  const supportedTemplates = ["summary", "detailed", "minimal"];
  if (exportConfig.template && !supportedTemplates.includes(exportConfig.template)) {
    throw new ValidationError(
      `Unsupported template: ${exportConfig.template}. Supported: ${supportedTemplates.join(", ")}`
    );
  }
  if (exportConfig.status) {
    const statuses = exportConfig.status.split(",").map((s) => s.trim());
    for (const status of statuses) {
      validateStatus(status);
    }
  }
  if (exportConfig.priority) {
    const priorities = exportConfig.priority.split(",").map((p) => p.trim());
    for (const priority of priorities) {
      validatePriority(priority);
    }
  }
  if (exportConfig.assignee) {
    validateAssignee(exportConfig.assignee);
  }
  if (exportConfig.limit) {
    const limit = parseInt(exportConfig.limit);
    if (isNaN(limit) || limit <= 0) {
      throw new ValidationError("Limit must be a positive number");
    }
  }
  const validSortFields = ["created", "updated", "priority", "status", "title"];
  if (!validSortFields.includes(exportConfig.sort)) {
    throw new ValidationError(
      `Invalid sort field: ${exportConfig.sort}. Valid: ${validSortFields.join(", ")}`
    );
  }
  if (!["asc", "desc"].includes(exportConfig.order)) {
    throw new ValidationError('Sort order must be "asc" or "desc"');
  }
  return exportConfig;
}
function parseAdvancedFilters(options) {
  const filters = {};
  if (options.filter) {
    const filterParts = options.filter.split(",");
    for (const part of filterParts) {
      const [key, value] = part.split("=");
      if (key && value) {
        const trimmedKey = key.trim();
        const trimmedValue = value.trim();
        switch (trimmedKey) {
          case "status":
            filters.status = trimmedValue.split(",").map((s) => s.trim());
            break;
          case "priority":
            filters.priority = trimmedValue.split(",").map((p) => p.trim());
            break;
          case "assignee":
            filters.assignee = trimmedValue;
            break;
          case "tags":
            filters.tags = trimmedValue.split(",").map((t) => t.trim());
            break;
          case "estimate":
            if (trimmedValue.includes("-")) {
              const [min, max] = trimmedValue.split("-").map((n) => parseInt(n.trim()));
              filters.estimateMin = min;
              filters.estimateMax = max;
            } else {
              filters.estimate = parseInt(trimmedValue);
            }
            break;
        }
      }
    }
  }
  if (options.status) {
    filters.status = options.status.split(",").map((s) => s.trim());
  }
  if (options.priority) {
    filters.priority = options.priority.split(",").map((p) => p.trim());
  }
  if (options.assignee) {
    filters.assignee = options.assignee;
  }
  if (options.tags) {
    filters.tags = options.tags.split(",").map((t) => t.trim());
  }
  if (options.id) {
    filters.id = options.id;
  }
  if (options.createdAfter) {
    filters.createdAfter = new Date(options.createdAfter);
  }
  if (options.createdBefore) {
    filters.createdBefore = new Date(options.createdBefore);
  }
  if (options.updatedAfter) {
    filters.updatedAfter = new Date(options.updatedAfter);
  }
  if (options.updatedBefore) {
    filters.updatedBefore = new Date(options.updatedBefore);
  }
  if (options.estimateMin) {
    filters.estimateMin = parseInt(options.estimateMin);
  }
  if (options.estimateMax) {
    filters.estimateMax = parseInt(options.estimateMax);
  }
  return filters;
}
function applyAdvancedFilters(items, filters) {
  return items.filter((item) => {
    if (filters.status && !filters.status.includes(item.status)) {
      return false;
    }
    if (filters.priority && !filters.priority.includes(item.priority)) {
      return false;
    }
    if (filters.assignee && item.assignee !== filters.assignee) {
      return false;
    }
    if (filters.id && item.id !== filters.id) {
      return false;
    }
    if (filters.tags && filters.tags.length > 0) {
      if (!item.tags || !filters.tags.some((tag) => {
        var _a;
        return (_a = item.tags) == null ? void 0 : _a.includes(tag);
      })) {
        return false;
      }
    }
    if (filters.createdAfter && item.createdAt < filters.createdAfter) {
      return false;
    }
    if (filters.createdBefore && item.createdAt > filters.createdBefore) {
      return false;
    }
    if (filters.updatedAfter && item.updatedAt < filters.updatedAfter) {
      return false;
    }
    if (filters.updatedBefore && item.updatedAt > filters.updatedBefore) {
      return false;
    }
    if (filters.estimate && item.estimate !== filters.estimate) {
      return false;
    }
    if (filters.estimateMin && (!item.estimate || item.estimate < filters.estimateMin)) {
      return false;
    }
    if (filters.estimateMax && (!item.estimate || item.estimate > filters.estimateMax)) {
      return false;
    }
    return true;
  });
}
function sortItems(items, sortField, order) {
  const sortedItems = [...items];
  sortedItems.sort((a, b) => {
    let comparison = 0;
    switch (sortField) {
      case "created":
        comparison = a.createdAt.getTime() - b.createdAt.getTime();
        break;
      case "updated":
        comparison = a.updatedAt.getTime() - b.updatedAt.getTime();
        break;
      case "priority":
        const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        comparison = (priorityOrder[a.priority] || 0) - (priorityOrder[b.priority] || 0);
        break;
      case "status":
        const statusOrder = { todo: 1, "in-progress": 2, blocked: 3, done: 4 };
        comparison = (statusOrder[a.status] || 0) - (statusOrder[b.status] || 0);
        break;
      case "title":
        comparison = a.title.localeCompare(b.title);
        break;
      default:
        comparison = 0;
    }
    return order === "desc" ? -comparison : comparison;
  });
  return sortedItems;
}
async function displayExportPreview(items, config) {
  console.log(
    Formatter.subheader(`Preview: ${items.length} items in ${config.format.toUpperCase()} format`)
  );
  if (config.format === "table" || items.length <= 10) {
    const previewData = await generateAdvancedExportData(items, config, "preview-project");
    console.log(previewData);
  } else {
    const sampleItems = items.slice(0, 3);
    console.log(Formatter.info(`Showing first 3 items (${items.length} total):`));
    const sampleData = await generateAdvancedExportData(sampleItems, config, "preview-project");
    console.log(sampleData);
    console.log(Formatter.dim("... (additional items truncated for preview)"));
  }
  console.log(Formatter.info(`Full export would contain ${items.length} items`));
}
function resolveOutputPath(outputPath, trackdownDir, pathResolver) {
  if (outputPath.startsWith("/") || outputPath.includes(":")) {
    return outputPath;
  } else {
    return (0, import_node_path4.join)(process.cwd(), pathResolver.getExportsDir(), outputPath);
  }
}
function ensureDirectoryExists(filePath) {
  const dir = (0, import_node_path4.join)(filePath, "..");
  if (!(0, import_node_fs4.existsSync)(dir)) {
    (0, import_node_fs4.mkdirSync)(dir, { recursive: true });
  }
}
function displayExportSummary(items, config, outputPath) {
  console.log("");
  console.log(Formatter.header("\u{1F4CA} Export Summary"));
  console.log(Formatter.success(`\u2705 Successfully exported ${items.length} items`));
  console.log(Formatter.info(`\u{1F4C1} Output: ${outputPath}`));
  console.log(Formatter.info(`\u{1F4CB} Format: ${config.format.toUpperCase()}`));
  console.log(Formatter.info(`\u{1F4DD} Template: ${config.template}`));
  const statusCounts = items.reduce(
    (acc, item) => {
      acc[item.status] = (acc[item.status] || 0) + 1;
      return acc;
    },
    {}
  );
  console.log("");
  console.log(Formatter.subheader("Status Breakdown:"));
  Object.entries(statusCounts).forEach(([status, count]) => {
    console.log(`  ${status}: ${count}`);
  });
  const priorityCounts = items.reduce(
    (acc, item) => {
      acc[item.priority] = (acc[item.priority] || 0) + 1;
      return acc;
    },
    {}
  );
  console.log("");
  console.log(Formatter.subheader("Priority Breakdown:"));
  Object.entries(priorityCounts).forEach(([priority, count]) => {
    console.log(`  ${priority}: ${count}`);
  });
  try {
    const stats = (0, import_node_fs4.statSync)(outputPath);
    const fileSizeKB = (stats.size / 1024).toFixed(2);
    console.log("");
    console.log(Formatter.info(`\u{1F4CA} File size: ${fileSizeKB} KB`));
  } catch {
  }
}
async function generateAdvancedExportData(items, config, projectName) {
  const metadata = {
    project: projectName || "trackdown-project",
    exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
    itemCount: items.length,
    format: config.format,
    template: config.template,
    filters: getAppliedFiltersInfo(config),
    sorting: {
      field: config.sort,
      order: config.order
    }
  };
  const processedItems = applyTemplate(items, config.template, config);
  switch (config.format) {
    case "json":
      return generateJSONExport(processedItems, metadata, config);
    case "yaml":
      return generateYAMLExport(processedItems, metadata, config);
    case "csv":
      return generateCSVExport(processedItems, metadata, config);
    case "md":
      return generateMarkdownExport(processedItems, metadata, config);
    case "table":
      return generateTableExport(processedItems, metadata, config);
    default:
      throw new Error(`Unsupported format: ${config.format}`);
  }
}
function applyTemplate(items, template, config) {
  switch (template) {
    case "minimal":
      return items.map((item) => ({
        id: item.id,
        title: item.title,
        status: item.status
      }));
    case "summary":
      return items.map((item) => ({
        id: item.id,
        title: item.title,
        status: item.status,
        priority: item.priority,
        assignee: item.assignee,
        createdAt: item.createdAt,
        updatedAt: item.updatedAt,
        tags: item.tags
      }));
    case "detailed":
    default:
      return items.map((item) => ({
        ...item,
        description: config.includeDescriptions ? item.description : void 0
      }));
  }
}
function generateJSONExport(items, metadata, config) {
  const exportData = {
    ...config.includeMetadata ? { metadata } : {},
    items
  };
  return JSON.stringify(exportData, null, 2);
}
function generateYAMLExport(items, metadata, config) {
  const lines = [];
  if (config.includeMetadata) {
    lines.push("metadata:");
    lines.push(`  project: "${metadata.project}"`);
    lines.push(`  exportedAt: "${metadata.exportedAt}"`);
    lines.push(`  itemCount: ${metadata.itemCount}`);
    lines.push(`  format: "${metadata.format}"`);
    lines.push(`  template: "${metadata.template}"`);
    lines.push("");
  }
  lines.push("items:");
  for (const item of items) {
    lines.push(`  - id: "${item.id}"`);
    lines.push(`    title: "${item.title}"`);
    lines.push(`    status: "${item.status}"`);
    if (item.priority) lines.push(`    priority: "${item.priority}"`);
    if (item.assignee) lines.push(`    assignee: "${item.assignee}"`);
    if (item.description) lines.push(`    description: "${item.description.replace(/"/g, '\\"')}"`);
    if (item.estimate) lines.push(`    estimate: ${item.estimate}`);
    if (item.createdAt) lines.push(`    createdAt: "${item.createdAt.toISOString()}"`);
    if (item.updatedAt) lines.push(`    updatedAt: "${item.updatedAt.toISOString()}"`);
    if (item.tags && item.tags.length > 0) {
      lines.push(`    tags: [${item.tags.map((tag) => `"${tag}"`).join(", ")}]`);
    }
  }
  return lines.join("\n");
}
function generateCSVExport(items, metadata, config) {
  const headers = Object.keys(items[0] || {}).filter(
    (key) => key !== "createdAt" && key !== "updatedAt" || config.template === "detailed"
  );
  if (config.template === "detailed") {
    headers.push("createdAt", "updatedAt");
  }
  const headerRow = headers.join(",");
  const dataRows = items.map((item) => {
    return headers.map((header) => {
      const value = item[header];
      if (value === void 0 || value === null) return "";
      if (Array.isArray(value)) return `"${value.join(", ")}"`;
      if (typeof value === "string" && value.includes(","))
        return `"${value.replace(/"/g, '""')}"`;
      if (value instanceof Date) return value.toISOString();
      return String(value);
    }).join(",");
  });
  const csvContent = [headerRow, ...dataRows].join("\n");
  if (config.includeMetadata) {
    const metadataLines = [
      `# Export Metadata`,
      `# Project: ${metadata.project}`,
      `# Exported: ${metadata.exportedAt}`,
      `# Items: ${metadata.itemCount}`,
      `# Template: ${metadata.template}`,
      `#`,
      csvContent
    ];
    return metadataLines.join("\n");
  }
  return csvContent;
}
function generateMarkdownExport(items, metadata, config) {
  const lines = [];
  lines.push(`# ${metadata.project} Export`);
  lines.push("");
  if (config.includeMetadata) {
    lines.push(`**Exported**: ${metadata.exportedAt}`);
    lines.push(`**Items**: ${metadata.itemCount}`);
    lines.push(`**Format**: ${metadata.format}`);
    lines.push(`**Template**: ${metadata.template}`);
    lines.push("");
  }
  lines.push("## Items");
  lines.push("");
  for (const item of items) {
    lines.push(`### ${item.title}`);
    lines.push("");
    lines.push(`- **ID**: ${item.id}`);
    lines.push(`- **Status**: ${item.status}`);
    if (item.priority) lines.push(`- **Priority**: ${item.priority}`);
    if (item.assignee) lines.push(`- **Assignee**: ${item.assignee}`);
    if (item.estimate) lines.push(`- **Estimate**: ${item.estimate} story points`);
    if (item.createdAt) lines.push(`- **Created**: ${item.createdAt.toISOString().split("T")[0]}`);
    if (item.updatedAt) lines.push(`- **Updated**: ${item.updatedAt.toISOString().split("T")[0]}`);
    if (item.tags && item.tags.length > 0) {
      lines.push(`- **Tags**: ${item.tags.join(", ")}`);
    }
    lines.push("");
    if (item.description) {
      lines.push(item.description);
      lines.push("");
    }
    lines.push("---");
    lines.push("");
  }
  return lines.join("\n");
}
function generateTableExport(items, metadata, config) {
  return Formatter.formatTable(items);
}
function getAppliedFiltersInfo(config) {
  const filters = {};
  if (config.status) filters.status = config.status;
  if (config.priority) filters.priority = config.priority;
  if (config.assignee) filters.assignee = config.assignee;
  if (config.tags) filters.tags = config.tags;
  if (config.createdAfter) filters.createdAfter = config.createdAfter;
  if (config.createdBefore) filters.createdBefore = config.createdBefore;
  if (config.updatedAfter) filters.updatedAfter = config.updatedAfter;
  if (config.updatedBefore) filters.updatedBefore = config.updatedBefore;
  if (config.estimateMin) filters.estimateMin = config.estimateMin;
  if (config.estimateMax) filters.estimateMax = config.estimateMax;
  if (config.limit) filters.limit = config.limit;
  return filters;
}
function collectItems(trackdownDir, includeCompleted, pathResolver) {
  const items = [];
  const directories = [pathResolver.getActiveDir()];
  if (includeCompleted) {
    directories.push(pathResolver.getCompletedDir());
  }
  for (const dir of directories) {
    const fullPath = (0, import_node_path4.join)(process.cwd(), dir);
    if ((0, import_node_fs4.existsSync)(fullPath)) {
      const files = (0, import_node_fs4.readdirSync)(fullPath).filter((file) => file.endsWith(".md"));
      for (const file of files) {
        try {
          const item = parseTrackdownFile((0, import_node_path4.join)(fullPath, file));
          if (item) {
            items.push(item);
          }
        } catch (_error) {
          console.warn(Formatter.warning(`Could not parse file: ${file}`));
        }
      }
    }
  }
  return items.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
}
function parseTrackdownFile(filePath) {
  var _a, _b, _c, _d;
  try {
    const content = (0, import_node_fs4.readFileSync)(filePath, "utf-8");
    const titleMatch = content.match(/^# (.+)$/m);
    const idMatch = content.match(/\*\*ID\*\*:\s*(.+)$/m);
    const statusMatch = content.match(/\*\*Status\*\*:\s*(.+)$/m);
    const priorityMatch = content.match(/\*\*Priority\*\*:\s*(.+)$/m);
    const assigneeMatch = content.match(/\*\*Assignee\*\*:\s*(.+)$/m);
    const createdMatch = content.match(/\*\*Created\*\*:\s*(.+)$/m);
    const updatedMatch = content.match(/\*\*Updated\*\*:\s*(.+)$/m);
    const tagsMatch = content.match(/\*\*Tags\*\*:\s*(.+)$/m);
    const estimateMatch = content.match(/\*\*Estimate\*\*:\s*(.+)$/m);
    if (!titleMatch || !idMatch) {
      return null;
    }
    const descriptionMatch = content.match(/## Description\n\n(.*?)(\n\n##|\n\n---|\n\n$)/s);
    const tags = tagsMatch ? tagsMatch[1].split(",").map((tag) => tag.trim().replace(/`/g, "")).filter(Boolean) : void 0;
    return {
      id: idMatch[1].trim(),
      title: titleMatch[1].trim(),
      description: descriptionMatch ? descriptionMatch[1].trim() : void 0,
      status: ((_a = statusMatch == null ? void 0 : statusMatch[1]) == null ? void 0 : _a.trim()) || "todo",
      priority: ((_b = priorityMatch == null ? void 0 : priorityMatch[1]) == null ? void 0 : _b.trim()) || "medium",
      assignee: ((_c = assigneeMatch == null ? void 0 : assigneeMatch[1]) == null ? void 0 : _c.trim()) !== "Unassigned" ? (_d = assigneeMatch == null ? void 0 : assigneeMatch[1]) == null ? void 0 : _d.trim() : void 0,
      createdAt: createdMatch ? new Date(createdMatch[1].trim()) : /* @__PURE__ */ new Date(),
      updatedAt: updatedMatch ? new Date(updatedMatch[1].trim()) : /* @__PURE__ */ new Date(),
      estimate: estimateMatch ? parseInt(estimateMatch[1].trim()) : void 0,
      tags
    };
  } catch (_error) {
    return null;
  }
}
var import_node_fs4, import_node_path4, import_commander, import_inquirer, import_ora;
var init_export = __esm({
  "src/commands/export.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_fs4 = require("fs");
    import_node_path4 = require("path");
    import_commander = require("commander");
    import_inquirer = __toESM(require("inquirer"), 1);
    import_ora = __toESM(require("ora"), 1);
    init_config();
    init_path_resolver();
    init_formatter();
    init_validation();
    __name(createExportCommand, "createExportCommand");
    __name(runInteractiveExportMode, "runInteractiveExportMode");
    __name(validateAndProcessExportOptions, "validateAndProcessExportOptions");
    __name(parseAdvancedFilters, "parseAdvancedFilters");
    __name(applyAdvancedFilters, "applyAdvancedFilters");
    __name(sortItems, "sortItems");
    __name(displayExportPreview, "displayExportPreview");
    __name(resolveOutputPath, "resolveOutputPath");
    __name(ensureDirectoryExists, "ensureDirectoryExists");
    __name(displayExportSummary, "displayExportSummary");
    __name(generateAdvancedExportData, "generateAdvancedExportData");
    __name(applyTemplate, "applyTemplate");
    __name(generateJSONExport, "generateJSONExport");
    __name(generateYAMLExport, "generateYAMLExport");
    __name(generateCSVExport, "generateCSVExport");
    __name(generateMarkdownExport, "generateMarkdownExport");
    __name(generateTableExport, "generateTableExport");
    __name(getAppliedFiltersInfo, "getAppliedFiltersInfo");
    __name(collectItems, "collectItems");
    __name(parseTrackdownFile, "parseTrackdownFile");
  }
});

// src/utils/unified-path-resolver.ts
var import_node_path5, import_node_fs5, _UnifiedPathResolver, UnifiedPathResolver;
var init_unified_path_resolver = __esm({
  "src/utils/unified-path-resolver.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_path5 = require("path");
    import_node_fs5 = require("fs");
    _UnifiedPathResolver = class _UnifiedPathResolver {
      config;
      projectRoot;
      cliTasksDir;
      // CLI override via --tasks-dir or --root-dir
      constructor(config, projectRoot, cliTasksDir) {
        this.config = config;
        this.projectRoot = projectRoot;
        this.cliTasksDir = cliTasksDir;
      }
      /**
       * Get the tasks root directory with proper priority resolution:
       * 1. CLI option override (--root-dir, --tasks-dir)
       * 2. Environment variable (AITRACKDOWN_TASKS_DIR)
       * 3. Config file setting (tasks_directory)
       * 4. Default to "tasks"
       */
      getTasksRootDirectory() {
        if (this.cliTasksDir) {
          return this.cliTasksDir;
        }
        const envTasksDir = process.env.AITRACKDOWN_TASKS_DIR || process.env.AITRACKDOWN_ROOT_DIR;
        if (envTasksDir) {
          return envTasksDir;
        }
        if (this.config.tasks_directory) {
          return this.config.tasks_directory;
        }
        return "tasks";
      }
      /**
       * Get all unified paths following the required structure
       */
      getUnifiedPaths() {
        const tasksRoot = this.getTasksRootDirectory();
        return {
          projectRoot: this.projectRoot,
          configDir: (0, import_node_path5.join)(this.projectRoot, ".ai-trackdown"),
          tasksRoot: (0, import_node_path5.join)(this.projectRoot, tasksRoot),
          epicsDir: (0, import_node_path5.join)(this.projectRoot, tasksRoot, this.config.structure.epics_dir),
          issuesDir: (0, import_node_path5.join)(this.projectRoot, tasksRoot, this.config.structure.issues_dir),
          tasksDir: (0, import_node_path5.join)(this.projectRoot, tasksRoot, this.config.structure.tasks_dir),
          prsDir: (0, import_node_path5.join)(this.projectRoot, tasksRoot, this.config.structure.prs_dir || "prs"),
          templatesDir: (0, import_node_path5.join)(this.projectRoot, tasksRoot, this.config.structure.templates_dir)
        };
      }
      /**
       * Get path for specific item type
       */
      getItemTypeDirectory(type) {
        const paths = this.getUnifiedPaths();
        switch (type) {
          case "epic":
            return paths.epicsDir;
          case "issue":
            return paths.issuesDir;
          case "task":
            return paths.tasksDir;
          case "pr":
            return paths.prsDir;
          default:
            throw new Error(`Unknown item type: ${type}`);
        }
      }
      /**
       * Get all directories that should be created for the unified structure
       */
      getRequiredDirectories() {
        const paths = this.getUnifiedPaths();
        return [
          paths.configDir,
          paths.tasksRoot,
          paths.epicsDir,
          paths.issuesDir,
          paths.tasksDir,
          paths.prsDir,
          paths.templatesDir
        ];
      }
      /**
       * Check if legacy directory structure exists (separate root directories)
       */
      detectLegacyStructure() {
        const legacyDirs = [];
        const suggestions = [];
        const potentialLegacyDirs = [
          (0, import_node_path5.join)(this.projectRoot, "epics"),
          (0, import_node_path5.join)(this.projectRoot, "issues"),
          (0, import_node_path5.join)(this.projectRoot, "tasks"),
          (0, import_node_path5.join)(this.projectRoot, "prs"),
          (0, import_node_path5.join)(this.projectRoot, "trackdown")
          // Old trackdown structure
        ];
        for (const dir of potentialLegacyDirs) {
          if ((0, import_node_fs5.existsSync)(dir)) {
            legacyDirs.push(dir);
          }
        }
        if (legacyDirs.length > 0) {
          const tasksRoot = this.getTasksRootDirectory();
          suggestions.push(
            `# Detected legacy directory structure. Migration options:`,
            ``,
            `# Option 1: Use CLI override to maintain current structure`,
            `export AITRACKDOWN_TASKS_DIR=""  # Use project root`,
            ``,
            `# Option 2: Migrate to unified structure`,
            `mkdir -p ${tasksRoot}`,
            ...legacyDirs.map((dir) => {
              const dirName = dir.split("/").pop();
              return `mv ${dirName} ${tasksRoot}/${dirName} 2>/dev/null || true`;
            }),
            ``,
            `# Option 3: Update configuration`,
            `# Edit .ai-trackdown/config.yaml and set:`,
            `# tasks_directory: ""  # Use project root`
          );
        }
        return {
          hasLegacy: legacyDirs.length > 0,
          legacyDirs,
          suggestions
        };
      }
      /**
       * Get migration commands for moving to unified structure
       */
      getMigrationCommands() {
        const legacy = this.detectLegacyStructure();
        if (!legacy.hasLegacy) {
          return [];
        }
        return legacy.suggestions;
      }
      /**
       * Validate current directory structure
       */
      validateStructure() {
        const paths = this.getUnifiedPaths();
        const issues = [];
        const missingDirs = [];
        const requiredDirs = this.getRequiredDirectories();
        for (const dir of requiredDirs) {
          if (!(0, import_node_fs5.existsSync)(dir)) {
            missingDirs.push(dir);
          }
        }
        const legacy = this.detectLegacyStructure();
        if (legacy.hasLegacy) {
          issues.push(`Legacy directory structure detected: ${legacy.legacyDirs.join(", ")}`);
        }
        return {
          valid: issues.length === 0 && missingDirs.length === 0,
          issues,
          missingDirs
        };
      }
      /**
       * Update CLI tasks directory override
       */
      setCliTasksDir(tasksDir) {
        this.cliTasksDir = tasksDir;
      }
      /**
       * Clear CLI tasks directory override
       */
      clearCliTasksDir() {
        this.cliTasksDir = void 0;
      }
      /**
       * Show structure information for debugging
       */
      showStructureInfo() {
        const paths = this.getUnifiedPaths();
        const validation = this.validateStructure();
        console.log(`
\u{1F3D7}\uFE0F  AI-Trackdown Directory Structure`);
        console.log(`\u{1F4C1} Tasks Root: ${paths.tasksRoot}`);
        console.log(`   \u251C\u2500\u2500 \u{1F4C2} epics/     \u2192 ${paths.epicsDir}`);
        console.log(`   \u251C\u2500\u2500 \u{1F4C2} issues/    \u2192 ${paths.issuesDir}`);
        console.log(`   \u251C\u2500\u2500 \u{1F4C2} tasks/     \u2192 ${paths.tasksDir}`);
        console.log(`   \u251C\u2500\u2500 \u{1F4C2} prs/       \u2192 ${paths.prsDir}`);
        console.log(`   \u2514\u2500\u2500 \u{1F4C2} templates/ \u2192 ${paths.templatesDir}`);
        if (validation.missingDirs.length > 0) {
          console.log(`
\u26A0\uFE0F  Missing directories:`);
          validation.missingDirs.forEach((dir) => console.log(`   \u2022 ${dir}`));
        }
        if (validation.issues.length > 0) {
          console.log(`
\u{1F6A8} Issues detected:`);
          validation.issues.forEach((issue) => console.log(`   \u2022 ${issue}`));
        }
        const legacy = this.detectLegacyStructure();
        if (legacy.hasLegacy) {
          console.log(`
\u{1F4CB} Migration suggestions:`);
          legacy.suggestions.forEach((suggestion) => console.log(`   ${suggestion}`));
        }
      }
    };
    __name(_UnifiedPathResolver, "UnifiedPathResolver");
    UnifiedPathResolver = _UnifiedPathResolver;
  }
});

// src/utils/template-manager.ts
var template_manager_exports = {};
__export(template_manager_exports, {
  TemplateManager: () => TemplateManager
});
var fs, path, import_url, YAML2, __filename2, __dirname2, _TemplateManager, TemplateManager;
var init_template_manager = __esm({
  "src/utils/template-manager.ts"() {
    "use strict";
    init_cjs_shims();
    fs = __toESM(require("fs"), 1);
    path = __toESM(require("path"), 1);
    import_url = require("url");
    YAML2 = __toESM(require("yaml"), 1);
    __filename2 = (0, import_url.fileURLToPath)(importMetaUrl);
    __dirname2 = path.dirname(__filename2);
    _TemplateManager = class _TemplateManager {
      bundledTemplatesDir;
      constructor() {
        const possiblePaths = [
          path.join(__dirname2, "../../templates"),
          // Development: src/utils -> templates
          path.join(__dirname2, "../templates"),
          // Compiled: dist/utils -> dist/templates
          path.join(__dirname2, "templates"),
          // Compiled: dist -> dist/templates
          path.resolve(__dirname2, "..", "templates")
          // Alternative dist structure
        ];
        this.bundledTemplatesDir = possiblePaths.find((dir) => {
          try {
            return fs.existsSync(dir);
          } catch {
            return false;
          }
        }) || path.join(__dirname2, "../../templates");
      }
      /**
       * Get the path to bundled templates
       */
      getBundledTemplatesDir() {
        return this.bundledTemplatesDir;
      }
      /**
       * Check if bundled templates exist
       */
      hasBundledTemplates() {
        return fs.existsSync(this.bundledTemplatesDir);
      }
      /**
       * List all bundled template files
       */
      listBundledTemplates() {
        if (!this.hasBundledTemplates()) {
          return [];
        }
        try {
          return fs.readdirSync(this.bundledTemplatesDir).filter((file) => file.endsWith(".yaml")).sort();
        } catch (error) {
          console.warn(`Failed to list bundled templates: ${error instanceof Error ? error.message : "Unknown error"}`);
          return [];
        }
      }
      /**
       * Deploy bundled templates to project's templates directory
       */
      deployTemplates(projectTemplatesDir, force = false) {
        if (!this.hasBundledTemplates()) {
          console.warn("No bundled templates found. Creating default templates programmatically.");
          this.createDefaultTemplates(projectTemplatesDir, force);
          return;
        }
        if (!fs.existsSync(projectTemplatesDir)) {
          fs.mkdirSync(projectTemplatesDir, { recursive: true });
        }
        const bundledFiles = this.listBundledTemplates();
        let deployedCount = 0;
        for (const templateFile of bundledFiles) {
          const sourcePath = path.join(this.bundledTemplatesDir, templateFile);
          const destPath = path.join(projectTemplatesDir, templateFile);
          try {
            if (fs.existsSync(destPath) && !force) {
              console.log(`\u23ED\uFE0F  Skipping ${templateFile} (already exists)`);
              continue;
            }
            fs.copyFileSync(sourcePath, destPath);
            console.log(`\u2705 Deployed ${templateFile}`);
            deployedCount++;
          } catch (error) {
            console.error(`\u274C Failed to deploy ${templateFile}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        console.log(`\u{1F4E6} Deployed ${deployedCount} template(s) to ${projectTemplatesDir}`);
      }
      /**
       * Create default templates programmatically if bundled templates are not available
       */
      createDefaultTemplates(projectTemplatesDir, force = false) {
        if (!fs.existsSync(projectTemplatesDir)) {
          fs.mkdirSync(projectTemplatesDir, { recursive: true });
        }
        const defaultTemplates = [
          {
            type: "epic",
            name: "default",
            description: "Default epic template",
            frontmatter_template: {
              title: "Epic Title",
              description: "Epic description",
              status: "planning",
              priority: "medium",
              assignee: "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: [
                "context/requirements",
                "context/constraints",
                "context/assumptions",
                "context/dependencies"
              ],
              sync_status: "local"
            },
            content_template: `# Epic: {{title}}

## Overview
{{description}}

## Objectives
- [ ] Objective 1
- [ ] Objective 2
- [ ] Objective 3

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Related Issues
{{#related_issues}}
- {{.}}
{{/related_issues}}

## Notes
Add any additional notes here.`
          },
          {
            type: "issue",
            name: "default",
            description: "Default issue template",
            frontmatter_template: {
              title: "Issue Title",
              description: "Issue description",
              status: "planning",
              priority: "medium",
              assignee: "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: [
                "context/requirements",
                "context/constraints",
                "context/assumptions",
                "context/dependencies"
              ],
              sync_status: "local"
            },
            content_template: `# Issue: {{title}}

## Description
{{description}}

## Tasks
{{#related_tasks}}
- [ ] {{.}}
{{/related_tasks}}

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Notes
Add any additional notes here.`
          },
          {
            type: "task",
            name: "default",
            description: "Default task template",
            frontmatter_template: {
              title: "Task Title",
              description: "Task description",
              status: "planning",
              priority: "medium",
              assignee: "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: [
                "context/requirements",
                "context/constraints",
                "context/assumptions",
                "context/dependencies"
              ],
              sync_status: "local"
            },
            content_template: `# Task: {{title}}

## Description
{{description}}

## Steps
1. Step 1
2. Step 2
3. Step 3

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Notes
Add any additional notes here.`
          },
          {
            type: "pr",
            name: "default",
            description: "Default PR template",
            frontmatter_template: {
              title: "PR Title",
              description: "PR description",
              status: "planning",
              priority: "medium",
              assignee: "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: [
                "context/requirements",
                "context/constraints",
                "context/assumptions",
                "context/dependencies"
              ],
              sync_status: "local"
            },
            content_template: `# PR: {{title}}

## Description
{{description}}

## Changes
- Change 1
- Change 2
- Change 3

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] Tests added/updated

## Related
- Issue: {{issue_id}}
- Branch: {{branch_name}}
- Target: {{target_branch}}

## Notes
Add any additional notes here.`
          }
        ];
        let deployedCount = 0;
        for (const template of defaultTemplates) {
          const templatePath = path.join(projectTemplatesDir, `${template.type}-${template.name}.yaml`);
          try {
            if (fs.existsSync(templatePath) && !force) {
              console.log(`\u23ED\uFE0F  Skipping ${template.type}-${template.name}.yaml (already exists)`);
              continue;
            }
            const templateContent = YAML2.stringify(template, {
              indent: 2,
              lineWidth: 120
            });
            fs.writeFileSync(templatePath, templateContent, "utf8");
            console.log(`\u2705 Created ${template.type}-${template.name}.yaml`);
            deployedCount++;
          } catch (error) {
            console.error(`\u274C Failed to create ${template.type}-${template.name}.yaml: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        console.log(`\u{1F4E6} Created ${deployedCount} default template(s) in ${projectTemplatesDir}`);
      }
      /**
       * Get template by type and name, with fallback to bundled templates
       */
      getTemplate(projectTemplatesDir, type, name = "default") {
        const templateFileName = `${type}-${name}.yaml`;
        const projectTemplatePath = path.join(projectTemplatesDir, templateFileName);
        if (fs.existsSync(projectTemplatePath)) {
          try {
            const templateContent = fs.readFileSync(projectTemplatePath, "utf8");
            return YAML2.parse(templateContent);
          } catch (error) {
            console.warn(`Failed to load project template ${projectTemplatePath}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        if (this.hasBundledTemplates()) {
          const bundledTemplatePath = path.join(this.bundledTemplatesDir, templateFileName);
          if (fs.existsSync(bundledTemplatePath)) {
            try {
              const templateContent = fs.readFileSync(bundledTemplatePath, "utf8");
              return YAML2.parse(templateContent);
            } catch (error) {
              console.warn(`Failed to load bundled template ${bundledTemplatePath}: ${error instanceof Error ? error.message : "Unknown error"}`);
            }
          }
        }
        return null;
      }
      /**
       * Validate template file structure
       */
      validateTemplate(templatePath) {
        try {
          const content = fs.readFileSync(templatePath, "utf8");
          const template = YAML2.parse(content);
          const requiredFields = ["type", "name", "description", "frontmatter_template", "content_template"];
          for (const field of requiredFields) {
            if (!template[field]) {
              console.error(`Template ${templatePath} missing required field: ${field}`);
              return false;
            }
          }
          const validTypes = ["epic", "issue", "task", "pr"];
          if (!validTypes.includes(template.type)) {
            console.error(`Template ${templatePath} has invalid type: ${template.type}`);
            return false;
          }
          return true;
        } catch (error) {
          console.error(`Failed to validate template ${templatePath}: ${error instanceof Error ? error.message : "Unknown error"}`);
          return false;
        }
      }
    };
    __name(_TemplateManager, "TemplateManager");
    TemplateManager = _TemplateManager;
  }
});

// src/utils/config-manager.ts
var fs2, path2, YAML3, DEFAULT_CONFIG_DIR, DEFAULT_CONFIG_FILE, _ConfigManager2, ConfigManager2;
var init_config_manager = __esm({
  "src/utils/config-manager.ts"() {
    "use strict";
    init_cjs_shims();
    fs2 = __toESM(require("fs"), 1);
    path2 = __toESM(require("path"), 1);
    YAML3 = __toESM(require("yaml"), 1);
    init_unified_path_resolver();
    DEFAULT_CONFIG_DIR = ".ai-trackdown";
    DEFAULT_CONFIG_FILE = "config.yaml";
    _ConfigManager2 = class _ConfigManager2 {
      configPath;
      config = null;
      constructor(projectRoot) {
        const root = projectRoot || this.findProjectRoot();
        this.configPath = path2.join(root, DEFAULT_CONFIG_DIR, DEFAULT_CONFIG_FILE);
      }
      /**
       * Load configuration from file
       */
      loadConfig() {
        if (this.config) {
          return this.config;
        }
        if (!fs2.existsSync(this.configPath)) {
          throw new Error(`AI-Trackdown configuration not found at ${this.configPath}. Run 'aitrackdown init' to create a new project.`);
        }
        try {
          const configContent = fs2.readFileSync(this.configPath, "utf8");
          const rawConfig = YAML3.parse(configContent);
          if (rawConfig.project && rawConfig.project.name && !rawConfig.name) {
            this.config = {
              name: rawConfig.project.name,
              description: rawConfig.project.description,
              version: rawConfig.version || "1.0.0",
              tasks_directory: rawConfig.tasks_directory || "tasks",
              structure: rawConfig.structure || {
                epics_dir: "epics",
                issues_dir: "issues",
                tasks_dir: "tasks",
                templates_dir: "templates",
                prs_dir: "prs"
              },
              naming_conventions: rawConfig.naming_conventions || {
                epic_prefix: "EP",
                issue_prefix: "ISS",
                task_prefix: "TSK",
                pr_prefix: "PR",
                file_extension: ".md"
              },
              default_assignee: rawConfig.default_assignee || "unassigned",
              ai_context_templates: rawConfig.ai_context_templates || [],
              automation: rawConfig.automation || {
                auto_update_timestamps: true,
                auto_calculate_tokens: false,
                auto_sync_status: true
              }
            };
          } else {
            this.config = rawConfig;
          }
          this.validateConfig(this.config);
          this.normalizeConfig(this.config);
          return this.config;
        } catch (error) {
          throw new Error(`Failed to load AI-Trackdown configuration: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Save configuration to file
       */
      saveConfig(config) {
        this.validateConfig(config);
        const configDir = path2.dirname(this.configPath);
        if (!fs2.existsSync(configDir)) {
          fs2.mkdirSync(configDir, { recursive: true });
        }
        const yamlContent = YAML3.stringify(config, {
          indent: 2,
          lineWidth: 120,
          minContentWidth: 20
        });
        fs2.writeFileSync(this.configPath, yamlContent, "utf8");
        this.config = config;
      }
      /**
       * Create default configuration
       */
      createDefaultConfig(projectName, options = {}) {
        const defaultConfig = {
          name: projectName,
          description: options.description || `AI-Trackdown project: ${projectName}`,
          version: "1.0.0",
          // NEW: Default tasks directory for unified structure
          tasks_directory: options.tasks_directory || "tasks",
          structure: {
            epics_dir: "epics",
            issues_dir: "issues",
            tasks_dir: "tasks",
            templates_dir: "templates",
            prs_dir: "prs"
            // NEW: PR directory
          },
          naming_conventions: {
            epic_prefix: "EP",
            issue_prefix: "ISS",
            task_prefix: "TSK",
            pr_prefix: "PR",
            // NEW: PR prefix
            file_extension: ".md"
          },
          default_assignee: options.default_assignee || "unassigned",
          ai_context_templates: [
            "context/requirements",
            "context/constraints",
            "context/assumptions",
            "context/dependencies"
          ],
          automation: {
            auto_update_timestamps: true,
            auto_calculate_tokens: false,
            auto_sync_status: true
          },
          ...options
        };
        return defaultConfig;
      }
      /**
       * Initialize new project with default structure
       */
      initializeProject(projectName, options = {}) {
        const config = this.createDefaultConfig(projectName, options);
        this.createProjectStructure(config);
        this.createDefaultTemplates(config);
        this.saveConfig(config);
        return config;
      }
      /**
       * Initialize new project with structure only (no template creation)
       */
      initializeProjectStructure(projectName, options = {}) {
        const config = this.createDefaultConfig(projectName, options);
        this.createProjectStructure(config);
        this.saveConfig(config);
        return config;
      }
      /**
       * Update specific configuration values
       */
      updateConfig(updates) {
        const currentConfig = this.loadConfig();
        const updatedConfig = this.deepMerge(currentConfig, updates);
        this.saveConfig(updatedConfig);
        return updatedConfig;
      }
      /**
       * Get configuration with environment overrides
       */
      getConfig() {
        const config = this.loadConfig();
        if (process.env.ATD_DEFAULT_ASSIGNEE) {
          config.default_assignee = process.env.ATD_DEFAULT_ASSIGNEE;
        }
        if (process.env.ATD_AUTO_TIMESTAMPS === "false") {
          config.automation.auto_update_timestamps = false;
        }
        if (process.env.ATD_AUTO_CALCULATE_TOKENS === "true") {
          config.automation.auto_calculate_tokens = true;
        }
        return config;
      }
      /**
       * Get absolute paths for project structure using unified directory layout
       */
      getAbsolutePaths(cliTasksDir) {
        const config = this.getConfig();
        const projectRoot = path2.dirname(path2.dirname(this.configPath));
        const pathResolver = new UnifiedPathResolver(config, projectRoot, cliTasksDir);
        const unifiedPaths = pathResolver.getUnifiedPaths();
        return {
          projectRoot: unifiedPaths.projectRoot,
          configDir: unifiedPaths.configDir,
          tasksRoot: unifiedPaths.tasksRoot,
          epicsDir: unifiedPaths.epicsDir,
          issuesDir: unifiedPaths.issuesDir,
          tasksDir: unifiedPaths.tasksDir,
          prsDir: unifiedPaths.prsDir,
          templatesDir: unifiedPaths.templatesDir
        };
      }
      /**
       * Check if current directory is an AI-Trackdown project
       */
      isProjectDirectory(dir) {
        const checkDir = dir || process.cwd();
        const configPath = path2.join(checkDir, DEFAULT_CONFIG_DIR, DEFAULT_CONFIG_FILE);
        return fs2.existsSync(configPath);
      }
      /**
       * Find project root by walking up directory tree
       */
      findProjectRoot(startDir) {
        let currentDir = startDir || process.cwd();
        while (currentDir !== path2.dirname(currentDir)) {
          const configPath = path2.join(currentDir, DEFAULT_CONFIG_DIR, DEFAULT_CONFIG_FILE);
          if (fs2.existsSync(configPath)) {
            return currentDir;
          }
          currentDir = path2.dirname(currentDir);
        }
        return startDir || process.cwd();
      }
      /**
       * Validate configuration structure
       */
      validateConfig(config) {
        const required = ["name", "version", "structure", "naming_conventions"];
        for (const field of required) {
          if (!config[field]) {
            throw new Error(`Configuration missing required field: ${field}`);
          }
        }
        const structureFields = ["epics_dir", "issues_dir", "tasks_dir", "templates_dir"];
        for (const field of structureFields) {
          if (!config.structure[field]) {
            throw new Error(`Configuration structure missing required field: ${field}`);
          }
        }
        const namingFields = ["epic_prefix", "issue_prefix", "task_prefix", "file_extension"];
        for (const field of namingFields) {
          if (!config.naming_conventions[field]) {
            throw new Error(`Configuration naming_conventions missing required field: ${field}`);
          }
        }
      }
      /**
       * Normalize configuration (ensure defaults and proper types)
       */
      normalizeConfig(config) {
        if (!config.automation) {
          config.automation = {
            auto_update_timestamps: true,
            auto_calculate_tokens: false,
            auto_sync_status: true
          };
        }
        if (!config.ai_context_templates) {
          config.ai_context_templates = [];
        }
        config.structure.epics_dir = config.structure.epics_dir.replace(/^\/|\/$/g, "");
        config.structure.issues_dir = config.structure.issues_dir.replace(/^\/|\/$/g, "");
        config.structure.tasks_dir = config.structure.tasks_dir.replace(/^\/|\/$/g, "");
        config.structure.templates_dir = config.structure.templates_dir.replace(/^\/|\/$/g, "");
        if (!config.naming_conventions.file_extension.startsWith(".")) {
          config.naming_conventions.file_extension = "." + config.naming_conventions.file_extension;
        }
      }
      /**
       * Create project directory structure using unified layout
       */
      createProjectStructure(config) {
        const projectRoot = path2.dirname(path2.dirname(this.configPath));
        const pathResolver = new UnifiedPathResolver(config, projectRoot);
        const requiredDirs = pathResolver.getRequiredDirectories();
        for (const dir of requiredDirs) {
          if (!fs2.existsSync(dir)) {
            fs2.mkdirSync(dir, { recursive: true });
          }
        }
      }
      /**
       * Create default templates
       */
      createDefaultTemplates(config) {
        const projectRoot = path2.dirname(path2.dirname(this.configPath));
        const pathResolver = new UnifiedPathResolver(config, projectRoot);
        const paths = pathResolver.getUnifiedPaths();
        const templatesDir = paths.templatesDir;
        const templates = [
          {
            type: "epic",
            name: "default",
            description: "Default epic template",
            frontmatter_template: {
              title: "Epic Title",
              description: "Epic description",
              status: "planning",
              priority: "medium",
              assignee: config.default_assignee || "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: config.ai_context_templates || [],
              sync_status: "local"
            },
            content_template: `# Epic: {{title}}

## Overview
{{description}}

## Objectives
- [ ] Objective 1
- [ ] Objective 2
- [ ] Objective 3

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Related Issues
{{#related_issues}}
- {{.}}
{{/related_issues}}

## Notes
Add any additional notes here.`
          },
          {
            type: "issue",
            name: "default",
            description: "Default issue template",
            frontmatter_template: {
              title: "Issue Title",
              description: "Issue description",
              status: "planning",
              priority: "medium",
              assignee: config.default_assignee || "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: config.ai_context_templates || [],
              sync_status: "local"
            },
            content_template: `# Issue: {{title}}

## Description
{{description}}

## Tasks
{{#related_tasks}}
- [ ] {{.}}
{{/related_tasks}}

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Notes
Add any additional notes here.`
          },
          {
            type: "task",
            name: "default",
            description: "Default task template",
            frontmatter_template: {
              title: "Task Title",
              description: "Task description",
              status: "planning",
              priority: "medium",
              assignee: config.default_assignee || "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: config.ai_context_templates || [],
              sync_status: "local"
            },
            content_template: `# Task: {{title}}

## Description
{{description}}

## Steps
1. Step 1
2. Step 2
3. Step 3

## Acceptance Criteria
- [ ] Criteria 1
- [ ] Criteria 2

## Notes
Add any additional notes here.`
          },
          {
            type: "pr",
            name: "default",
            description: "Default PR template",
            frontmatter_template: {
              title: "PR Title",
              description: "PR description",
              status: "planning",
              priority: "medium",
              assignee: config.default_assignee || "unassigned",
              created_date: "",
              updated_date: "",
              estimated_tokens: 0,
              actual_tokens: 0,
              ai_context: config.ai_context_templates || [],
              sync_status: "local"
            },
            content_template: `# PR: {{title}}

## Description
{{description}}

## Changes
- Change 1
- Change 2
- Change 3

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] Tests added/updated

## Related
- Issue: {{issue_id}}
- Branch: {{branch_name}}
- Target: {{target_branch}}

## Notes
Add any additional notes here.`
          }
        ];
        for (const template of templates) {
          const templatePath = path2.join(templatesDir, `${template.type}-${template.name}.yaml`);
          if (!fs2.existsSync(templatePath)) {
            const templateContent = YAML3.stringify(template, {
              indent: 2,
              lineWidth: 120
            });
            fs2.writeFileSync(templatePath, templateContent, "utf8");
          }
        }
      }
      /**
       * Deep merge two objects
       */
      deepMerge(target, source) {
        const result = { ...target };
        for (const key in source) {
          if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) {
            result[key] = this.deepMerge(result[key] || {}, source[key]);
          } else {
            result[key] = source[key];
          }
        }
        return result;
      }
      /**
       * Get template by type and name
       */
      getTemplate(type, name = "default") {
        const config = this.getConfig();
        const projectRoot = path2.dirname(path2.dirname(this.configPath));
        const pathResolver = new UnifiedPathResolver(config, projectRoot);
        const paths = pathResolver.getUnifiedPaths();
        const templatesDir = paths.templatesDir;
        const templatePath = path2.join(templatesDir, `${type}-${name}.yaml`);
        if (!fs2.existsSync(templatePath)) {
          return null;
        }
        try {
          const templateContent = fs2.readFileSync(templatePath, "utf8");
          return YAML3.parse(templateContent);
        } catch (error) {
          console.warn(`Failed to load template ${templatePath}: ${error instanceof Error ? error.message : "Unknown error"}`);
          return null;
        }
      }
      /**
       * Get template by type and name with fallback to bundled templates
       */
      getTemplateWithFallback(type, name = "default") {
        const config = this.getConfig();
        const projectRoot = path2.dirname(path2.dirname(this.configPath));
        const pathResolver = new UnifiedPathResolver(config, projectRoot);
        const paths = pathResolver.getUnifiedPaths();
        const templatesDir = paths.templatesDir;
        const projectTemplate = this.getTemplate(type, name);
        if (projectTemplate) {
          return projectTemplate;
        }
        const TemplateManager2 = (init_template_manager(), __toCommonJS(template_manager_exports)).TemplateManager;
        const templateManager = new TemplateManager2();
        return templateManager.getTemplate(templatesDir, type, name);
      }
      /**
       * List available templates
       */
      listTemplates() {
        const config = this.getConfig();
        const projectRoot = path2.dirname(path2.dirname(this.configPath));
        const pathResolver = new UnifiedPathResolver(config, projectRoot);
        const paths = pathResolver.getUnifiedPaths();
        const templatesDir = paths.templatesDir;
        if (!fs2.existsSync(templatesDir)) {
          return [];
        }
        const templates = [];
        const files = fs2.readdirSync(templatesDir).filter((file) => file.endsWith(".yaml"));
        for (const file of files) {
          try {
            const templateContent = fs2.readFileSync(path2.join(templatesDir, file), "utf8");
            const template = YAML3.parse(templateContent);
            templates.push({
              type: template.type,
              name: template.name,
              description: template.description
            });
          } catch (error) {
            console.warn(`Failed to parse template ${file}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        return templates;
      }
    };
    __name(_ConfigManager2, "ConfigManager");
    ConfigManager2 = _ConfigManager2;
  }
});

// src/utils/id-generator.ts
var fs3, path3, _AITrackdownIdGenerator, AITrackdownIdGenerator;
var init_id_generator = __esm({
  "src/utils/id-generator.ts"() {
    "use strict";
    init_cjs_shims();
    fs3 = __toESM(require("fs"), 1);
    path3 = __toESM(require("path"), 1);
    _AITrackdownIdGenerator = class _AITrackdownIdGenerator {
      config;
      // Counters for ID generation (loaded from .ai-trackdown/counters.json)
      counters = {
        epic: 1,
        issue: 1,
        task: 1
      };
      countersPath;
      constructor(config, projectRoot) {
        this.config = config;
        this.countersPath = path3.join(projectRoot, ".ai-trackdown", "counters.json");
        this.loadCounters();
      }
      /**
       * Generate unique Epic ID
       */
      generateEpicId(title) {
        const id = `${this.config.naming_conventions.epic_prefix}-${this.counters.epic.toString().padStart(4, "0")}`;
        this.counters.epic++;
        this.saveCounters();
        return id;
      }
      /**
       * Generate unique Issue ID
       */
      generateIssueId(epic_id, title) {
        const id = `${this.config.naming_conventions.issue_prefix}-${this.counters.issue.toString().padStart(4, "0")}`;
        this.counters.issue++;
        this.saveCounters();
        return id;
      }
      /**
       * Generate unique Task ID
       */
      generateTaskId(issue_id, title) {
        const id = `${this.config.naming_conventions.task_prefix}-${this.counters.task.toString().padStart(4, "0")}`;
        this.counters.task++;
        this.saveCounters();
        return id;
      }
      /**
       * Generate filename for an item
       */
      generateFilename(itemId, title) {
        const sanitizedTitle = title.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").slice(0, 50).replace(/^-|-$/g, "");
        return `${itemId}-${sanitizedTitle}${this.config.naming_conventions.file_extension}`;
      }
      /**
       * Get next available ID without incrementing counter
       */
      peekNextId(type) {
        const prefix = this.config.naming_conventions[`${type}_prefix`];
        const counter = this.counters[type];
        return `${prefix}-${counter.toString().padStart(4, "0")}`;
      }
      /**
       * Reset counters (dangerous - only for testing or project reset)
       */
      resetCounters() {
        this.counters = { epic: 1, issue: 1, task: 1 };
        this.saveCounters();
      }
      /**
       * Get current counter values
       */
      getCounters() {
        return { ...this.counters };
      }
      /**
       * Set specific counter value (useful for migration)
       */
      setCounter(type, value) {
        this.counters[type] = Math.max(1, value);
        this.saveCounters();
      }
      /**
       * Auto-detect and set counters based on existing files
       */
      autoDetectCounters(projectRoot) {
        const epicsDir = path3.join(projectRoot, this.config.structure.epics_dir);
        const issuesDir = path3.join(projectRoot, this.config.structure.issues_dir);
        const tasksDir = path3.join(projectRoot, this.config.structure.tasks_dir);
        const epicPrefix = this.config.naming_conventions.epic_prefix;
        const epicPattern = new RegExp(`${epicPrefix}-(\\d+)`);
        let maxEpic = 0;
        if (fs3.existsSync(epicsDir)) {
          const epicFiles = fs3.readdirSync(epicsDir);
          for (const file of epicFiles) {
            const match = file.match(epicPattern);
            if (match) {
              maxEpic = Math.max(maxEpic, parseInt(match[1], 10));
            }
          }
        }
        const issuePrefix = this.config.naming_conventions.issue_prefix;
        const issuePattern = new RegExp(`${issuePrefix}-(\\d+)`);
        let maxIssue = 0;
        if (fs3.existsSync(issuesDir)) {
          const issueFiles = fs3.readdirSync(issuesDir);
          for (const file of issueFiles) {
            const match = file.match(issuePattern);
            if (match) {
              maxIssue = Math.max(maxIssue, parseInt(match[1], 10));
            }
          }
        }
        const taskPrefix = this.config.naming_conventions.task_prefix;
        const taskPattern = new RegExp(`${taskPrefix}-(\\d+)`);
        let maxTask = 0;
        if (fs3.existsSync(tasksDir)) {
          const taskFiles = fs3.readdirSync(tasksDir);
          for (const file of taskFiles) {
            const match = file.match(taskPattern);
            if (match) {
              maxTask = Math.max(maxTask, parseInt(match[1], 10));
            }
          }
        }
        this.counters.epic = maxEpic + 1;
        this.counters.issue = maxIssue + 1;
        this.counters.task = maxTask + 1;
        this.saveCounters();
      }
      /**
       * Load counters from file
       */
      loadCounters() {
        try {
          if (fs3.existsSync(this.countersPath)) {
            const data = fs3.readFileSync(this.countersPath, "utf8");
            const loaded = JSON.parse(data);
            this.counters.epic = Math.max(1, loaded.epic || 1);
            this.counters.issue = Math.max(1, loaded.issue || 1);
            this.counters.task = Math.max(1, loaded.task || 1);
          }
        } catch (error) {
          console.warn(`Failed to load counters, using defaults: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Save counters to file
       */
      saveCounters() {
        try {
          const dir = path3.dirname(this.countersPath);
          if (!fs3.existsSync(dir)) {
            fs3.mkdirSync(dir, { recursive: true });
          }
          const data = JSON.stringify(this.counters, null, 2);
          fs3.writeFileSync(this.countersPath, data, "utf8");
        } catch (error) {
          console.warn(`Failed to save counters: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Validate ID format
       */
      validateId(id, type) {
        const prefix = this.config.naming_conventions[`${type}_prefix`];
        const pattern = new RegExp(`^${prefix}-\\d{4}$`);
        return pattern.test(id);
      }
      /**
       * Extract number from ID
       */
      extractIdNumber(id, type) {
        const prefix = this.config.naming_conventions[`${type}_prefix`];
        const pattern = new RegExp(`^${prefix}-(\\d{4})$`);
        const match = id.match(pattern);
        return match ? parseInt(match[1], 10) : null;
      }
      /**
       * Generate batch of IDs (useful for bulk operations)
       */
      generateBatchIds(type, count) {
        const ids = [];
        const prefix = this.config.naming_conventions[`${type}_prefix`];
        for (let i = 0; i < count; i++) {
          const id = `${prefix}-${this.counters[type].toString().padStart(4, "0")}`;
          ids.push(id);
          this.counters[type]++;
        }
        this.saveCounters();
        return ids;
      }
    };
    __name(_AITrackdownIdGenerator, "AITrackdownIdGenerator");
    AITrackdownIdGenerator = _AITrackdownIdGenerator;
  }
});

// src/utils/frontmatter-parser.ts
var fs4, path4, YAML4, FRONTMATTER_DELIMITER, FRONTMATTER_REGEX, _FrontmatterParser, FrontmatterParser;
var init_frontmatter_parser = __esm({
  "src/utils/frontmatter-parser.ts"() {
    "use strict";
    init_cjs_shims();
    fs4 = __toESM(require("fs"), 1);
    path4 = __toESM(require("path"), 1);
    YAML4 = __toESM(require("yaml"), 1);
    FRONTMATTER_DELIMITER = "---";
    FRONTMATTER_REGEX = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    _FrontmatterParser = class _FrontmatterParser {
      /**
       * Parse an Epic file with YAML frontmatter
       */
      parseEpic(filePath) {
        const { frontmatter, content } = this.parseFile(filePath);
        if (!frontmatter.epic_id) {
          throw new Error(`File ${filePath} is missing epic_id field`);
        }
        const epicFrontmatter = frontmatter;
        this.validateEpicFrontmatter(epicFrontmatter);
        return {
          ...epicFrontmatter,
          content,
          file_path: filePath
        };
      }
      /**
       * Parse an Issue file with YAML frontmatter
       */
      parseIssue(filePath) {
        const { frontmatter, content } = this.parseFile(filePath);
        if (!frontmatter.issue_id || !frontmatter.epic_id) {
          throw new Error(`File ${filePath} is missing required issue_id or epic_id field`);
        }
        const issueFrontmatter = frontmatter;
        this.validateIssueFrontmatter(issueFrontmatter);
        return {
          ...issueFrontmatter,
          content,
          file_path: filePath
        };
      }
      /**
       * Parse a Task file with YAML frontmatter
       */
      parseTask(filePath) {
        const { frontmatter, content } = this.parseFile(filePath);
        if (!frontmatter.task_id || !frontmatter.issue_id || !frontmatter.epic_id) {
          throw new Error(`File ${filePath} is missing required task_id, issue_id, or epic_id field`);
        }
        const taskFrontmatter = frontmatter;
        this.validateTaskFrontmatter(taskFrontmatter);
        return {
          ...taskFrontmatter,
          content,
          file_path: filePath
        };
      }
      /**
       * Parse a PR file with YAML frontmatter
       */
      parsePR(filePath) {
        const { frontmatter, content } = this.parseFile(filePath);
        if (!frontmatter.pr_id || !frontmatter.issue_id || !frontmatter.epic_id) {
          throw new Error(`File ${filePath} is missing required pr_id, issue_id, or epic_id field`);
        }
        const prFrontmatter = frontmatter;
        this.validatePRFrontmatter(prFrontmatter);
        return {
          ...prFrontmatter,
          content,
          file_path: filePath
        };
      }
      /**
       * Generic file parser for any ai-trackdown item
       */
      parseAnyItem(filePath) {
        const { frontmatter } = this.parseFile(filePath);
        if (frontmatter.epic_id && !frontmatter.issue_id && !frontmatter.task_id && !frontmatter.pr_id) {
          return this.parseEpic(filePath);
        } else if (frontmatter.issue_id && frontmatter.epic_id && !frontmatter.task_id && !frontmatter.pr_id) {
          return this.parseIssue(filePath);
        } else if (frontmatter.task_id && frontmatter.issue_id && frontmatter.epic_id && !frontmatter.pr_id) {
          return this.parseTask(filePath);
        } else if (frontmatter.pr_id && frontmatter.issue_id && frontmatter.epic_id && !frontmatter.task_id) {
          return this.parsePR(filePath);
        } else {
          throw new Error(`File ${filePath} does not match any ai-trackdown item type`);
        }
      }
      /**
       * Serialize Epic data back to file format
       */
      serializeEpic(data, content) {
        const frontmatter = this.cleanFrontmatter(data);
        return this.serializeWithFrontmatter(frontmatter, content);
      }
      /**
       * Serialize Issue data back to file format
       */
      serializeIssue(data, content) {
        const frontmatter = this.cleanFrontmatter(data);
        return this.serializeWithFrontmatter(frontmatter, content);
      }
      /**
       * Serialize Task data back to file format
       */
      serializeTask(data, content) {
        const frontmatter = this.cleanFrontmatter(data);
        return this.serializeWithFrontmatter(frontmatter, content);
      }
      /**
       * Serialize PR data back to file format
       */
      serializePR(data, content) {
        const frontmatter = this.cleanFrontmatter(data);
        return this.serializeWithFrontmatter(frontmatter, content);
      }
      /**
       * Write Epic data to file
       */
      writeEpic(filePath, data, content) {
        const serialized = this.serializeEpic(data, content);
        this.ensureDirectoryExists(path4.dirname(filePath));
        fs4.writeFileSync(filePath, serialized, "utf8");
      }
      /**
       * Write Issue data to file
       */
      writeIssue(filePath, data, content) {
        const serialized = this.serializeIssue(data, content);
        this.ensureDirectoryExists(path4.dirname(filePath));
        fs4.writeFileSync(filePath, serialized, "utf8");
      }
      /**
       * Write Task data to file
       */
      writeTask(filePath, data, content) {
        const serialized = this.serializeTask(data, content);
        this.ensureDirectoryExists(path4.dirname(filePath));
        fs4.writeFileSync(filePath, serialized, "utf8");
      }
      /**
       * Write PR data to file
       */
      writePR(filePath, data, content) {
        const serialized = this.serializePR(data, content);
        this.ensureDirectoryExists(path4.dirname(filePath));
        fs4.writeFileSync(filePath, serialized, "utf8");
      }
      /**
       * Update existing file with new frontmatter data
       */
      updateFile(filePath, updates) {
        const existing = this.parseAnyItem(filePath);
        const updated = {
          ...existing,
          ...updates,
          updated_date: (/* @__PURE__ */ new Date()).toISOString()
        };
        if ("epic_id" in updated && !("issue_id" in updated)) {
          this.writeEpic(filePath, updated, existing.content);
        } else if ("issue_id" in updated && !("task_id" in updated) && !("pr_id" in updated)) {
          this.writeIssue(filePath, updated, existing.content);
        } else if ("task_id" in updated) {
          this.writeTask(filePath, updated, existing.content);
        } else if ("pr_id" in updated) {
          this.writePR(filePath, updated, existing.content);
        }
        return updated;
      }
      /**
       * Validate file structure and content
       */
      validateFile(filePath) {
        const errors = [];
        const warnings = [];
        try {
          if (!fs4.existsSync(filePath)) {
            errors.push({
              field: "file",
              message: `File does not exist: ${filePath}`,
              severity: "error"
            });
            return { valid: false, errors, warnings };
          }
          const data = this.parseAnyItem(filePath);
          if ("epic_id" in data && !("issue_id" in data)) {
            return this.validateEpicData(data);
          } else if ("issue_id" in data && !("task_id" in data) && !("pr_id" in data)) {
            return this.validateIssueData(data);
          } else if ("task_id" in data) {
            return this.validateTaskData(data);
          } else if ("pr_id" in data) {
            return this.validatePRData(data);
          }
        } catch (error) {
          errors.push({
            field: "parse",
            message: `Failed to parse file: ${error instanceof Error ? error.message : "Unknown error"}`,
            severity: "error"
          });
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * Private: Core file parsing logic
       */
      parseFile(filePath) {
        if (!fs4.existsSync(filePath)) {
          throw new Error(`File not found: ${filePath}`);
        }
        const fileContent = fs4.readFileSync(filePath, "utf8");
        const match = fileContent.match(FRONTMATTER_REGEX);
        if (!match) {
          throw new Error(`No valid YAML frontmatter found in file: ${filePath}`);
        }
        const [, yamlContent, markdownContent] = match;
        try {
          const frontmatter = YAML4.parse(yamlContent);
          return {
            frontmatter,
            content: markdownContent.trim()
          };
        } catch (error) {
          throw new Error(`Failed to parse YAML frontmatter in ${filePath}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Private: Serialize frontmatter and content to file format
       */
      serializeWithFrontmatter(frontmatter, content) {
        const yamlString = YAML4.stringify(frontmatter, {
          indent: 2,
          lineWidth: 120,
          minContentWidth: 20
        });
        return `${FRONTMATTER_DELIMITER}
${yamlString}${FRONTMATTER_DELIMITER}

${content}
`;
      }
      /**
       * Private: Clean frontmatter object (remove undefined/null values)
       */
      cleanFrontmatter(data) {
        const cleaned = {};
        for (const [key, value] of Object.entries(data)) {
          if (value !== void 0 && value !== null) {
            cleaned[key] = value;
          }
        }
        return cleaned;
      }
      /**
       * Private: Ensure directory exists
       */
      ensureDirectoryExists(dirPath) {
        if (!fs4.existsSync(dirPath)) {
          fs4.mkdirSync(dirPath, { recursive: true });
        }
      }
      /**
       * Private: Validate Epic frontmatter
       */
      validateEpicFrontmatter(data) {
        const required = ["epic_id", "title", "status", "priority", "assignee", "created_date"];
        for (const field of required) {
          if (!data[field]) {
            throw new Error(`Epic missing required field: ${field}`);
          }
        }
      }
      /**
       * Private: Validate Issue frontmatter
       */
      validateIssueFrontmatter(data) {
        const required = ["issue_id", "epic_id", "title", "status", "priority", "assignee", "created_date"];
        for (const field of required) {
          if (!data[field]) {
            throw new Error(`Issue missing required field: ${field}`);
          }
        }
      }
      /**
       * Private: Validate Task frontmatter
       */
      validateTaskFrontmatter(data) {
        const required = ["task_id", "issue_id", "epic_id", "title", "status", "priority", "assignee", "created_date"];
        for (const field of required) {
          if (!data[field]) {
            throw new Error(`Task missing required field: ${field}`);
          }
        }
      }
      /**
       * Private: Validate PR frontmatter
       */
      validatePRFrontmatter(data) {
        const required = ["pr_id", "issue_id", "epic_id", "title", "status", "pr_status", "priority", "assignee", "created_date"];
        for (const field of required) {
          if (!data[field]) {
            throw new Error(`PR missing required field: ${field}`);
          }
        }
      }
      /**
       * Private: Comprehensive Epic data validation
       */
      validateEpicData(data) {
        const errors = [];
        const warnings = [];
        if (!data.epic_id) errors.push({ field: "epic_id", message: "Epic ID is required", severity: "error" });
        if (!data.title) errors.push({ field: "title", message: "Title is required", severity: "error" });
        if (!data.status) errors.push({ field: "status", message: "Status is required", severity: "error" });
        if (data.epic_id && !/^EP-\d{4}$/.test(data.epic_id)) {
          warnings.push({ field: "epic_id", message: "Epic ID should follow format EP-XXXX", severity: "warning" });
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * Private: Comprehensive Issue data validation
       */
      validateIssueData(data) {
        const errors = [];
        const warnings = [];
        if (!data.issue_id) errors.push({ field: "issue_id", message: "Issue ID is required", severity: "error" });
        if (!data.epic_id) errors.push({ field: "epic_id", message: "Epic ID is required", severity: "error" });
        if (!data.title) errors.push({ field: "title", message: "Title is required", severity: "error" });
        if (data.issue_id && !/^ISS-\d{4}$/.test(data.issue_id)) {
          warnings.push({ field: "issue_id", message: "Issue ID should follow format ISS-XXXX", severity: "warning" });
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * Private: Comprehensive Task data validation
       */
      validateTaskData(data) {
        const errors = [];
        const warnings = [];
        if (!data.task_id) errors.push({ field: "task_id", message: "Task ID is required", severity: "error" });
        if (!data.issue_id) errors.push({ field: "issue_id", message: "Issue ID is required", severity: "error" });
        if (!data.epic_id) errors.push({ field: "epic_id", message: "Epic ID is required", severity: "error" });
        if (data.task_id && !/^TSK-\d{4}$/.test(data.task_id)) {
          warnings.push({ field: "task_id", message: "Task ID should follow format TSK-XXXX", severity: "warning" });
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * Private: Comprehensive PR data validation
       */
      validatePRData(data) {
        const errors = [];
        const warnings = [];
        if (!data.pr_id) errors.push({ field: "pr_id", message: "PR ID is required", severity: "error" });
        if (!data.issue_id) errors.push({ field: "issue_id", message: "Issue ID is required", severity: "error" });
        if (!data.epic_id) errors.push({ field: "epic_id", message: "Epic ID is required", severity: "error" });
        if (!data.pr_status) errors.push({ field: "pr_status", message: "PR status is required", severity: "error" });
        if (data.pr_id && !/^PR-\d{4}$/.test(data.pr_id)) {
          warnings.push({ field: "pr_id", message: "PR ID should follow format PR-XXXX", severity: "warning" });
        }
        const validPRStatuses = ["draft", "open", "review", "approved", "merged", "closed"];
        if (data.pr_status && !validPRStatuses.includes(data.pr_status)) {
          errors.push({ field: "pr_status", message: `Invalid PR status: ${data.pr_status}`, severity: "error" });
        }
        return { valid: errors.length === 0, errors, warnings };
      }
      /**
       * Bulk operations for directory processing
       */
      parseDirectory(dirPath, itemType) {
        if (!fs4.existsSync(dirPath)) {
          return [];
        }
        const files = fs4.readdirSync(dirPath).filter((file) => file.endsWith(".md")).map((file) => path4.join(dirPath, file));
        const results = [];
        for (const filePath of files) {
          try {
            let data;
            switch (itemType) {
              case "epic":
                data = this.parseEpic(filePath);
                break;
              case "issue":
                data = this.parseIssue(filePath);
                break;
              case "task":
                data = this.parseTask(filePath);
                break;
              case "pr":
                data = this.parsePR(filePath);
                break;
              default:
                continue;
            }
            results.push(data);
          } catch (error) {
            console.warn(`Failed to parse ${filePath}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        return results;
      }
    };
    __name(_FrontmatterParser, "FrontmatterParser");
    FrontmatterParser = _FrontmatterParser;
  }
});

// src/commands/init.ts
function createInitCommand() {
  const command = new import_commander2.Command("init");
  command.description("Initialize a new AI-Trackdown project with hierarchical structure").argument("[project-name]", "name of the project").option("--project-name <name>", "project name (alternative to positional argument)").option("--type <type>", "project type (software, research, business, general)", "general").option("--assignee <assignee>", "default assignee for items").option("--tasks-directory <path>", "root directory for all task types (default: tasks)", "tasks").option("--force", "overwrite existing project").option("--interactive", "interactive setup mode").option("--skip-interactive", "skip interactive prompts, use defaults or fail if required info missing").addHelpText(
    "after",
    `
Examples:
  $ aitrackdown init my-project --type software
  $ aitrackdown init research-project --type research --interactive
  $ aitrackdown init --interactive
  $ aitrackdown init my-project --tasks-directory work
  $ aitrackdown init --project-name my-project --skip-interactive
  $ echo "my-project" | aitrackdown init --skip-interactive

Project Types:
  software  - Software development projects
  research  - Research and analysis projects  
  business  - Business process and planning
  general   - General purpose projects

Directory Structure:
  Default structure with --tasks-directory "tasks":
    tasks/epics/, tasks/issues/, tasks/tasks/, tasks/templates/
  
  Custom structure with --tasks-directory "work":
    work/epics/, work/issues/, work/tasks/, work/templates/
`
  ).action(async (projectName, options = {}) => {
    try {
      let finalProjectName = projectName || options.projectName;
      if (!finalProjectName) {
        const stdinName = await readProjectNameFromStdin();
        if (stdinName) {
          finalProjectName = stdinName;
        }
      }
      let config = {
        name: finalProjectName,
        type: options.type || "general",
        assignee: options.assignee || process.env.USER || "unassigned",
        tasksDirectory: options.tasksDirectory || process.env.CLI_TASKS_DIR || "tasks",
        force: options.force || false
      };
      const shouldRunInteractive = options.interactive || !options.skipInteractive && !finalProjectName && !isNonInteractive();
      if (shouldRunInteractive) {
        if (isNonInteractive()) {
          throw new Error("Interactive mode requested but running in non-interactive environment. Use --skip-interactive or provide --project-name.");
        }
        config = await runInteractiveSetup(config);
      } else if (options.skipInteractive && !config.name) {
        throw new Error("Project name is required when using --skip-interactive. Use --project-name or provide as argument.");
      }
      const projectNameValue = config.name || "ai-trackdown-project";
      if (!/^[a-zA-Z0-9][a-zA-Z0-9-_]*$/.test(projectNameValue)) {
        throw new Error("Project name must start with alphanumeric character and contain only letters, numbers, hyphens, and underscores");
      }
      const projectPath = path5.resolve(process.cwd(), projectNameValue);
      if (fs5.existsSync(projectPath) && !config.force) {
        console.error(`\u274C Project "${projectNameValue}" already exists`);
        console.log("\u{1F4A1} Use --force to overwrite existing project");
        process.exit(1);
      }
      const spinner = (0, import_ora2.default)("Initializing AI-Trackdown project...").start();
      try {
        if (!fs5.existsSync(projectPath)) {
          fs5.mkdirSync(projectPath, { recursive: true });
        }
        const configManager = new ConfigManager2(projectPath);
        const projectConfig = configManager.createDefaultConfig(projectNameValue, {
          description: `AI-Trackdown ${config.type} project: ${projectNameValue}`,
          default_assignee: config.assignee,
          tasks_directory: config.tasksDirectory
        });
        spinner.text = "Creating project structure...";
        configManager.createProjectStructure(projectConfig);
        configManager.saveConfig(projectConfig);
        spinner.text = "Deploying templates...";
        const templateManager = new TemplateManager();
        const pathResolver = new UnifiedPathResolver(projectConfig, projectPath);
        const paths = pathResolver.getUnifiedPaths();
        templateManager.deployTemplates(paths.templatesDir, config.force);
        spinner.text = "Setting up ID generator...";
        const idGenerator = new AITrackdownIdGenerator(projectConfig, projectPath);
        spinner.text = "Creating example items...";
        await createExampleItems(projectPath, projectConfig, idGenerator);
        spinner.text = "Creating documentation...";
        createProjectReadme(projectPath, projectNameValue, config.type, projectConfig);
        createGitignore(projectPath);
        spinner.succeed("AI-Trackdown project initialized successfully!");
        console.log(`
\u{1F389} AI-Trackdown project "${projectNameValue}" created successfully!

Project Type: ${config.type}
Location: ${projectPath}
Configuration: .ai-trackdown/config.yaml
Tasks Directory: ${config.tasksDirectory}/

\u{1F4C1} Project Structure (Unified Layout):
\u251C\u2500\u2500 .ai-trackdown/          # Configuration and metadata
\u2502   \u251C\u2500\u2500 config.yaml         # Project configuration
\u2502   \u251C\u2500\u2500 counters.json       # ID counters
\u2502   \u2514\u2500\u2500 templates/          # Item templates  
\u251C\u2500\u2500 ${config.tasksDirectory}/                # Tasks root directory
\u2502   \u251C\u2500\u2500 epics/              # Epic-level planning
\u2502   \u251C\u2500\u2500 issues/             # Issue-level work items
\u2502   \u251C\u2500\u2500 tasks/              # Task-level activities
\u2502   \u251C\u2500\u2500 prs/                # Pull request tracking
\u2502   \u2514\u2500\u2500 templates/          # Item templates
\u251C\u2500\u2500 .gitignore             # Git ignore patterns
\u2514\u2500\u2500 README.md              # Project documentation

\u{1F680} Next Steps:
1. Navigate to your project:
   cd ${projectNameValue}

2. Explore the example items:
   ls ${config.tasksDirectory}/epics/ ${config.tasksDirectory}/issues/ ${config.tasksDirectory}/tasks/

3. Create your first epic:
   aitrackdown epic create "New Feature Development"

4. Create an issue within the epic:
   aitrackdown issue create "API Implementation" --epic EP-0001

5. Create tasks for the issue:
   aitrackdown task create "Design API Schema" --issue ISS-0001

6. View project status:
   aitrackdown status

7. Get help:
   aitrackdown --help
`);
      } catch (error) {
        spinner.fail("Project initialization failed");
        throw error;
      }
    } catch (error) {
      console.error(`\u274C Failed to initialize project: ${error instanceof Error ? error.message : "Unknown error"}`);
      process.exit(1);
    }
  });
  return command;
}
function isNonInteractive() {
  return !process.stdout.isTTY || !process.stdin.isTTY || process.env.CI === "true";
}
async function readProjectNameFromStdin() {
  return new Promise((resolve5) => {
    if (!process.stdin.isTTY) {
      let input = "";
      let resolved = false;
      const timeout = setTimeout(() => {
        if (!resolved) {
          resolved = true;
          resolve5(null);
        }
      }, 100);
      process.stdin.setEncoding("utf8");
      process.stdin.on("data", (chunk) => {
        input += chunk.toString();
      });
      process.stdin.on("end", () => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          const projectName = input.trim();
          resolve5(projectName || null);
        }
      });
      process.stdin.on("error", () => {
        if (!resolved) {
          resolved = true;
          clearTimeout(timeout);
          resolve5(null);
        }
      });
      setImmediate(() => {
        if (!resolved && process.stdin.readable) {
          const chunk = process.stdin.read();
          if (chunk !== null) {
            input += chunk.toString();
          }
        }
      });
    } else {
      resolve5(null);
    }
  });
}
async function runInteractiveSetup(initialConfig) {
  console.log(`
\u{1F680} AI-Trackdown Interactive Setup
`);
  if (isNonInteractive()) {
    throw new Error("Cannot run interactive setup in non-interactive environment. Use --skip-interactive or provide --project-name.");
  }
  try {
    const answers = await import_inquirer2.default.prompt([
      {
        type: "input",
        name: "name",
        message: "Project name:",
        default: initialConfig.name || "my-trackdown-project",
        validate: /* @__PURE__ */ __name((input) => {
          if (!/^[a-zA-Z0-9][a-zA-Z0-9-_]*$/.test(input)) {
            return "Project name must start with alphanumeric character and contain only letters, numbers, hyphens, and underscores";
          }
          return true;
        }, "validate")
      },
      {
        type: "list",
        name: "type",
        message: "Project type:",
        choices: [
          { name: "\u{1F4BB} Software - Software development projects", value: "software" },
          { name: "\u{1F52C} Research - Research and analysis projects", value: "research" },
          { name: "\u{1F4CA} Business - Business process and planning", value: "business" },
          { name: "\u{1F4C1} General - General purpose projects", value: "general" }
        ],
        default: initialConfig.type
      },
      {
        type: "input",
        name: "assignee",
        message: "Default assignee:",
        default: initialConfig.assignee
      },
      {
        type: "input",
        name: "tasksDirectory",
        message: "Tasks root directory:",
        default: initialConfig.tasksDirectory || "tasks",
        validate: /* @__PURE__ */ __name((input) => {
          if (!/^[a-zA-Z0-9][a-zA-Z0-9-_/]*$/.test(input)) {
            return "Tasks directory must start with alphanumeric character and contain only letters, numbers, hyphens, underscores, and slashes";
          }
          return true;
        }, "validate")
      },
      {
        type: "confirm",
        name: "force",
        message: "Overwrite existing project if it exists?",
        default: initialConfig.force,
        when: /* @__PURE__ */ __name((answers2) => fs5.existsSync(path5.resolve(process.cwd(), answers2.name)), "when")
      }
    ]);
    return { ...initialConfig, ...answers };
  } catch (error) {
    if (error instanceof Error) {
      if (error.message.includes("User force closed the prompt") || error.message.includes("prompt aborted") || error.message.includes("canceled")) {
        throw new Error("Interactive setup was cancelled. Use --skip-interactive to bypass prompts.");
      }
      throw error;
    }
    throw new Error("Interactive setup failed. Use --skip-interactive to bypass prompts.");
  }
}
async function createExampleItems(projectPath, config, idGenerator) {
  const parser = new FrontmatterParser();
  const pathResolver = new UnifiedPathResolver(config, projectPath);
  const paths = pathResolver.getUnifiedPaths();
  const epicId = idGenerator.generateEpicId("Project Setup and Initial Development");
  const epicPath = path5.join(
    paths.epicsDir,
    idGenerator.generateFilename(epicId, "Project Setup and Initial Development")
  );
  const epicData = {
    epic_id: epicId,
    title: "Project Setup and Initial Development",
    description: "Initial setup and foundational development for the project",
    status: "active",
    priority: "high",
    assignee: config.default_assignee || "unassigned",
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    updated_date: (/* @__PURE__ */ new Date()).toISOString(),
    estimated_tokens: 500,
    actual_tokens: 0,
    ai_context: ["project-setup", "initial-development", "foundation"],
    related_issues: ["ISS-0001"],
    sync_status: "local",
    tags: ["setup", "foundation"],
    milestone: "v1.0.0"
  };
  const epicContent = `# Epic: Project Setup and Initial Development

## Overview
This epic covers the foundational work needed to get the project up and running, including environment setup, initial architecture decisions, and core infrastructure.

## Objectives
- [ ] Set up development environment
- [ ] Establish project structure and conventions
- [ ] Implement core infrastructure
- [ ] Create initial documentation

## Success Criteria
- Development environment is fully configured
- Team can effectively collaborate on the project
- Core infrastructure is in place and tested
- Documentation is comprehensive and up-to-date

## Related Issues
- ISS-0001: Development Environment Setup

## Notes
This is a foundational epic that will enable all future development work.`;
  parser.writeEpic(epicPath, epicData, epicContent);
  const issueId = idGenerator.generateIssueId(epicId, "Development Environment Setup");
  const issuePath = path5.join(
    paths.issuesDir,
    idGenerator.generateFilename(issueId, "Development Environment Setup")
  );
  const issueData = {
    issue_id: issueId,
    epic_id: epicId,
    title: "Development Environment Setup",
    description: "Configure development environment and tooling for the project",
    status: "active",
    priority: "high",
    assignee: config.default_assignee || "unassigned",
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    updated_date: (/* @__PURE__ */ new Date()).toISOString(),
    estimated_tokens: 200,
    actual_tokens: 0,
    ai_context: ["environment-setup", "tooling", "configuration"],
    related_tasks: ["TSK-0001", "TSK-0002"],
    sync_status: "local",
    tags: ["setup", "environment"],
    dependencies: []
  };
  const issueContent = `# Issue: Development Environment Setup

## Description
Set up a consistent development environment that all team members can use. This includes configuring development tools, establishing coding standards, and creating setup documentation.

## Tasks
- TSK-0001: Install and configure development tools
- TSK-0002: Create development setup documentation

## Acceptance Criteria
- [ ] All required development tools are identified and documented
- [ ] Setup instructions are created and tested
- [ ] Development environment can be replicated consistently
- [ ] Team members can successfully set up their environments

## Dependencies
None - this is foundational work.

## Notes
Focus on creating a setup that is reliable and easy to follow for new team members.`;
  parser.writeIssue(issuePath, issueData, issueContent);
  const task1Id = idGenerator.generateTaskId(issueId, "Install and configure development tools");
  const task1Path = path5.join(
    paths.tasksDir,
    idGenerator.generateFilename(task1Id, "Install and configure development tools")
  );
  const task1Data = {
    task_id: task1Id,
    issue_id: issueId,
    epic_id: epicId,
    title: "Install and configure development tools",
    description: "Install required development tools and configure them for the project",
    status: "planning",
    priority: "high",
    assignee: config.default_assignee || "unassigned",
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    updated_date: (/* @__PURE__ */ new Date()).toISOString(),
    estimated_tokens: 100,
    actual_tokens: 0,
    ai_context: ["tool-installation", "configuration", "setup"],
    sync_status: "local",
    tags: ["tools", "setup"],
    time_estimate: "4 hours",
    dependencies: []
  };
  const task1Content = `# Task: Install and configure development tools

## Description
Install and configure all necessary development tools for the project including IDE, version control, package managers, and any project-specific tools.

## Steps
1. Install IDE/editor with required extensions
2. Configure version control (Git)
3. Install package managers and dependencies
4. Set up project-specific tools and utilities
5. Test the complete development setup

## Acceptance Criteria
- [ ] All required tools are installed and working
- [ ] Configuration is documented
- [ ] Setup can be reproduced on different machines
- [ ] All tools integrate properly with the project

## Tools to Install
- [ ] IDE/Editor (VS Code, IntelliJ, etc.)
- [ ] Git and Git client
- [ ] Node.js/Python/etc. (as needed)
- [ ] Package managers
- [ ] Project-specific tools

## Notes
Document any platform-specific setup requirements.`;
  parser.writeTask(task1Path, task1Data, task1Content);
  const task2Id = idGenerator.generateTaskId(issueId, "Create development setup documentation");
  const task2Path = path5.join(
    paths.tasksDir,
    idGenerator.generateFilename(task2Id, "Create development setup documentation")
  );
  const task2Data = {
    task_id: task2Id,
    issue_id: issueId,
    epic_id: epicId,
    title: "Create development setup documentation",
    description: "Write comprehensive documentation for setting up the development environment",
    status: "planning",
    priority: "medium",
    assignee: config.default_assignee || "unassigned",
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    updated_date: (/* @__PURE__ */ new Date()).toISOString(),
    estimated_tokens: 100,
    actual_tokens: 0,
    ai_context: ["documentation", "setup-guide", "onboarding"],
    sync_status: "local",
    tags: ["documentation", "setup"],
    time_estimate: "2 hours",
    dependencies: ["TSK-0001"]
  };
  const task2Content = `# Task: Create development setup documentation

## Description
Create comprehensive setup documentation that enables new team members to quickly and reliably set up their development environment.

## Steps
1. Document all required tools and versions
2. Write step-by-step setup instructions
3. Include troubleshooting section
4. Add platform-specific notes (Windows/Mac/Linux)
5. Test documentation with a fresh setup

## Acceptance Criteria
- [ ] Documentation is complete and accurate
- [ ] Instructions work on all supported platforms
- [ ] Troubleshooting section addresses common issues
- [ ] Documentation is easily accessible to team members

## Documentation Sections
- [ ] Prerequisites and system requirements
- [ ] Tool installation instructions
- [ ] Configuration steps
- [ ] Verification and testing
- [ ] Troubleshooting common issues
- [ ] Contact information for help

## Notes
Keep documentation updated as tools and requirements evolve.`;
  parser.writeTask(task2Path, task2Data, task2Content);
}
function createProjectReadme(projectPath, projectName, projectType, config) {
  const tasksDir = config.tasks_directory || "tasks";
  const readmeContent = `# ${projectName}

An AI-Trackdown project for hierarchical project management.

**Project Type:** ${projectType}  
**Created:** ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}
**Tasks Directory:** ${tasksDir}/

## Overview

This project uses AI-Trackdown for hierarchical project management with Epics, Issues, and Tasks. Each item has YAML frontmatter for metadata and Markdown content for descriptions.

## Unified Directory Structure

\`\`\`
${projectName}/
\u251C\u2500\u2500 .ai-trackdown/          # Configuration and metadata
\u2502   \u251C\u2500\u2500 config.yaml         # Project configuration
\u2502   \u251C\u2500\u2500 counters.json       # ID generation counters
\u2502   \u2514\u2500\u2500 templates/          # Item templates
\u251C\u2500\u2500 ${tasksDir}/                  # Tasks root directory (configurable)
\u2502   \u251C\u2500\u2500 epics/              # Epic-level planning (.md files)
\u2502   \u251C\u2500\u2500 issues/             # Issue-level work items (.md files)
\u2502   \u251C\u2500\u2500 tasks/              # Task-level activities (.md files)
\u2502   \u251C\u2500\u2500 prs/                # Pull request tracking (.md files)
\u2502   \u2514\u2500\u2500 templates/          # Item templates
\u251C\u2500\u2500 .gitignore             # Git ignore patterns
\u2514\u2500\u2500 README.md              # This file
\`\`\`

## Hierarchy

- **Epics** (${config.naming_conventions.epic_prefix}-XXXX): High-level features or objectives
- **Issues** (${config.naming_conventions.issue_prefix}-XXXX): Specific work items within epics
- **Tasks** (${config.naming_conventions.task_prefix}-XXXX): Granular activities within issues

## Getting Started

### View Items
\`\`\`bash
# List all epics
ls ${tasksDir}/epics/

# List all issues
ls ${tasksDir}/issues/

# List all tasks
ls ${tasksDir}/tasks/

# List all PRs
ls ${tasksDir}/prs/
\`\`\`

### Create New Items
\`\`\`bash
# Create a new epic
aitrackdown epic create "New Feature Development"

# Create an issue within an epic
aitrackdown issue create "API Implementation" --epic EP-0001

# Create a task within an issue
aitrackdown task create "Design API Schema" --issue ISS-0001
\`\`\`

### Project Management
\`\`\`bash
# View project status
aitrackdown status

# Search items
aitrackdown search --status active --priority high

# Update item status
aitrackdown task update TSK-0001 --status completed

# Export project data
aitrackdown export --format json
\`\`\`

## Configuration

Project configuration is stored in \`.ai-trackdown/config.yaml\`. You can modify:

- Directory structure
- Naming conventions
- Default assignee
- AI context templates
- Automation settings

## File Format

Each item file contains YAML frontmatter and Markdown content:

\`\`\`markdown
---
epic_id: EP-0001
title: Project Setup and Initial Development
description: Initial setup and foundational development
status: active
priority: high
assignee: ${config.default_assignee}
created_date: 2023-XX-XX
updated_date: 2023-XX-XX
estimated_tokens: 500
actual_tokens: 0
ai_context:
  - project-setup
  - initial-development
related_issues:
  - ISS-0001
sync_status: local
---

# Epic: Project Setup and Initial Development

## Overview
Detailed description of the epic...
\`\`\`

## Examples

The project includes example items to help you get started:
- **EP-0001**: Project Setup and Initial Development
- **ISS-0001**: Development Environment Setup
- **TSK-0001**: Install and configure development tools
- **TSK-0002**: Create development setup documentation

## Commands

| Command | Description |
|---------|-------------|
| \`aitrackdown init\` | Initialize a new project |
| \`aitrackdown epic create\` | Create a new epic |
| \`aitrackdown issue create\` | Create a new issue |
| \`aitrackdown task create\` | Create a new task |
| \`aitrackdown status\` | View project status |
| \`aitrackdown search\` | Search items |
| \`aitrackdown export\` | Export project data |

## Links

- [AI-Trackdown Documentation](https://github.com/your-org/ai-trackdown-tools)
- [Project Issues](https://github.com/your-org/ai-trackdown-tools/issues)

---

*Generated by ai-trackdown-tools on ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}*
`;
  fs5.writeFileSync(path5.join(projectPath, "README.md"), readmeContent, "utf8");
}
function createGitignore(projectPath) {
  const gitignoreContent = `# AI-Trackdown exports
.ai-trackdown/exports/
*.backup

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
`;
  fs5.writeFileSync(path5.join(projectPath, ".gitignore"), gitignoreContent, "utf8");
}
var import_commander2, import_inquirer2, import_ora2, fs5, path5;
var init_init = __esm({
  "src/commands/init.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander2 = require("commander");
    import_inquirer2 = __toESM(require("inquirer"), 1);
    import_ora2 = __toESM(require("ora"), 1);
    init_config_manager();
    init_id_generator();
    init_frontmatter_parser();
    init_unified_path_resolver();
    init_template_manager();
    fs5 = __toESM(require("fs"), 1);
    path5 = __toESM(require("path"), 1);
    __name(createInitCommand, "createInitCommand");
    __name(isNonInteractive, "isNonInteractive");
    __name(readProjectNameFromStdin, "readProjectNameFromStdin");
    __name(runInteractiveSetup, "runInteractiveSetup");
    __name(createExampleItems, "createExampleItems");
    __name(createProjectReadme, "createProjectReadme");
    __name(createGitignore, "createGitignore");
  }
});

// src/commands/status.ts
function createStatusCommand() {
  const command = new import_commander3.Command("status");
  command.description("Display comprehensive project status with advanced filtering and analytics").option("-v, --verbose", "show detailed item information with descriptions").option("-c, --compact", "compact output format for quick overview").option("--table", "display results in table format").option("--stats", "show detailed project statistics and analytics").option("--filter <expr>", 'advanced filter expression (e.g., "status=todo,priority=high")').option("-s, --status <status>", "filter by status (todo, in-progress, done, blocked)").option("-p, --priority <priority>", "filter by priority (low, medium, high, critical)").option("-a, --assignee <name>", "filter by assignee name or email").option("-t, --tags <tags>", "filter by tags (comma-separated)").option("-i, --id <id>", "filter by specific item ID").option("--created-after <date>", "show items created after date (YYYY-MM-DD)").option("--created-before <date>", "show items created before date (YYYY-MM-DD)").option("--updated-after <date>", "show items updated after date (YYYY-MM-DD)").option("--updated-before <date>", "show items updated before date (YYYY-MM-DD)").option("--estimate-min <points>", "minimum story points").option("--estimate-max <points>", "maximum story points").option(
    "--sort <field>",
    "sort by field (created, updated, priority, status, title)",
    "updated"
  ).option("--order <direction>", "sort order (asc, desc)", "desc").option("--limit <count>", "limit number of results shown").option("--offset <count>", "skip number of results (for pagination)").option("--interactive", "interactive filtering and display mode").option("--watch", "continuously monitor and refresh status").option("--export <file>", "export filtered results to file").option("--full", "comprehensive project status with enhanced details").addHelpText(
    "after",
    `
Examples:
  $ aitrackdown status
  $ aitrackdown status --verbose --stats
  $ aitrackdown status --filter "status=todo,priority=high"
  $ aitrackdown status --assignee john.doe --created-after 2024-01-01
  $ aitrackdown status --tags backend,security --table
  $ aitrackdown status --interactive
  $ aitrackdown status --stats --export project-status.json

Filter Expressions:
  status=todo,blocked        - Multiple status values
  priority=high              - Single priority
  assignee=john.doe          - Specific assignee
  tags=backend,api           - Items with any of these tags
  estimate=5-13              - Story points range

Status Values:
  todo          - Not started
  in-progress   - Currently being worked on
  blocked       - Blocked by dependencies or issues
  done          - Completed tasks

Priority Levels:
  low           - Nice to have, non-urgent
  medium        - Standard priority (default)
  high          - Important, should be done soon
  critical      - Urgent, blocking other work

Sort Fields:
  created       - Creation date
  updated       - Last modified date
  priority      - Priority level (critical > high > medium > low)
  status        - Status progression (todo > in-progress > blocked > done)
  title         - Alphabetical by title
`
  ).action(
    async (options) => {
      var _a, _b, _c;
      try {
        const parentCommand = command.parent;
        const rootDirOption = ((_a = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _a.rootDir) || ((_b = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _b.tasksDir);
        const configManager = new ConfigManager();
        const config = configManager.getConfig();
        const pathResolver = new PathResolver(configManager, rootDirOption);
        const trackdownDir = (0, import_node_path6.join)(process.cwd(), pathResolver.getRootDirectory());
        if (!(0, import_node_fs6.existsSync)(trackdownDir)) {
          if (pathResolver.shouldMigrate()) {
            pathResolver.showMigrationWarning();
            console.log("\nMigration commands:");
            pathResolver.getMigrationCommands().forEach((cmd) => {
              console.log(Formatter.highlight(cmd));
            });
            process.exit(1);
          }
          console.error(Formatter.error(`No ${pathResolver.getRootDirectory()} project found in current directory`));
          console.log(Formatter.info('Run "aitrackdown init" to initialize a new project'));
          console.log(
            Formatter.info(`Or navigate to a directory with an existing ${pathResolver.getRootDirectory()} project`)
          );
          process.exit(1);
        }
        if (options == null ? void 0 : options.interactive) {
          const interactiveOptions = await runInteractiveStatusMode(options);
          options = { ...options, ...interactiveOptions };
        }
        if (options == null ? void 0 : options.watch) {
          return runWatchMode(trackdownDir, options, config, pathResolver);
        }
        const spinner = (0, import_ora3.default)("Analyzing project status...").start();
        try {
          const items = await getAllItemsEnhanced(trackdownDir, pathResolver);
          spinner.text = "Applying filters...";
          const filters = parseFilters(options);
          const filteredItems = applyAdvancedFilters2(items, filters);
          spinner.text = "Processing results...";
          const sortedItems = applySorting(
            filteredItems,
            (options == null ? void 0 : options.sort) || "updated",
            (options == null ? void 0 : options.order) || "desc"
          );
          const paginatedItems = applyPagination(sortedItems, options == null ? void 0 : options.limit, options == null ? void 0 : options.offset);
          spinner.succeed(
            `Found ${filteredItems.length} items${filteredItems.length !== items.length ? ` (${items.length} total)` : ""}`
          );
          console.log(Formatter.header(`\u{1F4CA} ${config.projectName || "Trackdown"} Project Status`));
          if ((options == null ? void 0 : options.stats) !== false) {
            displayProjectOverview(trackdownDir, items, config, pathResolver);
          }
          if (filteredItems.length === 0) {
            console.log(Formatter.box("No items match the current filters", "info"));
            console.log(
              Formatter.info(
                "Try adjusting your filter criteria or use --help for filter examples"
              )
            );
            return;
          }
          if (options == null ? void 0 : options.table) {
            console.log(Formatter.header("\u{1F4CB} Items Table"));
            console.log(Formatter.formatTable(paginatedItems));
          } else if (options == null ? void 0 : options.compact) {
            console.log(Formatter.header("\u{1F4DD} Compact View"));
            displayCompactView(paginatedItems);
          } else if (options == null ? void 0 : options.verbose) {
            console.log(Formatter.header("\u{1F4D6} Detailed View"));
            displayDetailedView(paginatedItems);
          } else {
            console.log(Formatter.header("\u{1F4CB} Status Overview"));
            displayGroupedView(paginatedItems);
          }
          if (options == null ? void 0 : options.stats) {
            console.log(Formatter.header("\u{1F4C8} Project Analytics"));
            displayAdvancedStatistics(filteredItems, items);
          }
          if (hasActiveFilters(filters)) {
            displayActiveFilters(filters);
          }
          if ((options == null ? void 0 : options.limit) || (options == null ? void 0 : options.offset)) {
            displayPaginationInfo(sortedItems.length, paginatedItems.length, options);
          }
          if (options == null ? void 0 : options.export) {
            await exportResults(filteredItems, options.export, config);
          }
          if (!(options == null ? void 0 : options.compact) && !(options == null ? void 0 : options.table)) {
            displayNextSteps(filteredItems, config);
          }
        } catch (error) {
          spinner.fail("Status analysis failed");
          throw error;
        }
      } catch (error) {
        if (error instanceof ValidationError) {
          console.error(Formatter.error(error.message));
          if (error.suggestion) {
            console.log(Formatter.info(`\u{1F4A1} ${error.suggestion}`));
          }
          if ((_c = error.validOptions) == null ? void 0 : _c.length) {
            console.log(Formatter.info("Valid options:"));
            error.validOptions.forEach((option) => {
              console.log(Formatter.highlight(`  ${option}`));
            });
          }
        } else {
          console.error(
            Formatter.error(
              `Failed to get status: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
        process.exit(1);
      }
    }
  );
  return command;
}
async function runInteractiveStatusMode(currentOptions) {
  console.log(Formatter.header("\u{1F50D} Interactive Status Filtering"));
  const answers = await import_inquirer3.default.prompt([
    {
      type: "list",
      name: "outputFormat",
      message: "Output format:",
      choices: [
        { name: "\u{1F4CB} Default - Grouped by status", value: "default" },
        { name: "\u{1F4D6} Verbose - Detailed item view", value: "verbose" },
        { name: "\u{1F4DD} Compact - Quick overview", value: "compact" },
        { name: "\u{1F4CA} Table - Tabular format", value: "table" }
      ],
      default: "default"
    },
    {
      type: "checkbox",
      name: "statusFilter",
      message: "Filter by status (select multiple):",
      choices: [
        { name: "\u{1F4DD} Todo - Not started", value: "todo" },
        { name: "\u{1F504} In Progress - Currently working", value: "in-progress" },
        { name: "\u{1F6AB} Blocked - Dependencies or issues", value: "blocked" },
        { name: "\u2705 Done - Completed tasks", value: "done" }
      ]
    },
    {
      type: "checkbox",
      name: "priorityFilter",
      message: "Filter by priority (select multiple):",
      choices: [
        { name: "\u{1F534} Critical - Urgent, blocking", value: "critical" },
        { name: "\u{1F7E0} High - Important, urgent", value: "high" },
        { name: "\u{1F7E1} Medium - Standard priority", value: "medium" },
        { name: "\u{1F7E2} Low - Nice to have", value: "low" }
      ]
    },
    {
      type: "input",
      name: "assigneeFilter",
      message: "Filter by assignee (username/email):"
    },
    {
      type: "input",
      name: "tagsFilter",
      message: "Filter by tags (comma-separated):"
    },
    {
      type: "list",
      name: "sortBy",
      message: "Sort results by:",
      choices: [
        { name: "\u{1F552} Last Updated (newest first)", value: "updated:desc" },
        { name: "\u{1F552} Last Updated (oldest first)", value: "updated:asc" },
        { name: "\u{1F4C5} Created Date (newest first)", value: "created:desc" },
        { name: "\u{1F4C5} Created Date (oldest first)", value: "created:asc" },
        { name: "\u{1F3F7}\uFE0F Priority (high to low)", value: "priority:desc" },
        { name: "\u{1F4DD} Title (A-Z)", value: "title:asc" }
      ],
      default: "updated:desc"
    },
    {
      type: "confirm",
      name: "showStats",
      message: "Show detailed statistics?",
      default: true
    },
    {
      type: "input",
      name: "limitResults",
      message: "Limit number of results (leave blank for all):",
      validate: /* @__PURE__ */ __name((input) => {
        if (!input) return true;
        const num = parseInt(input);
        if (isNaN(num) || num < 1) return "Please enter a valid positive number";
        return true;
      }, "validate")
    }
  ]);
  const [sortField, sortOrder] = answers.sortBy.split(":");
  return {
    verbose: answers.outputFormat === "verbose",
    compact: answers.outputFormat === "compact",
    table: answers.outputFormat === "table",
    stats: answers.showStats,
    status: answers.statusFilter.length === 1 ? answers.statusFilter[0] : void 0,
    priority: answers.priorityFilter.length === 1 ? answers.priorityFilter[0] : void 0,
    assignee: answers.assigneeFilter || void 0,
    tags: answers.tagsFilter || void 0,
    sort: sortField,
    order: sortOrder,
    limit: answers.limitResults ? answers.limitResults : void 0,
    filter: buildFilterExpression(answers)
  };
}
function buildFilterExpression(answers) {
  const filters = [];
  if (answers.statusFilter.length > 1) {
    filters.push(`status=${answers.statusFilter.join(",")}`);
  }
  if (answers.priorityFilter.length > 1) {
    filters.push(`priority=${answers.priorityFilter.join(",")}`);
  }
  if (answers.assigneeFilter) {
    filters.push(`assignee=${answers.assigneeFilter}`);
  }
  if (answers.tagsFilter) {
    filters.push(`tags=${answers.tagsFilter}`);
  }
  return filters.join(",");
}
async function runWatchMode(trackdownDir, options, config, pathResolver) {
  console.log(Formatter.info("\u{1F441}\uFE0F Watch mode enabled - monitoring for changes..."));
  console.log(Formatter.info("Press Ctrl+C to exit"));
  let lastHash = "";
  const displayStatus = /* @__PURE__ */ __name(async () => {
    try {
      console.clear();
      console.log(
        Formatter.header(
          `\u{1F4CA} ${config.projectName || "Trackdown"} Live Status - ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`
        )
      );
      const items = await getAllItemsEnhanced(trackdownDir, pathResolver);
      const currentHash = JSON.stringify(
        items.map((i) => `${i.id}-${i.updatedAt.getTime()}`)
      ).substring(0, 20);
      if (currentHash !== lastHash) {
        const filters = parseFilters(options);
        const filteredItems = applyAdvancedFilters2(items, filters);
        const sortedItems = applySorting(
          filteredItems,
          (options == null ? void 0 : options.sort) || "updated",
          (options == null ? void 0 : options.order) || "desc"
        );
        const paginatedItems = applyPagination(sortedItems, options == null ? void 0 : options.limit, options == null ? void 0 : options.offset);
        displayProjectOverview(trackdownDir, items, config, pathResolver);
        if (paginatedItems.length > 0) {
          if (options == null ? void 0 : options.table) {
            console.log(Formatter.formatTable(paginatedItems));
          } else {
            displayGroupedView(paginatedItems);
          }
        } else {
          console.log(Formatter.box("No items match current filters", "info"));
        }
        lastHash = currentHash;
        console.log(Formatter.info(`\u{1F504} Last updated: ${(/* @__PURE__ */ new Date()).toLocaleTimeString()}`));
      } else {
        console.log(Formatter.info("No changes detected"));
      }
    } catch (error) {
      console.error(
        Formatter.error(
          `Watch mode error: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
    }
  }, "displayStatus");
  await displayStatus();
  const interval = setInterval(displayStatus, 2e3);
  process.on("SIGINT", () => {
    clearInterval(interval);
    console.log(Formatter.info("\n\u{1F44B} Watch mode stopped"));
    process.exit(0);
  });
}
async function getAllItemsEnhanced(trackdownDir, pathResolver) {
  const items = [];
  const directories = [
    pathResolver.getActiveDir(),
    pathResolver.getCompletedDir()
  ];
  for (const dir of directories) {
    const fullPath = (0, import_node_path6.join)(process.cwd(), dir);
    if ((0, import_node_fs6.existsSync)(fullPath)) {
      const files = (0, import_node_fs6.readdirSync)(fullPath).filter((file) => file.endsWith(".md"));
      for (const file of files) {
        try {
          const item = parseTrackdownFileEnhanced((0, import_node_path6.join)(fullPath, file));
          if (item) {
            items.push(item);
          }
        } catch (_error) {
          console.warn(Formatter.warning(`Could not parse file: ${file}`));
        }
      }
    }
  }
  return items.sort((a, b) => b.updatedAt.getTime() - a.updatedAt.getTime());
}
function parseTrackdownFileEnhanced(filePath) {
  var _a, _b, _c, _d;
  try {
    const content = (0, import_node_fs6.readFileSync)(filePath, "utf-8");
    const stats = (0, import_node_fs6.statSync)(filePath);
    const titleMatch = content.match(/^# (.+)$/m);
    const idMatch = content.match(/\*\*ID\*\*:\s*(.+)$/m);
    const statusMatch = content.match(/\*\*Status\*\*:\s*(.+)$/m);
    const priorityMatch = content.match(/\*\*Priority\*\*:\s*(.+)$/m);
    const assigneeMatch = content.match(/\*\*Assignee\*\*:\s*(.+)$/m);
    const createdMatch = content.match(/\*\*Created\*\*:\s*(.+)$/m);
    const updatedMatch = content.match(/\*\*Updated\*\*:\s*(.+)$/m);
    const tagsMatch = content.match(/\*\*Tags\*\*:\s*(.+)$/m);
    const labelsMatch = content.match(/\*\*Labels\*\*:\s*(.+)$/m);
    const estimateMatch = content.match(/\*\*Story Points\*\*:\s*(.+)$/m);
    if (!titleMatch || !idMatch) {
      return null;
    }
    const descriptionMatch = content.match(/## Description\n\n(.*?)\n\n##/s);
    const tags = tagsMatch ? tagsMatch[1].split(",").map((tag) => tag.trim().replace(/`/g, "")).filter(Boolean) : void 0;
    const labels = labelsMatch ? labelsMatch[1].split(",").map((label) => label.trim().replace(/`/g, "")).filter(Boolean) : void 0;
    const estimate = estimateMatch ? parseFloat(estimateMatch[1].trim()) : void 0;
    return {
      id: idMatch[1].trim(),
      title: titleMatch[1].trim(),
      description: descriptionMatch ? descriptionMatch[1].trim() : void 0,
      status: ((_a = statusMatch == null ? void 0 : statusMatch[1]) == null ? void 0 : _a.trim()) || "todo",
      priority: ((_b = priorityMatch == null ? void 0 : priorityMatch[1]) == null ? void 0 : _b.trim()) || "medium",
      assignee: ((_c = assigneeMatch == null ? void 0 : assigneeMatch[1]) == null ? void 0 : _c.trim()) !== "Unassigned" ? (_d = assigneeMatch == null ? void 0 : assigneeMatch[1]) == null ? void 0 : _d.trim() : void 0,
      createdAt: createdMatch ? new Date(createdMatch[1].trim()) : stats.birthtime,
      updatedAt: updatedMatch ? new Date(updatedMatch[1].trim()) : stats.mtime,
      tags,
      labels,
      estimate
    };
  } catch (_error) {
    return null;
  }
}
function parseFilters(options) {
  const filters = {};
  if (options == null ? void 0 : options.status) {
    filters.status = validateStatus2(options.status);
  }
  if (options == null ? void 0 : options.priority) {
    filters.priority = validatePriority(options.priority);
  }
  if (options == null ? void 0 : options.assignee) {
    filters.assignee = validateAssignee(options.assignee);
  }
  if (options == null ? void 0 : options.id) {
    filters.id = validateId(options.id);
  }
  if (options == null ? void 0 : options.tags) {
    filters.tags = validateTags(options.tags);
  }
  if (options == null ? void 0 : options.createdAfter) {
    filters.createdAfter = new Date(options.createdAfter);
  }
  if (options == null ? void 0 : options.createdBefore) {
    filters.createdBefore = new Date(options.createdBefore);
  }
  if (options == null ? void 0 : options.updatedAfter) {
    filters.updatedAfter = new Date(options.updatedAfter);
  }
  if (options == null ? void 0 : options.updatedBefore) {
    filters.updatedBefore = new Date(options.updatedBefore);
  }
  if (options == null ? void 0 : options.estimateMin) {
    filters.estimateMin = parseFloat(options.estimateMin);
  }
  if (options == null ? void 0 : options.estimateMax) {
    filters.estimateMax = parseFloat(options.estimateMax);
  }
  if (options == null ? void 0 : options.filter) {
    parseAdvancedFilter(options.filter, filters);
  }
  return filters;
}
function parseAdvancedFilter(filterExpr, filters) {
  const parts = filterExpr.split(",");
  for (const part of parts) {
    const [key, value] = part.split("=");
    if (!key || !value) continue;
    const trimmedKey = key.trim();
    const trimmedValue = value.trim();
    switch (trimmedKey) {
      case "status":
        if (trimmedValue.includes(",")) {
          filters.statusIn = trimmedValue.split(",").map((s) => s.trim());
        } else {
          filters.status = trimmedValue;
        }
        break;
      case "priority":
        if (trimmedValue.includes(",")) {
          filters.priorityIn = trimmedValue.split(",").map((p) => p.trim());
        } else {
          filters.priority = trimmedValue;
        }
        break;
      case "assignee":
        filters.assignee = trimmedValue;
        break;
      case "tags":
        filters.tags = trimmedValue.split(",").map((t) => t.trim());
        break;
      case "estimate":
        if (trimmedValue.includes("-")) {
          const [min, max] = trimmedValue.split("-");
          filters.estimateMin = parseFloat(min);
          filters.estimateMax = parseFloat(max);
        }
        break;
    }
  }
}
function applyAdvancedFilters2(items, filters) {
  return items.filter((item) => {
    if (filters.status && item.status !== filters.status) return false;
    if (filters.statusIn && !filters.statusIn.includes(item.status)) return false;
    if (filters.priority && item.priority !== filters.priority) return false;
    if (filters.priorityIn && !filters.priorityIn.includes(item.priority)) return false;
    if (filters.assignee && item.assignee !== filters.assignee) return false;
    if (filters.id && item.id !== filters.id) return false;
    if (filters.tags && filters.tags.length > 0) {
      if (!item.tags || !filters.tags.some((tag) => item.tags.includes(tag))) return false;
    }
    if (filters.createdAfter && item.createdAt < filters.createdAfter) return false;
    if (filters.createdBefore && item.createdAt > filters.createdBefore) return false;
    if (filters.updatedAfter && item.updatedAt < filters.updatedAfter) return false;
    if (filters.updatedBefore && item.updatedAt > filters.updatedBefore) return false;
    if (filters.estimateMin && (!item.estimate || item.estimate < filters.estimateMin))
      return false;
    if (filters.estimateMax && (!item.estimate || item.estimate > filters.estimateMax))
      return false;
    return true;
  });
}
function applySorting(items, sortField, sortOrder) {
  const direction = sortOrder === "desc" ? -1 : 1;
  return [...items].sort((a, b) => {
    let comparison = 0;
    switch (sortField) {
      case "created":
        comparison = a.createdAt.getTime() - b.createdAt.getTime();
        break;
      case "updated":
        comparison = a.updatedAt.getTime() - b.updatedAt.getTime();
        break;
      case "title":
        comparison = a.title.localeCompare(b.title);
        break;
      case "priority":
        const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        comparison = priorityOrder[a.priority] - priorityOrder[b.priority];
        break;
      case "status":
        const statusOrder = { todo: 1, "in-progress": 2, blocked: 3, done: 4 };
        comparison = statusOrder[a.status] - statusOrder[b.status];
        break;
      default:
        comparison = a.updatedAt.getTime() - b.updatedAt.getTime();
    }
    return comparison * direction;
  });
}
function applyPagination(items, limit, offset) {
  let start = 0;
  let end = items.length;
  if (offset) {
    start = parseInt(offset);
    if (isNaN(start) || start < 0) start = 0;
  }
  if (limit) {
    const limitNum = parseInt(limit);
    if (!isNaN(limitNum) && limitNum > 0) {
      end = start + limitNum;
    }
  }
  return items.slice(start, end);
}
function displayProjectOverview(trackdownDir, items, config, pathResolver) {
  const summary = getProjectSummaryEnhanced(trackdownDir, items, pathResolver);
  console.log(summary);
}
function getProjectSummaryEnhanced(trackdownDir, items, pathResolver) {
  const activeItems = items.filter((item) => item.status !== "done");
  const completedItems = items.filter((item) => item.status === "done");
  const total = items.length;
  const completionRate = total > 0 ? Math.round(completedItems.length / total * 100) : 0;
  const lastWeek = /* @__PURE__ */ new Date();
  lastWeek.setDate(lastWeek.getDate() - 7);
  const recentlyCompleted = completedItems.filter((item) => item.updatedAt >= lastWeek).length;
  const recentlyCreated = items.filter((item) => item.createdAt >= lastWeek).length;
  const byPriority = items.reduce(
    (acc, item) => {
      acc[item.priority] = (acc[item.priority] || 0) + 1;
      return acc;
    },
    {}
  );
  return [
    `\u{1F4CA} Project Overview`,
    `   Active Items: ${Formatter.highlight(activeItems.length.toString())}`,
    `   Completed Items: ${Formatter.highlight(completedItems.length.toString())}`,
    `   Total Items: ${Formatter.highlight(total.toString())}`,
    `   Completion Rate: ${Formatter.highlight(`${completionRate}%`)}`,
    `   Weekly Velocity: ${Formatter.highlight(`${recentlyCompleted} completed, ${recentlyCreated} created`)}`,
    `   Priority Breakdown: ${Object.entries(byPriority).map(([p, c]) => `${p}: ${c}`).join(", ")}`,
    ""
  ].join("\n");
}
function displayCompactView(items) {
  items.forEach((item, index) => {
    const statusBadge = getStatusIcon(item.status);
    const priorityColor = getPriorityColor(item.priority);
    console.log(
      `${(index + 1).toString().padStart(3, " ")}. ${statusBadge} ${priorityColor(item.priority.charAt(0).toUpperCase())} ${item.title} ${Formatter.dim(`(${item.id})`)}`
    );
  });
}
function displayDetailedView(items) {
  items.forEach((item, index) => {
    console.log(Formatter.formatItem(item, "detailed"));
    if (index < items.length - 1) {
      console.log(Formatter.dim("\u2500".repeat(80)));
    }
  });
}
function displayGroupedView(items) {
  const groupedItems = groupItemsByStatus(items);
  for (const [status, statusItems] of Object.entries(groupedItems)) {
    if (statusItems.length > 0) {
      console.log(
        Formatter.subheader(
          `${getStatusIcon(status)} ${status.toUpperCase()} (${statusItems.length})`
        )
      );
      statusItems.forEach((item, index) => {
        var _a;
        const priorityColor = getPriorityColor(item.priority);
        const assigneeInfo = item.assignee ? ` @${item.assignee}` : "";
        const tagsInfo = ((_a = item.tags) == null ? void 0 : _a.length) ? ` [${item.tags.join(", ")}]` : "";
        console.log(
          `  ${index + 1}. ${priorityColor(item.priority.toUpperCase())} ${item.title}${assigneeInfo}${tagsInfo} ${Formatter.dim(`(${item.id})`)}`
        );
      });
      console.log("");
    }
  }
}
function displayAdvancedStatistics(filteredItems, allItems) {
  const stats = Formatter.generateStats(filteredItems);
  console.log(stats);
  if (allItems.length > filteredItems.length) {
    console.log(
      Formatter.info(`\u{1F4CA} Showing ${filteredItems.length} of ${allItems.length} total items`)
    );
  }
  const withEstimates = filteredItems.filter((item) => item.estimate);
  if (withEstimates.length > 0) {
    const totalPoints = withEstimates.reduce((sum, item) => sum + (item.estimate || 0), 0);
    const avgPoints = Math.round(totalPoints / withEstimates.length * 10) / 10;
    console.log(
      Formatter.info(
        `\u{1F4CA} Story Points: ${totalPoints} total, ${avgPoints} average (${withEstimates.length} estimated)`
      )
    );
  }
  const lastWeek = /* @__PURE__ */ new Date();
  lastWeek.setDate(lastWeek.getDate() - 7);
  const recentActivity = filteredItems.filter((item) => item.updatedAt >= lastWeek).length;
  console.log(
    Formatter.info(`\u{1F504} Recent Activity: ${recentActivity} items updated in the last 7 days`)
  );
}
function hasActiveFilters(filters) {
  return Object.keys(filters).length > 0;
}
function displayActiveFilters(filters) {
  console.log(Formatter.header("\u{1F50D} Active Filters"));
  const filterDescriptions = [];
  if (filters.status) filterDescriptions.push(`Status: ${filters.status}`);
  if (filters.statusIn) filterDescriptions.push(`Status in: ${filters.statusIn.join(", ")}`);
  if (filters.priority) filterDescriptions.push(`Priority: ${filters.priority}`);
  if (filters.priorityIn) filterDescriptions.push(`Priority in: ${filters.priorityIn.join(", ")}`);
  if (filters.assignee) filterDescriptions.push(`Assignee: ${filters.assignee}`);
  if (filters.id) filterDescriptions.push(`ID: ${filters.id}`);
  if (filters.tags) filterDescriptions.push(`Tags: ${filters.tags.join(", ")}`);
  if (filters.createdAfter)
    filterDescriptions.push(`Created after: ${filters.createdAfter.toDateString()}`);
  if (filters.createdBefore)
    filterDescriptions.push(`Created before: ${filters.createdBefore.toDateString()}`);
  if (filters.updatedAfter)
    filterDescriptions.push(`Updated after: ${filters.updatedAfter.toDateString()}`);
  if (filters.updatedBefore)
    filterDescriptions.push(`Updated before: ${filters.updatedBefore.toDateString()}`);
  if (filters.estimateMin) filterDescriptions.push(`Min estimate: ${filters.estimateMin}`);
  if (filters.estimateMax) filterDescriptions.push(`Max estimate: ${filters.estimateMax}`);
  filterDescriptions.forEach((desc) => {
    console.log(Formatter.info(`  \u2022 ${desc}`));
  });
  console.log("");
}
function displayPaginationInfo(totalCount, displayedCount, options) {
  const offset = (options == null ? void 0 : options.offset) ? parseInt(options.offset) : 0;
  const limit = (options == null ? void 0 : options.limit) ? parseInt(options.limit) : displayedCount;
  console.log(
    Formatter.info(
      `\u{1F4C4} Pagination: Showing ${displayedCount} items (${offset + 1}-${offset + displayedCount} of ${totalCount})`
    )
  );
  if (offset + displayedCount < totalCount) {
    console.log(Formatter.info(`   Next page: --offset ${offset + limit} --limit ${limit}`));
  }
  console.log("");
}
async function exportResults(items, exportFile, config) {
  const spinner = (0, import_ora3.default)("Exporting filtered results...").start();
  try {
    const format = exportFile.split(".").pop() || "json";
    const exportData = Formatter.formatExport(items, format);
    writeFileSync(exportFile, exportData);
    spinner.succeed(`Exported ${items.length} items to ${exportFile}`);
    console.log(Formatter.info(`\u{1F4C4} Export completed: ${exportFile}`));
  } catch (error) {
    spinner.fail("Export failed");
    throw error;
  }
}
function displayNextSteps(items, config) {
  console.log(Formatter.header("\u{1F4A1} Quick Actions"));
  const todoItems = items.filter((item) => item.status === "todo");
  const inProgressItems = items.filter((item) => item.status === "in-progress");
  const blockedItems = items.filter((item) => item.status === "blocked");
  if (todoItems.length > 0) {
    console.log(Formatter.info("\u{1F4DD} Create a new task:"));
    console.log(Formatter.highlight('  trackdown track "New task title"'));
  }
  if (inProgressItems.length > 0) {
    console.log(Formatter.info("\u{1F504} Update task status:"));
    console.log(Formatter.highlight(`  # Edit file: ${inProgressItems[0].id}*.md`));
  }
  if (blockedItems.length > 0) {
    console.log(Formatter.warning("\u{1F6AB} Review blocked items for resolution"));
  }
  console.log(Formatter.info("\u{1F4CA} View detailed item:"));
  console.log(Formatter.highlight("  trackdown status --id <item-id> --verbose"));
  console.log("");
}
function getStatusIcon(status) {
  switch (status) {
    case "todo":
      return "\u{1F4DD}";
    case "in-progress":
      return "\u{1F504}";
    case "blocked":
      return "\u{1F6AB}";
    case "done":
      return "\u2705";
    default:
      return "\u{1F4C4}";
  }
}
function groupItemsByStatus(items) {
  const groups = {
    todo: [],
    "in-progress": [],
    blocked: [],
    done: []
  };
  for (const item of items) {
    if (groups[item.status]) {
      groups[item.status].push(item);
    }
  }
  return groups;
}
function getPriorityColor(priority) {
  switch (priority) {
    case "low":
      return Formatter.dim;
    case "medium":
      return (text) => text;
    // no color
    case "high":
      return (text) => Formatter.highlight(text);
    case "critical":
      return (text) => Formatter.error(text);
    default:
      return (text) => text;
  }
}
function validateStatus2(status) {
  const validStatuses = ["todo", "in-progress", "blocked", "done"];
  const normalizedStatus = status.toLowerCase().trim();
  if (!validStatuses.includes(normalizedStatus)) {
    throw new ValidationError(
      `Invalid status: ${status}`,
      `Valid statuses are: ${validStatuses.join(", ")}`,
      1,
      "status",
      validStatuses.map((s) => `--status ${s}`)
    );
  }
  return normalizedStatus;
}
var import_node_fs6, import_node_path6, import_commander3, import_inquirer3, import_ora3;
var init_status = __esm({
  "src/commands/status.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_fs6 = require("fs");
    import_node_path6 = require("path");
    import_commander3 = require("commander");
    import_inquirer3 = __toESM(require("inquirer"), 1);
    import_ora3 = __toESM(require("ora"), 1);
    init_config();
    init_path_resolver();
    init_formatter();
    init_validation();
    __name(createStatusCommand, "createStatusCommand");
    __name(runInteractiveStatusMode, "runInteractiveStatusMode");
    __name(buildFilterExpression, "buildFilterExpression");
    __name(runWatchMode, "runWatchMode");
    __name(getAllItemsEnhanced, "getAllItemsEnhanced");
    __name(parseTrackdownFileEnhanced, "parseTrackdownFileEnhanced");
    __name(parseFilters, "parseFilters");
    __name(parseAdvancedFilter, "parseAdvancedFilter");
    __name(applyAdvancedFilters2, "applyAdvancedFilters");
    __name(applySorting, "applySorting");
    __name(applyPagination, "applyPagination");
    __name(displayProjectOverview, "displayProjectOverview");
    __name(getProjectSummaryEnhanced, "getProjectSummaryEnhanced");
    __name(displayCompactView, "displayCompactView");
    __name(displayDetailedView, "displayDetailedView");
    __name(displayGroupedView, "displayGroupedView");
    __name(displayAdvancedStatistics, "displayAdvancedStatistics");
    __name(hasActiveFilters, "hasActiveFilters");
    __name(displayActiveFilters, "displayActiveFilters");
    __name(displayPaginationInfo, "displayPaginationInfo");
    __name(exportResults, "exportResults");
    __name(displayNextSteps, "displayNextSteps");
    __name(getStatusIcon, "getStatusIcon");
    __name(groupItemsByStatus, "groupItemsByStatus");
    __name(getPriorityColor, "getPriorityColor");
    __name(validateStatus2, "validateStatus");
  }
});

// src/utils/trackdown-index-manager.ts
var fs6, path6, import_util, readFile2, writeFile2, stat2, readdir2, access2, INDEX_FILE_NAME, INDEX_VERSION, MAX_CONCURRENT_READS, _TrackdownIndexManager, TrackdownIndexManager;
var init_trackdown_index_manager = __esm({
  "src/utils/trackdown-index-manager.ts"() {
    "use strict";
    init_cjs_shims();
    fs6 = __toESM(require("fs"), 1);
    path6 = __toESM(require("path"), 1);
    import_util = require("util");
    init_frontmatter_parser();
    init_unified_path_resolver();
    readFile2 = (0, import_util.promisify)(fs6.readFile);
    writeFile2 = (0, import_util.promisify)(fs6.writeFile);
    stat2 = (0, import_util.promisify)(fs6.stat);
    readdir2 = (0, import_util.promisify)(fs6.readdir);
    access2 = (0, import_util.promisify)(fs6.access);
    INDEX_FILE_NAME = ".ai-trackdown-index";
    INDEX_VERSION = "1.0.0";
    MAX_CONCURRENT_READS = 50;
    _TrackdownIndexManager = class _TrackdownIndexManager {
      indexPath;
      tasksDir;
      projectPath;
      config;
      pathResolver;
      frontmatterParser;
      // Memory cache for performance
      cachedIndex = null;
      cacheTimestamp = 0;
      CACHE_TTL = 5e3;
      // 5 seconds cache TTL
      constructor(config, projectPath, cliTasksDir) {
        this.config = config;
        this.projectPath = projectPath;
        this.pathResolver = new UnifiedPathResolver(config, projectPath, cliTasksDir);
        this.frontmatterParser = new FrontmatterParser();
        const paths = this.pathResolver.getUnifiedPaths();
        this.tasksDir = paths.tasksRoot;
        this.indexPath = path6.join(this.tasksDir, INDEX_FILE_NAME);
      }
      /**
       * Load index with memory caching and performance optimization
       */
      async loadIndex() {
        const tracker = this.startPerformanceTracking("loadIndex");
        try {
          if (this.cachedIndex && Date.now() - this.cacheTimestamp < this.CACHE_TTL) {
            this.endPerformanceTracking(tracker);
            return this.cachedIndex;
          }
          if (!await this.indexExists()) {
            console.warn(`Index file not found at ${this.indexPath}. Rebuilding...`);
            return await this.rebuildIndex();
          }
          const indexContent = await readFile2(this.indexPath, "utf8");
          const index = JSON.parse(indexContent);
          if (!this.validateIndexStructure(index)) {
            console.warn("Index file corrupted. Rebuilding...");
            return await this.rebuildIndex();
          }
          this.cachedIndex = index;
          this.cacheTimestamp = Date.now();
          const loadTime = this.endPerformanceTracking(tracker);
          index.stats.performanceMetrics.lastLoadTime = loadTime;
          return index;
        } catch (error) {
          console.warn(`Failed to load index: ${error instanceof Error ? error.message : "Unknown error"}. Rebuilding...`);
          return await this.rebuildIndex();
        }
      }
      /**
       * Save index with atomic writes and compression consideration
       */
      async saveIndex(index) {
        const tracker = this.startPerformanceTracking("saveIndex");
        try {
          index.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
          index.projectPath = this.projectPath;
          index.stats.totalEpics = Object.keys(index.epics).length;
          index.stats.totalIssues = Object.keys(index.issues).length;
          index.stats.totalTasks = Object.keys(index.tasks).length;
          index.stats.totalPRs = Object.keys(index.prs).length;
          const indexContent = JSON.stringify(index, null, 2);
          index.stats.indexSize = Buffer.byteLength(indexContent, "utf8");
          await this.ensureTasksDirectoryExists();
          const tempPath = `${this.indexPath}.tmp`;
          await writeFile2(tempPath, indexContent, "utf8");
          fs6.renameSync(tempPath, this.indexPath);
          this.cachedIndex = index;
          this.cacheTimestamp = Date.now();
          const saveTime = this.endPerformanceTracking(tracker);
          index.stats.performanceMetrics.lastUpdateTime = saveTime;
        } catch (error) {
          throw new Error(`Failed to save index: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Rebuild entire index by scanning filesystem
       */
      async rebuildIndex() {
        const tracker = this.startPerformanceTracking("rebuildIndex");
        console.log("\u{1F504} Rebuilding AI-Trackdown index...");
        const newIndex = {
          version: INDEX_VERSION,
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
          projectPath: this.projectPath,
          epics: {},
          issues: {},
          tasks: {},
          prs: {},
          stats: {
            totalEpics: 0,
            totalIssues: 0,
            totalTasks: 0,
            totalPRs: 0,
            lastFullScan: (/* @__PURE__ */ new Date()).toISOString(),
            indexSize: 0,
            performanceMetrics: {
              lastLoadTime: 0,
              lastUpdateTime: 0,
              lastRebuildTime: 0
            }
          }
        };
        try {
          const paths = this.pathResolver.getUnifiedPaths();
          const scanTasks = [
            this.scanDirectory(paths.epicsDir, "epic"),
            this.scanDirectory(paths.issuesDir, "issue"),
            this.scanDirectory(paths.tasksDir, "task"),
            this.scanDirectory(paths.prsDir, "pr")
          ];
          const [epics, issues, tasks, prs] = await Promise.all(scanTasks);
          for (const epic of epics) {
            newIndex.epics[epic.id] = await this.createEpicIndexEntry(epic);
          }
          for (const issue of issues) {
            newIndex.issues[issue.id] = await this.createIssueIndexEntry(issue);
          }
          for (const task of tasks) {
            newIndex.tasks[task.id] = await this.createTaskIndexEntry(task);
          }
          for (const pr of prs) {
            newIndex.prs[pr.id] = await this.createPRIndexEntry(pr);
          }
          this.buildRelationships(newIndex);
          await this.saveIndex(newIndex);
          const rebuildTime = this.endPerformanceTracking(tracker);
          newIndex.stats.performanceMetrics.lastRebuildTime = rebuildTime;
          console.log(`\u2705 Index rebuilt successfully in ${rebuildTime}ms`);
          console.log(`\u{1F4CA} Indexed: ${newIndex.stats.totalEpics} epics, ${newIndex.stats.totalIssues} issues, ${newIndex.stats.totalTasks} tasks, ${newIndex.stats.totalPRs} PRs`);
          return newIndex;
        } catch (error) {
          throw new Error(`Failed to rebuild index: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Update single item in index (incremental update)
       */
      async updateItem(type, id) {
        const tracker = this.startPerformanceTracking("updateItem");
        try {
          const index = await this.loadIndex();
          const filePath = await this.findItemFile(type, id);
          if (!filePath || !fs6.existsSync(filePath)) {
            await this.removeItem(type, id);
            return;
          }
          const itemData = this.frontmatterParser.parseAnyItem(filePath);
          switch (type) {
            case "epic":
              index.epics[id] = await this.createEpicIndexEntry(itemData);
              break;
            case "issue":
              index.issues[id] = await this.createIssueIndexEntry(itemData);
              break;
            case "task":
              index.tasks[id] = await this.createTaskIndexEntry(itemData);
              break;
            case "pr":
              index.prs[id] = await this.createPRIndexEntry(itemData);
              break;
          }
          this.updateRelationships(index, type, id);
          await this.saveIndex(index);
          this.endPerformanceTracking(tracker);
        } catch (error) {
          throw new Error(`Failed to update item ${type}/${id}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Remove item from index
       */
      async removeItem(type, id) {
        const tracker = this.startPerformanceTracking("removeItem");
        try {
          const index = await this.loadIndex();
          switch (type) {
            case "epic":
              delete index.epics[id];
              for (const issueId of Object.keys(index.issues)) {
                if (index.issues[issueId].epicId === id) {
                  delete index.issues[issueId];
                }
              }
              for (const taskId of Object.keys(index.tasks)) {
                if (index.tasks[taskId].epicId === id) {
                  delete index.tasks[taskId];
                }
              }
              break;
            case "issue":
              delete index.issues[id];
              for (const taskId of Object.keys(index.tasks)) {
                if (index.tasks[taskId].issueId === id) {
                  delete index.tasks[taskId];
                }
              }
              for (const prId of Object.keys(index.prs)) {
                if (index.prs[prId].issueId === id) {
                  delete index.prs[prId];
                }
              }
              break;
            case "task":
              delete index.tasks[id];
              break;
            case "pr":
              delete index.prs[id];
              break;
          }
          this.cleanupRelationships(index, type, id);
          await this.saveIndex(index);
          this.endPerformanceTracking(tracker);
        } catch (error) {
          throw new Error(`Failed to remove item ${type}/${id}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Validate index structure and detect corruption
       */
      async validateIndex() {
        try {
          const index = await this.loadIndex();
          return this.validateIndexStructure(index);
        } catch {
          return false;
        }
      }
      /**
       * Get index statistics and health information
       */
      async getIndexStats() {
        try {
          const indexExists = await this.indexExists();
          let lastModified;
          if (indexExists) {
            const stats = await stat2(this.indexPath);
            lastModified = stats.mtime;
          }
          const index = await this.loadIndex();
          const cacheHit = Date.now() - this.cacheTimestamp < this.CACHE_TTL;
          return {
            ...index.stats,
            healthy: this.validateIndexStructure(index),
            cacheHit,
            indexFileExists: indexExists,
            lastModified
          };
        } catch (error) {
          return {
            totalEpics: 0,
            totalIssues: 0,
            totalTasks: 0,
            totalPRs: 0,
            lastFullScan: "",
            indexSize: 0,
            performanceMetrics: {
              lastLoadTime: 0,
              lastUpdateTime: 0,
              lastRebuildTime: 0
            },
            healthy: false,
            cacheHit: false,
            indexFileExists: false
          };
        }
      }
      /**
       * Clear memory cache (useful for testing or forcing reload)
       */
      clearCache() {
        this.cachedIndex = null;
        this.cacheTimestamp = 0;
      }
      /**
       * Get all items of a specific type with fast index lookup
       */
      async getItemsByType(type) {
        const index = await this.loadIndex();
        switch (type) {
          case "epic":
            return Object.values(index.epics);
          case "issue":
            return Object.values(index.issues);
          case "task":
            return Object.values(index.tasks);
          case "pr":
            return Object.values(index.prs);
          default:
            return [];
        }
      }
      /**
       * Fast item lookup by ID
       */
      async getItemById(type, id) {
        const index = await this.loadIndex();
        switch (type) {
          case "epic":
            return index.epics[id] || null;
          case "issue":
            return index.issues[id] || null;
          case "task":
            return index.tasks[id] || null;
          case "pr":
            return index.prs[id] || null;
          default:
            return null;
        }
      }
      /**
       * Get items by status with fast filtering
       */
      async getItemsByStatus(status) {
        const index = await this.loadIndex();
        const allItems = [
          ...Object.values(index.epics),
          ...Object.values(index.issues),
          ...Object.values(index.tasks),
          ...Object.values(index.prs)
        ];
        return allItems.filter((item) => item.status === status);
      }
      /**
       * Get project overview with pre-calculated metrics
       */
      async getProjectOverview() {
        const index = await this.loadIndex();
        const allItems = [
          ...Object.values(index.epics),
          ...Object.values(index.issues),
          ...Object.values(index.tasks),
          ...Object.values(index.prs)
        ];
        const byStatus = allItems.reduce((acc, item) => {
          acc[item.status] = (acc[item.status] || 0) + 1;
          return acc;
        }, {});
        const byPriority = allItems.reduce((acc, item) => {
          acc[item.priority] = (acc[item.priority] || 0) + 1;
          return acc;
        }, {});
        const byType = {
          epic: index.stats.totalEpics,
          issue: index.stats.totalIssues,
          task: index.stats.totalTasks,
          pr: index.stats.totalPRs
        };
        const completedItems = byStatus.completed || 0;
        const completionRate = allItems.length > 0 ? Math.round(completedItems / allItems.length * 100) : 0;
        const lastWeek = /* @__PURE__ */ new Date();
        lastWeek.setDate(lastWeek.getDate() - 7);
        const recentActivity = allItems.filter((item) => new Date(item.lastModified) >= lastWeek).sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime()).slice(0, 10);
        return {
          totalItems: allItems.length,
          byStatus,
          byPriority,
          byType,
          completionRate,
          recentActivity
        };
      }
      // Private helper methods
      async indexExists() {
        try {
          await access2(this.indexPath);
          return true;
        } catch {
          return false;
        }
      }
      validateIndexStructure(index) {
        return !!(index.version && index.lastUpdated && index.projectPath && index.epics && index.issues && index.tasks && index.prs && index.stats);
      }
      async ensureTasksDirectoryExists() {
        try {
          await access2(this.tasksDir);
        } catch {
          fs6.mkdirSync(this.tasksDir, { recursive: true });
        }
      }
      async scanDirectory(dirPath, itemType) {
        try {
          await access2(dirPath);
        } catch {
          return [];
        }
        const files = await readdir2(dirPath);
        const mdFiles = files.filter((file) => file.endsWith(".md"));
        const results = [];
        const batchSize = Math.min(MAX_CONCURRENT_READS, mdFiles.length);
        for (let i = 0; i < mdFiles.length; i += batchSize) {
          const batch = mdFiles.slice(i, i + batchSize);
          const batchPromises = batch.map(async (file) => {
            try {
              const filePath = path6.join(dirPath, file);
              return this.frontmatterParser.parseAnyItem(filePath);
            } catch (error) {
              console.warn(`Failed to parse ${file}: ${error instanceof Error ? error.message : "Unknown error"}`);
              return null;
            }
          });
          const batchResults = await Promise.all(batchPromises);
          results.push(...batchResults.filter(Boolean));
        }
        return results;
      }
      async createEpicIndexEntry(epic) {
        const stats = await stat2(epic.file_path);
        return {
          id: epic.epic_id,
          title: epic.title,
          filePath: epic.file_path,
          status: epic.status,
          priority: epic.priority,
          lastModified: epic.updated_date,
          fileSize: stats.size,
          assignee: epic.assignee !== "unassigned" ? epic.assignee : void 0,
          tags: epic.tags,
          issueIds: epic.related_issues || [],
          milestone: epic.milestone,
          completion_percentage: epic.completion_percentage
        };
      }
      async createIssueIndexEntry(issue) {
        const stats = await stat2(issue.file_path);
        return {
          id: issue.issue_id,
          title: issue.title,
          filePath: issue.file_path,
          status: issue.status,
          priority: issue.priority,
          lastModified: issue.updated_date,
          fileSize: stats.size,
          assignee: issue.assignee !== "unassigned" ? issue.assignee : void 0,
          tags: issue.tags,
          epicId: issue.epic_id,
          taskIds: issue.related_tasks || [],
          prIds: issue.related_prs || [],
          blocked_by: issue.blocked_by,
          blocks: issue.blocks
        };
      }
      async createTaskIndexEntry(task) {
        const stats = await stat2(task.file_path);
        return {
          id: task.task_id,
          title: task.title,
          filePath: task.file_path,
          status: task.status,
          priority: task.priority,
          lastModified: task.updated_date,
          fileSize: stats.size,
          assignee: task.assignee !== "unassigned" ? task.assignee : void 0,
          tags: task.tags,
          issueId: task.issue_id,
          epicId: task.epic_id,
          time_estimate: task.time_estimate,
          time_spent: task.time_spent,
          parent_task: task.parent_task,
          subtasks: task.subtasks
        };
      }
      async createPRIndexEntry(pr) {
        const stats = await stat2(pr.file_path);
        return {
          id: pr.pr_id,
          title: pr.title,
          filePath: pr.file_path,
          status: pr.status,
          priority: pr.priority,
          lastModified: pr.updated_date,
          fileSize: stats.size,
          assignee: pr.assignee !== "unassigned" ? pr.assignee : void 0,
          tags: pr.tags,
          issueId: pr.issue_id,
          epicId: pr.epic_id,
          pr_status: pr.pr_status,
          branch_name: pr.branch_name,
          pr_number: pr.pr_number,
          reviewers: pr.reviewers
        };
      }
      buildRelationships(index) {
        for (const epic of Object.values(index.epics)) {
          epic.issueIds = Object.values(index.issues).filter((issue) => issue.epicId === epic.id).map((issue) => issue.id);
        }
        for (const issue of Object.values(index.issues)) {
          issue.taskIds = Object.values(index.tasks).filter((task) => task.issueId === issue.id).map((task) => task.id);
          issue.prIds = Object.values(index.prs).filter((pr) => pr.issueId === issue.id).map((pr) => pr.id);
        }
      }
      updateRelationships(index, type, id) {
        this.buildRelationships(index);
      }
      cleanupRelationships(index, type, id) {
        switch (type) {
          case "epic":
            for (const epic of Object.values(index.epics)) {
              epic.issueIds = epic.issueIds.filter((issueId) => issueId !== id);
            }
            break;
          case "issue":
            for (const issue of Object.values(index.issues)) {
              issue.taskIds = issue.taskIds.filter((taskId) => taskId !== id);
              issue.prIds = issue.prIds.filter((prId) => prId !== id);
            }
            break;
        }
      }
      async findItemFile(type, id) {
        const paths = this.pathResolver.getUnifiedPaths();
        const typeDir = this.pathResolver.getItemTypeDirectory(type);
        try {
          const files = await readdir2(typeDir);
          const mdFiles = files.filter((file) => file.endsWith(".md"));
          for (const file of mdFiles) {
            if (file.includes(id)) {
              return path6.join(typeDir, file);
            }
          }
        } catch {
        }
        return null;
      }
      startPerformanceTracking(operation) {
        return {
          startTime: Date.now(),
          operation
        };
      }
      endPerformanceTracking(tracker) {
        const duration = Date.now() - tracker.startTime;
        if (duration > 100) {
          console.warn(`\u26A0\uFE0F Slow ${tracker.operation}: ${duration}ms`);
        }
        return duration;
      }
    };
    __name(_TrackdownIndexManager, "TrackdownIndexManager");
    TrackdownIndexManager = _TrackdownIndexManager;
  }
});

// src/commands/status-enhanced.ts
function createStatusEnhancedCommand() {
  const command = new import_commander4.Command("status-enhanced");
  command.description("Display comprehensive project status using high-performance index system").option("-v, --verbose", "show detailed item information").option("-c, --compact", "compact output format").option("--table", "display results in table format").option("--stats", "show detailed project statistics").option("-s, --status <status>", "filter by status (planning|active|completed|archived)").option("-p, --priority <priority>", "filter by priority (low|medium|high|critical)").option("-a, --assignee <name>", "filter by assignee").option("-t, --tags <tags>", "filter by tags (comma-separated)").option("--type <type>", "filter by item type (epic|issue|task|pr)").option("--limit <count>", "limit number of results").option("--rebuild-index", "force rebuild of index before displaying status").option("--index-stats", "show index performance and health statistics").addHelpText("after", `
Examples:
  $ aitrackdown status-enhanced
  $ aitrackdown status-enhanced --verbose --stats
  $ aitrackdown status-enhanced --status active --priority high
  $ aitrackdown status-enhanced --type epic --table
  $ aitrackdown status-enhanced --rebuild-index
  $ aitrackdown status-enhanced --index-stats

Performance Benefits:
  - \u{1F680} >90% faster than traditional filesystem scanning
  - \u26A1 <10ms response time for projects with 1000+ items  
  - \u{1F4CA} Pre-calculated metrics and relationships
  - \u{1F504} Real-time incremental updates
  - \u{1F4BE} <5MB memory usage for large projects

Filter Options:
  Status: planning, active, completed, archived
  Priority: low, medium, high, critical
  Type: epic, issue, task, pr
`).action(async (options) => {
    try {
      await displayEnhancedStatus(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to get status: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return command;
}
async function displayEnhancedStatus(options) {
  var _a, _b, _c;
  const startTime = Date.now();
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parentCommand = (_a = process.command) == null ? void 0 : _a.parent;
  const cliTasksDir = ((_b = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _b.rootDir) || ((_c = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _c.tasksDir);
  const projectRoot = configManager.findProjectRoot();
  const indexManager = new TrackdownIndexManager(config, projectRoot, cliTasksDir);
  if (options.rebuildIndex) {
    console.log(Formatter.info("\u{1F504} Rebuilding index..."));
    await indexManager.rebuildIndex();
  }
  if (options.indexStats) {
    await displayIndexStatistics(indexManager);
    return;
  }
  console.log(Formatter.header(`\u{1F4CA} ${config.name || "AI-Trackdown"} Project Status (Enhanced)`));
  const overview = await indexManager.getProjectOverview();
  displayProjectSummary(overview, startTime);
  const filteredItems = await applyFilters(indexManager, options);
  const limitedItems = options.limit ? filteredItems.slice(0, parseInt(options.limit)) : filteredItems;
  if (limitedItems.length === 0) {
    console.log(Formatter.box("No items match the current filters", "info"));
    return;
  }
  if (options.table) {
    displayTableView(limitedItems);
  } else if (options.compact) {
    displayCompactView2(limitedItems);
  } else if (options.verbose) {
    displayVerboseView(limitedItems);
  } else {
    displayGroupedView2(limitedItems);
  }
  if (options.stats) {
    await displayDetailedStatistics(indexManager, overview);
  }
  const totalTime = Date.now() - startTime;
  console.log(Formatter.dim(`
\u26A1 Retrieved in ${totalTime}ms using index system`));
  if (filteredItems.length !== overview.totalItems) {
    console.log(Formatter.info(`\u{1F4CA} Showing ${limitedItems.length} of ${filteredItems.length} filtered items (${overview.totalItems} total)`));
  }
}
async function displayIndexStatistics(indexManager) {
  const stats = await indexManager.getIndexStats();
  console.log(Formatter.header("\u{1F4C8} Index System Statistics"));
  console.log(Formatter.info(`Health Status: ${stats.healthy ? "\u2705 Healthy" : "\u274C Unhealthy"}`));
  console.log(Formatter.info(`Index File Exists: ${stats.indexFileExists ? "\u2705 Yes" : "\u274C No"}`));
  console.log(Formatter.info(`Cache Hit: ${stats.cacheHit ? "\u2705 Yes" : "\u274C No"}`));
  if (stats.lastModified) {
    console.log(Formatter.info(`Last Modified: ${stats.lastModified.toLocaleString()}`));
  }
  console.log(Formatter.subheader("\n\u{1F4CA} Content Statistics"));
  console.log(Formatter.info(`Total Epics: ${stats.totalEpics}`));
  console.log(Formatter.info(`Total Issues: ${stats.totalIssues}`));
  console.log(Formatter.info(`Total Tasks: ${stats.totalTasks}`));
  console.log(Formatter.info(`Total PRs: ${stats.totalPRs}`));
  console.log(Formatter.info(`Index Size: ${Math.round(stats.indexSize / 1024)}KB`));
  console.log(Formatter.info(`Last Full Scan: ${stats.lastFullScan}`));
  console.log(Formatter.subheader("\n\u26A1 Performance Metrics"));
  console.log(Formatter.info(`Last Load Time: ${stats.performanceMetrics.lastLoadTime}ms`));
  console.log(Formatter.info(`Last Update Time: ${stats.performanceMetrics.lastUpdateTime}ms`));
  console.log(Formatter.info(`Last Rebuild Time: ${stats.performanceMetrics.lastRebuildTime}ms`));
  const isPerformant = stats.performanceMetrics.lastLoadTime < 50 && stats.performanceMetrics.lastUpdateTime < 20;
  console.log(Formatter.subheader("\n\u{1F3AF} Performance Assessment"));
  console.log(Formatter.info(`Overall Performance: ${isPerformant ? "\u{1F680} Excellent" : "\u26A0\uFE0F Needs Optimization"}`));
  if (!isPerformant) {
    console.log(Formatter.warning("Consider rebuilding the index if performance is slow"));
    console.log(Formatter.info("Run: aitrackdown status-enhanced --rebuild-index"));
  }
}
function displayProjectSummary(overview, startTime) {
  const activeItems = overview.totalItems - (overview.byStatus.completed || 0);
  console.log(Formatter.subheader("\u{1F4CB} Project Overview"));
  console.log(Formatter.info(`Active Items: ${Formatter.highlight(activeItems.toString())}`));
  console.log(Formatter.info(`Completed Items: ${Formatter.highlight((overview.byStatus.completed || 0).toString())}`));
  console.log(Formatter.info(`Total Items: ${Formatter.highlight(overview.totalItems.toString())}`));
  console.log(Formatter.info(`Completion Rate: ${Formatter.highlight(`${overview.completionRate}%`)}`));
  console.log(Formatter.info(`Type Breakdown: Epics: ${overview.byType.epic}, Issues: ${overview.byType.issue}, Tasks: ${overview.byType.task}, PRs: ${overview.byType.pr}`));
  const priorityBreakdown = Object.entries(overview.byPriority).map(([priority, count]) => `${priority}: ${count}`).join(", ");
  console.log(Formatter.info(`Priority Breakdown: ${priorityBreakdown}`));
  console.log("");
}
async function applyFilters(indexManager, options) {
  let items = [];
  if (options.type) {
    items = await indexManager.getItemsByType(options.type);
  } else {
    const [epics, issues, tasks, prs] = await Promise.all([
      indexManager.getItemsByType("epic"),
      indexManager.getItemsByType("issue"),
      indexManager.getItemsByType("task"),
      indexManager.getItemsByType("pr")
    ]);
    items = [...epics, ...issues, ...tasks, ...prs];
  }
  if (options.status) {
    items = items.filter((item) => item.status === options.status);
  }
  if (options.priority) {
    items = items.filter((item) => item.priority === options.priority);
  }
  if (options.assignee) {
    items = items.filter((item) => item.assignee === options.assignee);
  }
  if (options.tags) {
    const filterTags = options.tags.split(",").map((tag) => tag.trim());
    items = items.filter(
      (item) => item.tags && item.tags.some((tag) => filterTags.includes(tag))
    );
  }
  items.sort((a, b) => new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime());
  return items;
}
function displayTableView(items) {
  console.log(Formatter.subheader("\u{1F4CA} Items Table"));
  const headers = ["ID", "Type", "Title", "Status", "Priority", "Assignee", "Modified"];
  const rows = items.map((item) => [
    item.id,
    getItemType(item),
    item.title.length > 30 ? item.title.substring(0, 27) + "..." : item.title,
    item.status,
    item.priority,
    item.assignee || "unassigned",
    new Date(item.lastModified).toLocaleDateString()
  ]);
  console.log(headers.join("	"));
  console.log("-".repeat(100));
  rows.forEach((row) => console.log(row.join("	")));
}
function displayCompactView2(items) {
  console.log(Formatter.subheader("\u{1F4DD} Compact View"));
  items.forEach((item, index) => {
    const typeEmoji = getTypeEmoji(getItemType(item));
    const statusEmoji = getStatusEmoji(item.status);
    const priorityColor = getPriorityColor2(item.priority);
    console.log(
      `${(index + 1).toString().padStart(3, " ")}. ${typeEmoji} ${statusEmoji} ${priorityColor(item.priority[0].toUpperCase())} ${item.title} ${Formatter.dim(`(${item.id})`)}`
    );
  });
}
function displayVerboseView(items) {
  console.log(Formatter.subheader("\u{1F4D6} Detailed View"));
  items.forEach((item, index) => {
    var _a;
    const typeEmoji = getTypeEmoji(getItemType(item));
    const statusEmoji = getStatusEmoji(item.status);
    console.log(`${typeEmoji} ${statusEmoji} ${Formatter.highlight(item.title)}`);
    console.log(`   ID: ${item.id}`);
    console.log(`   Status: ${item.status} | Priority: ${item.priority}`);
    if (item.assignee) console.log(`   Assignee: ${item.assignee}`);
    if ((_a = item.tags) == null ? void 0 : _a.length) console.log(`   Tags: ${item.tags.join(", ")}`);
    console.log(`   Modified: ${new Date(item.lastModified).toLocaleString()}`);
    console.log(`   File: ${item.filePath}`);
    if (index < items.length - 1) {
      console.log(Formatter.dim("\u2500".repeat(60)));
    }
  });
}
function displayGroupedView2(items) {
  console.log(Formatter.subheader("\u{1F4CB} Status Overview"));
  const grouped = items.reduce((acc, item) => {
    if (!acc[item.status]) acc[item.status] = [];
    acc[item.status].push(item);
    return acc;
  }, {});
  for (const [status, statusItems] of Object.entries(grouped)) {
    if (statusItems.length > 0) {
      const statusEmoji = getStatusEmoji(status);
      console.log(Formatter.subheader(`${statusEmoji} ${status.toUpperCase()} (${statusItems.length})`));
      statusItems.forEach((item, index) => {
        var _a;
        const typeEmoji = getTypeEmoji(getItemType(item));
        const priorityColor = getPriorityColor2(item.priority);
        const assigneeInfo = item.assignee ? ` @${item.assignee}` : "";
        const tagsInfo = ((_a = item.tags) == null ? void 0 : _a.length) ? ` [${item.tags.join(", ")}]` : "";
        console.log(
          `  ${index + 1}. ${typeEmoji} ${priorityColor(item.priority.toUpperCase())} ${item.title}${assigneeInfo}${tagsInfo} ${Formatter.dim(`(${item.id})`)}`
        );
      });
      console.log("");
    }
  }
}
async function displayDetailedStatistics(indexManager, overview) {
  console.log(Formatter.header("\u{1F4C8} Detailed Analytics"));
  if (overview.recentActivity.length > 0) {
    console.log(Formatter.subheader("\u{1F504} Recent Activity (Last 7 Days)"));
    overview.recentActivity.forEach((item) => {
      const typeEmoji = getTypeEmoji(getItemType(item));
      console.log(`${typeEmoji} ${item.title} - ${new Date(item.lastModified).toLocaleDateString()}`);
    });
    console.log("");
  }
  const stats = await indexManager.getIndexStats();
  console.log(Formatter.subheader("\u26A1 Performance Metrics"));
  console.log(Formatter.info(`Index Load Time: ${stats.performanceMetrics.lastLoadTime}ms`));
  console.log(Formatter.info(`Index Size: ${Math.round(stats.indexSize / 1024)}KB`));
  console.log(Formatter.info(`Cache Status: ${stats.cacheHit ? "Hit" : "Miss"}`));
}
function getItemType(item) {
  if (item.id.startsWith("EP-")) return "epic";
  if (item.id.startsWith("ISS-")) return "issue";
  if (item.id.startsWith("TSK-")) return "task";
  if (item.id.startsWith("PR-")) return "pr";
  return "unknown";
}
function getTypeEmoji(type) {
  switch (type) {
    case "epic":
      return "\u{1F3AF}";
    case "issue":
      return "\u{1F4CB}";
    case "task":
      return "\u2705";
    case "pr":
      return "\u{1F504}";
    default:
      return "\u{1F4C4}";
  }
}
function getStatusEmoji(status) {
  switch (status) {
    case "planning":
      return "\u{1F4DD}";
    case "active":
      return "\u{1F504}";
    case "completed":
      return "\u2705";
    case "archived":
      return "\u{1F4E6}";
    default:
      return "\u{1F4C4}";
  }
}
function getPriorityColor2(priority) {
  switch (priority) {
    case "low":
      return Formatter.dim;
    case "medium":
      return (text) => text;
    case "high":
      return Formatter.highlight;
    case "critical":
      return Formatter.error;
    default:
      return (text) => text;
  }
}
var import_commander4;
var init_status_enhanced = __esm({
  "src/commands/status-enhanced.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander4 = require("commander");
    init_config_manager();
    init_trackdown_index_manager();
    init_formatter();
    __name(createStatusEnhancedCommand, "createStatusEnhancedCommand");
    __name(displayEnhancedStatus, "displayEnhancedStatus");
    __name(displayIndexStatistics, "displayIndexStatistics");
    __name(displayProjectSummary, "displayProjectSummary");
    __name(applyFilters, "applyFilters");
    __name(displayTableView, "displayTableView");
    __name(displayCompactView2, "displayCompactView");
    __name(displayVerboseView, "displayVerboseView");
    __name(displayGroupedView2, "displayGroupedView");
    __name(displayDetailedStatistics, "displayDetailedStatistics");
    __name(getItemType, "getItemType");
    __name(getTypeEmoji, "getTypeEmoji");
    __name(getStatusEmoji, "getStatusEmoji");
    __name(getPriorityColor2, "getPriorityColor");
  }
});

// src/commands/backlog.ts
function createBacklogCommand() {
  const cmd = new import_commander5.Command("backlog");
  cmd.description("Show comprehensive project backlog").option("--epic <epic-id>", "filter by specific epic").option("--status <status>", "filter by status (planning, active, completed, archived)").option("--format <format>", "output format (table, json, markdown)", "table").option("--full", "show full backlog with all details").option("--with-issues", "include issues in epic display").option("--with-tasks", "include tasks in issue display").action(async (options) => {
    try {
      await showBacklog(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to show backlog: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function showBacklog(options) {
  const configManager = new ConfigManager2();
  const parser = new FrontmatterParser();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  console.log(Formatter.info("\u{1F4CB} Project Backlog"));
  console.log("=".repeat(50));
  try {
    const epics = parser.parseDirectory(paths.epicsDir, "epic");
    if (epics.length === 0) {
      console.log(Formatter.warning("No epics found in project"));
      return;
    }
    let filteredEpics = epics;
    if (options.epic) {
      filteredEpics = epics.filter((epic) => epic.epic_id === options.epic);
    }
    if (options.status) {
      filteredEpics = epics.filter((epic) => epic.status === options.status);
    }
    if (options.format === "json") {
      console.log(JSON.stringify(filteredEpics, null, 2));
      return;
    }
    for (const epic of filteredEpics) {
      await displayEpic(epic, parser, paths, options);
    }
    console.log("");
    console.log(Formatter.info(`\u{1F4CA} Summary: ${filteredEpics.length} epic(s)`));
    console.log(Formatter.success("\u2705 Backlog display complete"));
  } catch (error) {
    console.error(Formatter.error(`Error reading backlog: ${error instanceof Error ? error.message : "Unknown error"}`));
  }
}
async function displayEpic(epic, parser, paths, options) {
  console.log("");
  console.log(Formatter.success(`\u{1F3AF} ${epic.epic_id}: ${epic.title}`));
  console.log(Formatter.info(`   Status: ${epic.status} | Priority: ${epic.priority} | Assignee: ${epic.assignee}`));
  console.log(Formatter.debug(`   Created: ${epic.created_date} | Updated: ${epic.updated_date}`));
  if (epic.description && options.full) {
    console.log(Formatter.debug(`   Description: ${epic.description}`));
  }
  if (epic.tags && epic.tags.length > 0) {
    console.log(Formatter.debug(`   Tags: ${epic.tags.join(", ")}`));
  }
  if (options.withIssues) {
    try {
      const allIssues = parser.parseDirectory(paths.issuesDir, "issue");
      const epicIssues = allIssues.filter((issue) => issue.epic_id === epic.epic_id);
      if (epicIssues.length > 0) {
        console.log(Formatter.info(`   \u{1F4CB} Issues (${epicIssues.length}):`));
        for (const issue of epicIssues) {
          console.log(Formatter.debug(`     \u2022 ${issue.issue_id}: ${issue.title} [${issue.status}]`));
          if (options.withTasks) {
            try {
              const allTasks = parser.parseDirectory(paths.tasksDir, "task");
              const issueTasks = allTasks.filter((task) => task.issue_id === issue.issue_id);
              if (issueTasks.length > 0) {
                for (const task of issueTasks) {
                  console.log(Formatter.debug(`       - ${task.task_id}: ${task.title} [${task.status}]`));
                }
              }
            } catch (taskError) {
              console.log(Formatter.warning(`       Error reading tasks: ${taskError}`));
            }
          }
        }
      }
    } catch (issueError) {
      console.log(Formatter.warning(`   Error reading issues: ${issueError}`));
    }
  }
}
var import_commander5;
var init_backlog = __esm({
  "src/commands/backlog.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander5 = require("commander");
    init_config_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createBacklogCommand, "createBacklogCommand");
    __name(showBacklog, "showBacklog");
    __name(displayEpic, "displayEpic");
  }
});

// src/commands/backlog-enhanced.ts
function createBacklogEnhancedCommand() {
  const command = new import_commander6.Command("backlog-enhanced");
  command.description("Display project backlog with hierarchical view using high-performance index").option("-e, --epic <epic-id>", "filter by specific epic").option("-s, --status <status>", "filter by status (planning|active|completed|archived)").option("-p, --priority <priority>", "filter by priority (low|medium|high|critical)").option("-a, --assignee <name>", "filter by assignee").option("-d, --detailed", "show detailed information for each item").option("--hierarchy", "show complete hierarchical structure").option("--progress", "show detailed progress metrics").option("--export <file>", "export backlog to JSON file").option("--rebuild-index", "force rebuild of index before displaying backlog").addHelpText("after", `
Examples:
  $ aitrackdown backlog-enhanced
  $ aitrackdown backlog-enhanced --hierarchy --progress
  $ aitrackdown backlog-enhanced --epic EP-0001 --detailed
  $ aitrackdown backlog-enhanced --status active --priority high
  $ aitrackdown backlog-enhanced --export backlog.json

Performance Features:
  \u26A1 Instant backlog generation from indexed data
  \u{1F517} Pre-calculated hierarchical relationships
  \u{1F4CA} Real-time progress tracking
  \u{1F3AF} Fast filtering across all dimensions
`).action(async (options) => {
    try {
      await displayEnhancedBacklog(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to display backlog: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return command;
}
async function displayEnhancedBacklog(options) {
  var _a, _b, _c;
  const startTime = Date.now();
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parentCommand = (_a = process.command) == null ? void 0 : _a.parent;
  const cliTasksDir = ((_b = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _b.rootDir) || ((_c = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _c.tasksDir);
  const projectRoot = configManager.findProjectRoot();
  const indexManager = new TrackdownIndexManager(config, projectRoot, cliTasksDir);
  if (options.rebuildIndex) {
    console.log(Formatter.info("\u{1F504} Rebuilding index..."));
    await indexManager.rebuildIndex();
  }
  console.log(Formatter.header(`\u{1F4CB} ${config.name || "AI-Trackdown"} Project Backlog (Enhanced)`));
  const [epics, issues, tasks, prs] = await Promise.all([
    indexManager.getItemsByType("epic"),
    indexManager.getItemsByType("issue"),
    indexManager.getItemsByType("task"),
    indexManager.getItemsByType("pr")
  ]);
  const filteredData = applyBacklogFilters({ epics, issues, tasks, prs }, options);
  if (options.progress) {
    displayProgressSummary(filteredData);
  }
  if (options.hierarchy) {
    displayHierarchicalView(filteredData, options);
  } else {
    displayBacklogView(filteredData, options);
  }
  if (options.export) {
    await exportBacklog(filteredData, options.export);
  }
  const totalTime = Date.now() - startTime;
  console.log(Formatter.dim(`
\u26A1 Generated in ${totalTime}ms using index system`));
}
function applyBacklogFilters(data, options) {
  let { epics, issues, tasks, prs } = data;
  if (options.epic) {
    epics = epics.filter((epic) => epic.id === options.epic);
    issues = issues.filter((issue) => issue.epicId === options.epic);
    tasks = tasks.filter((task) => task.epicId === options.epic);
    prs = prs.filter((pr) => pr.epicId === options.epic);
  }
  if (options.status) {
    epics = epics.filter((epic) => epic.status === options.status);
    issues = issues.filter((issue) => issue.status === options.status);
    tasks = tasks.filter((task) => task.status === options.status);
    prs = prs.filter((pr) => pr.status === options.status);
  }
  if (options.priority) {
    epics = epics.filter((epic) => epic.priority === options.priority);
    issues = issues.filter((issue) => issue.priority === options.priority);
    tasks = tasks.filter((task) => task.priority === options.priority);
    prs = prs.filter((pr) => pr.priority === options.priority);
  }
  if (options.assignee) {
    epics = epics.filter((epic) => epic.assignee === options.assignee);
    issues = issues.filter((issue) => issue.assignee === options.assignee);
    tasks = tasks.filter((task) => task.assignee === options.assignee);
    prs = prs.filter((pr) => pr.assignee === options.assignee);
  }
  return { epics, issues, tasks, prs };
}
function displayProgressSummary(data) {
  const { epics, issues, tasks, prs } = data;
  const total = epics.length + issues.length + tasks.length + prs.length;
  if (total === 0) {
    console.log(Formatter.box("No items match the current filters", "info"));
    return;
  }
  console.log(Formatter.subheader("\u{1F4CA} Progress Summary"));
  const completedItems = [
    ...epics.filter((e) => e.status === "completed"),
    ...issues.filter((i) => i.status === "completed"),
    ...tasks.filter((t) => t.status === "completed"),
    ...prs.filter((p) => p.status === "completed")
  ].length;
  const completionRate = total > 0 ? Math.round(completedItems / total * 100) : 0;
  console.log(Formatter.info(`Total Items: ${total}`));
  console.log(Formatter.info(`Completed: ${completedItems} (${completionRate}%)`));
  console.log(Formatter.info(`In Progress: ${[...epics, ...issues, ...tasks, ...prs].filter((item) => item.status === "active").length}`));
  console.log(Formatter.info(`Planned: ${[...epics, ...issues, ...tasks, ...prs].filter((item) => item.status === "planning").length}`));
  console.log(Formatter.subheader("\n\u{1F4C8} Progress by Type"));
  displayTypeProgress("Epics", epics);
  displayTypeProgress("Issues", issues);
  displayTypeProgress("Tasks", tasks);
  displayTypeProgress("PRs", prs);
  console.log("");
}
function displayTypeProgress(typeName, items) {
  if (items.length === 0) return;
  const completed = items.filter((item) => item.status === "completed").length;
  const rate = Math.round(completed / items.length * 100);
  const progressBar = createProgressBar(rate);
  console.log(Formatter.info(`${typeName}: ${completed}/${items.length} ${progressBar} ${rate}%`));
}
function createProgressBar(percentage, width = 20) {
  const filled = Math.round(percentage / 100 * width);
  const empty = width - filled;
  return `[${"\u2588".repeat(filled)}${" ".repeat(empty)}]`;
}
function displayHierarchicalView(data, options) {
  const { epics, issues, tasks, prs } = data;
  console.log(Formatter.subheader("\u{1F333} Hierarchical Backlog View"));
  if (epics.length === 0) {
    console.log(Formatter.box("No epics match the current filters", "info"));
    return;
  }
  epics.forEach((epic) => {
    displayEpic2(epic, options);
    const epicIssues = issues.filter((issue) => issue.epicId === epic.id);
    epicIssues.forEach((issue, issueIndex) => {
      const isLastIssue = issueIndex === epicIssues.length - 1;
      displayIssue(issue, isLastIssue, options);
      const issueTasks = tasks.filter((task) => task.issueId === issue.id);
      const issuePRs = prs.filter((pr) => pr.issueId === issue.id);
      issueTasks.forEach((task, taskIndex) => {
        const isLastTask = taskIndex === issueTasks.length - 1 && issuePRs.length === 0;
        displayTask(task, isLastIssue, isLastTask, options);
      });
      issuePRs.forEach((pr, prIndex) => {
        const isLastPR = prIndex === issuePRs.length - 1;
        displayPR(pr, isLastIssue, isLastPR, options);
      });
    });
    console.log("");
  });
}
function displayBacklogView(data, options) {
  const { epics, issues, tasks, prs } = data;
  console.log(Formatter.subheader("\u{1F4CB} Backlog Overview"));
  const allItems = [...epics, ...issues, ...tasks, ...prs].map((item) => ({
    ...item,
    type: getItemType2(item.id)
  })).sort((a, b) => {
    const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
    const priorityDiff = priorityOrder[b.priority] - priorityOrder[a.priority];
    if (priorityDiff !== 0) return priorityDiff;
    return new Date(b.lastModified).getTime() - new Date(a.lastModified).getTime();
  });
  if (allItems.length === 0) {
    console.log(Formatter.box("No items match the current filters", "info"));
    return;
  }
  const grouped = allItems.reduce((acc, item) => {
    if (!acc[item.status]) acc[item.status] = [];
    acc[item.status].push(item);
    return acc;
  }, {});
  for (const [status, statusItems] of Object.entries(grouped)) {
    if (statusItems.length > 0) {
      const statusEmoji = getStatusEmoji2(status);
      console.log(Formatter.subheader(`${statusEmoji} ${status.toUpperCase()} (${statusItems.length})`));
      statusItems.forEach((item, index) => {
        displayBacklogItem(item, index, options);
      });
      console.log("");
    }
  }
}
function displayEpic2(epic, options) {
  var _a;
  const statusEmoji = getStatusEmoji2(epic.status);
  const priorityColor = getPriorityColor3(epic.priority);
  const completionInfo = epic.completion_percentage !== void 0 ? ` (${epic.completion_percentage}%)` : "";
  console.log(`\u{1F3AF} ${statusEmoji} ${priorityColor(epic.priority.toUpperCase())} ${Formatter.highlight(epic.title)}${completionInfo} ${Formatter.dim(`(${epic.id})`)}`);
  if (options.detailed) {
    console.log(`   Assignee: ${epic.assignee || "unassigned"}`);
    if (epic.milestone) console.log(`   Milestone: ${epic.milestone}`);
    if ((_a = epic.tags) == null ? void 0 : _a.length) console.log(`   Tags: ${epic.tags.join(", ")}`);
    console.log(`   Modified: ${new Date(epic.lastModified).toLocaleString()}`);
  }
}
function displayIssue(issue, isLast, options) {
  var _a;
  const prefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
  const statusEmoji = getStatusEmoji2(issue.status);
  const priorityColor = getPriorityColor3(issue.priority);
  console.log(`${prefix}\u{1F4CB} ${statusEmoji} ${priorityColor(issue.priority.toUpperCase())} ${issue.title} ${Formatter.dim(`(${issue.id})`)}`);
  if (options.detailed) {
    const indent = isLast ? "    " : "\u2502   ";
    console.log(`${indent}Assignee: ${issue.assignee || "unassigned"}`);
    if ((_a = issue.tags) == null ? void 0 : _a.length) console.log(`${indent}Tags: ${issue.tags.join(", ")}`);
    console.log(`${indent}Modified: ${new Date(issue.lastModified).toLocaleString()}`);
  }
}
function displayTask(task, issueIsLast, isLast, options) {
  var _a;
  const issuePrefix = issueIsLast ? "    " : "\u2502   ";
  const taskPrefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
  const statusEmoji = getStatusEmoji2(task.status);
  const priorityColor = getPriorityColor3(task.priority);
  console.log(`${issuePrefix}${taskPrefix}\u2705 ${statusEmoji} ${priorityColor(task.priority.toUpperCase())} ${task.title} ${Formatter.dim(`(${task.id})`)}`);
  if (options.detailed) {
    const indent = issuePrefix + (isLast ? "    " : "\u2502   ");
    console.log(`${indent}Assignee: ${task.assignee || "unassigned"}`);
    if (task.time_estimate) console.log(`${indent}Estimate: ${task.time_estimate}`);
    if ((_a = task.tags) == null ? void 0 : _a.length) console.log(`${indent}Tags: ${task.tags.join(", ")}`);
  }
}
function displayPR(pr, issueIsLast, isLast, options) {
  var _a;
  const issuePrefix = issueIsLast ? "    " : "\u2502   ";
  const prPrefix = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
  const statusEmoji = getStatusEmoji2(pr.status);
  const priorityColor = getPriorityColor3(pr.priority);
  console.log(`${issuePrefix}${prPrefix}\u{1F504} ${statusEmoji} ${priorityColor(pr.priority.toUpperCase())} ${pr.title} ${Formatter.dim(`(${pr.id})`)}`);
  if (options.detailed) {
    const indent = issuePrefix + (isLast ? "    " : "\u2502   ");
    console.log(`${indent}PR Status: ${pr.pr_status}`);
    if (pr.branch_name) console.log(`${indent}Branch: ${pr.branch_name}`);
    if ((_a = pr.reviewers) == null ? void 0 : _a.length) console.log(`${indent}Reviewers: ${pr.reviewers.join(", ")}`);
  }
}
function displayBacklogItem(item, index, options) {
  var _a;
  const typeEmoji = getTypeEmoji2(item.type);
  const statusEmoji = getStatusEmoji2(item.status);
  const priorityColor = getPriorityColor3(item.priority);
  const assigneeInfo = item.assignee ? ` @${item.assignee}` : "";
  const tagsInfo = ((_a = item.tags) == null ? void 0 : _a.length) ? ` [${item.tags.join(", ")}]` : "";
  console.log(
    `  ${(index + 1).toString().padStart(3, " ")}. ${typeEmoji} ${statusEmoji} ${priorityColor(item.priority.toUpperCase())} ${item.title}${assigneeInfo}${tagsInfo} ${Formatter.dim(`(${item.id})`)}`
  );
  if (options.detailed) {
    console.log(`      Modified: ${new Date(item.lastModified).toLocaleString()}`);
    if (item.type === "epic" && item.completion_percentage !== void 0) {
      console.log(`      Completion: ${item.completion_percentage}%`);
    }
    if (item.type === "pr" && item.pr_status) {
      console.log(`      PR Status: ${item.pr_status}`);
    }
  }
}
async function exportBacklog(data, filename) {
  const exportData = {
    exportTime: (/* @__PURE__ */ new Date()).toISOString(),
    summary: {
      totalEpics: data.epics.length,
      totalIssues: data.issues.length,
      totalTasks: data.tasks.length,
      totalPRs: data.prs.length
    },
    data
  };
  const fs32 = await import("fs");
  fs32.writeFileSync(filename, JSON.stringify(exportData, null, 2));
  console.log(Formatter.success(`Backlog exported to ${filename}`));
}
function getItemType2(id) {
  if (id.startsWith("EP-")) return "epic";
  if (id.startsWith("ISS-")) return "issue";
  if (id.startsWith("TSK-")) return "task";
  if (id.startsWith("PR-")) return "pr";
  return "unknown";
}
function getTypeEmoji2(type) {
  switch (type) {
    case "epic":
      return "\u{1F3AF}";
    case "issue":
      return "\u{1F4CB}";
    case "task":
      return "\u2705";
    case "pr":
      return "\u{1F504}";
    default:
      return "\u{1F4C4}";
  }
}
function getStatusEmoji2(status) {
  switch (status) {
    case "planning":
      return "\u{1F4DD}";
    case "active":
      return "\u{1F504}";
    case "completed":
      return "\u2705";
    case "archived":
      return "\u{1F4E6}";
    default:
      return "\u{1F4C4}";
  }
}
function getPriorityColor3(priority) {
  switch (priority) {
    case "low":
      return Formatter.dim;
    case "medium":
      return (text) => text;
    case "high":
      return Formatter.highlight;
    case "critical":
      return Formatter.error;
    default:
      return (text) => text;
  }
}
var import_commander6;
var init_backlog_enhanced = __esm({
  "src/commands/backlog-enhanced.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander6 = require("commander");
    init_config_manager();
    init_trackdown_index_manager();
    init_formatter();
    __name(createBacklogEnhancedCommand, "createBacklogEnhancedCommand");
    __name(displayEnhancedBacklog, "displayEnhancedBacklog");
    __name(applyBacklogFilters, "applyBacklogFilters");
    __name(displayProgressSummary, "displayProgressSummary");
    __name(displayTypeProgress, "displayTypeProgress");
    __name(createProgressBar, "createProgressBar");
    __name(displayHierarchicalView, "displayHierarchicalView");
    __name(displayBacklogView, "displayBacklogView");
    __name(displayEpic2, "displayEpic");
    __name(displayIssue, "displayIssue");
    __name(displayTask, "displayTask");
    __name(displayPR, "displayPR");
    __name(displayBacklogItem, "displayBacklogItem");
    __name(exportBacklog, "exportBacklog");
    __name(getItemType2, "getItemType");
    __name(getTypeEmoji2, "getTypeEmoji");
    __name(getStatusEmoji2, "getStatusEmoji");
    __name(getPriorityColor3, "getPriorityColor");
  }
});

// src/commands/portfolio.ts
function createPortfolioCommand() {
  const cmd = new import_commander7.Command("portfolio");
  cmd.description("Portfolio-wide status reporting across multiple ai-trackdown projects").option("--format <format>", "output format (table, json, markdown)", "table").option("--directory <path>", "root directory to scan for projects", ".").option("--health", "focus on project health monitoring").option("--summary", "show summary statistics only").action(async (options) => {
    try {
      await showPortfolio(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to show portfolio: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function showPortfolio(options) {
  console.log(Formatter.info("\u{1F3E2} AI-Trackdown Portfolio Status"));
  console.log("=".repeat(60));
  const scanDirectory = path7.resolve(options.directory || ".");
  const projects = await findAiTrackdownProjects(scanDirectory);
  if (projects.length === 0) {
    console.log(Formatter.warning("No AI-Trackdown projects found"));
    return;
  }
  const projectSummaries = [];
  for (const project of projects) {
    try {
      const summary = await analyzeProject(project);
      projectSummaries.push(summary);
    } catch (error) {
      projectSummaries.push({
        name: path7.basename(project),
        path: project,
        config: null,
        epics: 0,
        issues: 0,
        tasks: 0,
        status: "error",
        lastUpdated: "unknown"
      });
    }
  }
  if (options.format === "json") {
    console.log(JSON.stringify(projectSummaries, null, 2));
    return;
  }
  displayPortfolioSummary(projectSummaries, options);
}
async function findAiTrackdownProjects(rootDir) {
  const projects = [];
  function scanDir(dir, depth = 0) {
    if (depth > 3) return;
    try {
      const items = fs7.readdirSync(dir);
      if (items.includes(".ai-trackdown")) {
        projects.push(dir);
        return;
      }
      for (const item of items) {
        if (item.startsWith(".") && item !== ".ai-trackdown") continue;
        const itemPath = path7.join(dir, item);
        try {
          const stat3 = fs7.statSync(itemPath);
          if (stat3.isDirectory()) {
            scanDir(itemPath, depth + 1);
          }
        } catch (error) {
        }
      }
    } catch (error) {
    }
  }
  __name(scanDir, "scanDir");
  scanDir(rootDir);
  return projects;
}
async function analyzeProject(projectPath) {
  const configManager = new ConfigManager2(projectPath);
  const parser = new FrontmatterParser();
  let config = null;
  let status = "healthy";
  try {
    config = configManager.getConfig();
  } catch (error) {
    status = "error";
  }
  const paths = configManager.getAbsolutePaths();
  let epics = 0;
  let issues = 0;
  let tasks = 0;
  let lastUpdated = "never";
  try {
    const epicData = parser.parseDirectory(paths.epicsDir, "epic");
    epics = epicData.length;
    const issueData = parser.parseDirectory(paths.issuesDir, "issue");
    issues = issueData.length;
    const taskData = parser.parseDirectory(paths.tasksDir, "task");
    tasks = taskData.length;
    const allItems = [...epicData, ...issueData, ...taskData];
    if (allItems.length > 0) {
      const dates = allItems.map((item) => item.updated_date).filter((date) => date).sort().reverse();
      if (dates.length > 0) {
        lastUpdated = new Date(dates[0]).toLocaleDateString();
      }
    }
    if (epics === 0 && issues === 0 && tasks === 0) {
      status = "warning";
    }
  } catch (error) {
    status = "error";
  }
  return {
    name: (config == null ? void 0 : config.project_name) || path7.basename(projectPath),
    path: projectPath,
    config,
    epics,
    issues,
    tasks,
    status,
    lastUpdated
  };
}
function displayPortfolioSummary(projects, options) {
  console.log(Formatter.info(`\u{1F4CA} Found ${projects.length} AI-Trackdown project(s)`));
  console.log("");
  const totalEpics = projects.reduce((sum, p) => sum + p.epics, 0);
  const totalIssues = projects.reduce((sum, p) => sum + p.issues, 0);
  const totalTasks = projects.reduce((sum, p) => sum + p.tasks, 0);
  const healthyProjects = projects.filter((p) => p.status === "healthy").length;
  const warningProjects = projects.filter((p) => p.status === "warning").length;
  const errorProjects = projects.filter((p) => p.status === "error").length;
  console.log(Formatter.success(`\u{1F4C8} Portfolio Overview:`));
  console.log(Formatter.info(`   Total Items: ${totalEpics + totalIssues + totalTasks}`));
  console.log(Formatter.info(`   Epics: ${totalEpics} | Issues: ${totalIssues} | Tasks: ${totalTasks}`));
  console.log(Formatter.info(`   Health: ${healthyProjects} healthy, ${warningProjects} warnings, ${errorProjects} errors`));
  console.log("");
  if (options.summary) {
    return;
  }
  console.log(Formatter.success("\u{1F4CB} Project Details:"));
  console.log("");
  for (const project of projects) {
    const statusIcon = getStatusIcon2(project.status);
    const statusColor = getStatusColor(project.status);
    console.log(statusColor(`${statusIcon} ${project.name}`));
    console.log(Formatter.debug(`   Path: ${project.path}`));
    console.log(Formatter.debug(`   Items: ${project.epics} epics, ${project.issues} issues, ${project.tasks} tasks`));
    console.log(Formatter.debug(`   Last Updated: ${project.lastUpdated}`));
    if (options.health && project.status !== "healthy") {
      console.log(Formatter.warning(`   \u26A0\uFE0F  Status: ${project.status}`));
    }
    console.log("");
  }
}
function getStatusIcon2(status) {
  switch (status) {
    case "healthy":
      return "\u2705";
    case "warning":
      return "\u26A0\uFE0F";
    case "error":
      return "\u274C";
    default:
      return "\u2753";
  }
}
function getStatusColor(status) {
  switch (status) {
    case "healthy":
      return Formatter.success;
    case "warning":
      return Formatter.warning;
    case "error":
      return Formatter.error;
    default:
      return Formatter.info;
  }
}
var import_commander7, fs7, path7;
var init_portfolio = __esm({
  "src/commands/portfolio.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander7 = require("commander");
    fs7 = __toESM(require("fs"), 1);
    path7 = __toESM(require("path"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createPortfolioCommand, "createPortfolioCommand");
    __name(showPortfolio, "showPortfolio");
    __name(findAiTrackdownProjects, "findAiTrackdownProjects");
    __name(analyzeProject, "analyzeProject");
    __name(displayPortfolioSummary, "displayPortfolioSummary");
    __name(getStatusIcon2, "getStatusIcon");
    __name(getStatusColor, "getStatusColor");
  }
});

// src/commands/track.ts
function createTrackCommand() {
  const command = new import_commander8.Command("track");
  command.description("Track a new task or issue with advanced features").argument("<title>", "title of the task or issue").option("--priority <level>", "priority level (low, medium, high, critical)").option("--assignee <name>", "assign to team member").option("--tags <tags>", "comma-separated tags").option("--estimate <points>", "story point estimate").option("--description <text>", "detailed description").option("--id <id>", "custom ID for the item").option("--template <name>", "use specific template").option("--interactive", "interactive task creation mode").option("--duplicate-from <id>", "duplicate from existing task").option("--labels <labels>", "comma-separated labels").option("--due-date <date>", "due date (YYYY-MM-DD format)").addHelpText(
    "after",
    `
Examples:
  $ aitrackdown track "Implement user login"
  $ aitrackdown track "Fix critical bug" --priority critical --assignee john.doe
  $ aitrackdown track "Add API endpoint" --tags backend,api --estimate 5
  $ aitrackdown track "Design homepage" --interactive
  $ aitrackdown track "Update docs" --duplicate-from TD-123

Priority Levels:
  low       - Nice to have, non-urgent
  medium    - Standard priority (default)
  high      - Important, should be done soon
  critical  - Urgent, blocking other work

Story Points:
  1-2       - Quick fixes or small tasks
  3-5       - Standard features or moderate complexity
  8-13      - Large features or complex tasks
  21+       - Epic-sized work (consider breaking down)
`
  ).action(
    async (title, options) => {
      var _a, _b, _c;
      try {
        const parentCommand = command.parent;
        const rootDirOption = ((_a = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _a.rootDir) || ((_b = parentCommand == null ? void 0 : parentCommand.opts()) == null ? void 0 : _b.tasksDir);
        const configManager = new ConfigManager();
        const config = configManager.getConfig();
        const pathResolver = new PathResolver(configManager, rootDirOption);
        let taskData = {
          title,
          priority: (options == null ? void 0 : options.priority) || config.defaultPriority || "medium",
          assignee: options == null ? void 0 : options.assignee,
          tags: options == null ? void 0 : options.tags,
          estimate: options == null ? void 0 : options.estimate,
          description: options == null ? void 0 : options.description,
          id: options == null ? void 0 : options.id,
          template: (options == null ? void 0 : options.template) || config.defaultTemplate || "standard",
          labels: options == null ? void 0 : options.labels,
          dueDate: options == null ? void 0 : options.dueDate
        };
        if (options == null ? void 0 : options.interactive) {
          taskData = await runInteractiveTaskCreation(taskData, config);
        }
        if (options == null ? void 0 : options.duplicateFrom) {
          taskData = await duplicateTask(options.duplicateFrom, taskData);
        }
        const validatedTitle = validateRequired(taskData.title, "Title");
        const priority = validatePriority(taskData.priority);
        const tags = taskData.tags ? validateTags2(taskData.tags) : void 0;
        const labels = taskData.labels ? validateTags2(taskData.labels) : void 0;
        const assignee = taskData.assignee ? validateAssignee(taskData.assignee) : config.autoAssign ? config.defaultAssignee : void 0;
        const estimate = taskData.estimate ? validateStoryPoints(taskData.estimate) : void 0;
        const itemId = taskData.id ? validateId(taskData.id) : generateId();
        const spinner = (0, import_ora4.default)("Creating trackdown task...").start();
        try {
          const item = {
            id: itemId,
            title: validatedTitle,
            description: taskData.description,
            status: "todo",
            priority,
            assignee,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date(),
            tags,
            estimate,
            labels,
            metadata: {
              template: taskData.template,
              dueDate: taskData.dueDate,
              source: (options == null ? void 0 : options.duplicateFrom) ? "duplicate" : "new",
              createdBy: process.env.USER || "unknown"
            }
          };
          spinner.text = "Setting up task structure...";
          const activeDir = (0, import_node_path7.join)(process.cwd(), pathResolver.getActiveDir());
          if (!(0, import_node_fs7.existsSync)(activeDir)) {
            if (pathResolver.shouldMigrate()) {
              pathResolver.showMigrationWarning();
              console.log("\nMigration commands:");
              pathResolver.getMigrationCommands().forEach((cmd) => {
                console.log(Formatter.highlight(cmd));
              });
              process.exit(1);
            }
            (0, import_node_fs7.mkdirSync)(activeDir, { recursive: true });
          }
          const filename = `${itemId}-${sanitizeFilename(validatedTitle)}.md`;
          const filePath = (0, import_node_path7.join)(activeDir, filename);
          if ((0, import_node_fs7.existsSync)(filePath)) {
            throw new ValidationError(
              `Item with ID "${itemId}" already exists`,
              "Use a different ID with --id option",
              1,
              "track",
              ["--id TD-NEW-001", "--id feature-auth", "--id bug-fix-123"]
            );
          }
          spinner.text = "Generating task content...";
          const content = generateMarkdownContent(item, config);
          (0, import_node_fs7.writeFileSync)(filePath, content);
          spinner.succeed("Task created successfully!");
          console.log(
            Formatter.box(
              `
\u{1F3AF} Task "${validatedTitle}" tracked successfully!

ID: ${itemId}
Priority: ${priority.toUpperCase()}
${assignee ? `Assignee: ${assignee}` : ""}
${estimate ? `Estimate: ${estimate} story points` : ""}
${(tags == null ? void 0 : tags.length) ? `Tags: ${tags.join(", ")}` : ""}
Location: ${filePath}
`,
              "success"
            )
          );
          console.log(Formatter.header("Next Steps"));
          console.log(Formatter.info("\u2022 View task details:"));
          console.log(Formatter.highlight(`  trackdown status --filter id=${itemId}`));
          console.log(Formatter.info("\u2022 Edit the task file:"));
          console.log(Formatter.highlight(`  ${process.env.EDITOR || "nano"} "${filePath}"`));
          console.log(Formatter.info("\u2022 Check project status:"));
          console.log(Formatter.highlight("  trackdown status"));
          if (!assignee && !config.autoAssign) {
            console.log(Formatter.warning("\u{1F4A1} Consider assigning this task to someone"));
            console.log(
              Formatter.info("  Use: trackdown track --assignee <name> for future tasks")
            );
          }
          if (!estimate) {
            console.log(Formatter.info("\u{1F4A1} Add story points to help with planning"));
            console.log(Formatter.info("  Use: --estimate <points> (1-100 scale)"));
          }
        } catch (error) {
          spinner.fail("Task creation failed");
          throw error;
        }
      } catch (error) {
        if (error instanceof ValidationError) {
          console.error(Formatter.error(error.message));
          if (error.suggestion) {
            console.log(Formatter.info(`\u{1F4A1} ${error.suggestion}`));
          }
          if ((_c = error.validOptions) == null ? void 0 : _c.length) {
            console.log(Formatter.info("Valid options:"));
            error.validOptions.forEach((option) => {
              console.log(Formatter.highlight(`  ${option}`));
            });
          }
        } else {
          console.error(
            Formatter.error(
              `Failed to track task: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
        process.exit(1);
      }
    }
  );
  return command;
}
async function runInteractiveTaskCreation(taskData, config) {
  console.log(Formatter.header("\u{1F4DD} Interactive Task Creation"));
  const answers = await import_inquirer4.default.prompt([
    {
      type: "input",
      name: "title",
      message: "Task title:",
      default: taskData.title,
      validate: /* @__PURE__ */ __name((input) => {
        try {
          validateRequired(input, "Title");
          return true;
        } catch (error) {
          return error instanceof Error ? error.message : "Invalid title";
        }
      }, "validate")
    },
    {
      type: "editor",
      name: "description",
      message: "Task description (opens in editor):",
      default: taskData.description || "Add a detailed description of this task...",
      when: /* @__PURE__ */ __name(() => process.env.EDITOR !== void 0, "when")
    },
    {
      type: "input",
      name: "description",
      message: "Task description:",
      default: taskData.description,
      when: /* @__PURE__ */ __name(() => process.env.EDITOR === void 0, "when")
    },
    {
      type: "list",
      name: "priority",
      message: "Priority level:",
      choices: [
        { name: "\u{1F7E2} Low - Nice to have", value: "low" },
        { name: "\u{1F7E1} Medium - Standard priority", value: "medium" },
        { name: "\u{1F7E0} High - Important, urgent", value: "high" },
        { name: "\u{1F534} Critical - Blocking, emergency", value: "critical" }
      ],
      default: taskData.priority
    },
    {
      type: "input",
      name: "assignee",
      message: "Assignee (username or email):",
      default: taskData.assignee || config.defaultAssignee,
      validate: /* @__PURE__ */ __name((input) => {
        if (!input) return true;
        try {
          validateAssignee(input);
          return true;
        } catch (error) {
          return error instanceof Error ? error.message : "Invalid assignee";
        }
      }, "validate")
    },
    {
      type: "input",
      name: "estimate",
      message: "Story points (1-100):",
      default: taskData.estimate,
      validate: /* @__PURE__ */ __name((input) => {
        if (!input) return true;
        try {
          validateStoryPoints(input);
          return true;
        } catch (error) {
          return error instanceof Error ? error.message : "Invalid story points";
        }
      }, "validate")
    },
    {
      type: "input",
      name: "tags",
      message: "Tags (comma-separated):",
      default: taskData.tags,
      validate: /* @__PURE__ */ __name((input) => {
        if (!input) return true;
        try {
          validateTags2(input);
          return true;
        } catch (error) {
          return error instanceof Error ? error.message : "Invalid tags";
        }
      }, "validate")
    },
    {
      type: "input",
      name: "id",
      message: "Custom ID (leave blank for auto-generated):",
      default: taskData.id,
      validate: /* @__PURE__ */ __name((input) => {
        if (!input) return true;
        try {
          validateId(input);
          return true;
        } catch (error) {
          return error instanceof Error ? error.message : "Invalid ID";
        }
      }, "validate")
    }
  ]);
  return { ...taskData, ...answers };
}
async function duplicateTask(sourceId, taskData) {
  console.log(Formatter.info(`\u{1F504} Duplicating from task: ${sourceId}`));
  return {
    ...taskData,
    description: `${taskData.description || ""}

*Duplicated from task: ${sourceId}*`
  };
}
function generateId() {
  const timestamp = Date.now().toString(36);
  const random = Math.random().toString(36).substring(2, 7);
  return `TD-${timestamp}-${random}`.toUpperCase();
}
function sanitizeFilename(title) {
  return title.toLowerCase().replace(/[^a-z0-9\s-]/g, "").replace(/\s+/g, "-").substring(0, 50);
}
function generateMarkdownContent(item, config) {
  var _a, _b, _c, _d, _e, _f, _g;
  const tagsSection = ((_a = item.tags) == null ? void 0 : _a.length) ? `
**Tags**: ${item.tags.map((tag) => `\`${tag}\``).join(", ")}` : "";
  const labelsSection = ((_b = item.labels) == null ? void 0 : _b.length) ? `
**Labels**: ${item.labels.map((label) => `\`${label}\``).join(", ")}` : "";
  const estimateSection = item.estimate ? `
**Story Points**: ${item.estimate}` : "";
  const dueDateSection = ((_c = item.metadata) == null ? void 0 : _c.dueDate) ? `
**Due Date**: ${item.metadata.dueDate}` : "";
  const metadataSection = `
## Metadata

- **Template**: ${((_d = item.metadata) == null ? void 0 : _d.template) || "standard"}
- **Created By**: ${((_e = item.metadata) == null ? void 0 : _e.createdBy) || "unknown"}
- **Source**: ${((_f = item.metadata) == null ? void 0 : _f.source) || "new"}
${((_g = item.metadata) == null ? void 0 : _g.dueDate) ? `- **Due Date**: ${item.metadata.dueDate}` : ""}
`;
  return `# ${item.title}

**ID**: ${item.id}
**Status**: ${item.status}
**Priority**: ${item.priority}
**Assignee**: ${item.assignee || "Unassigned"}
**Created**: ${item.createdAt.toISOString()}
**Updated**: ${item.updatedAt.toISOString()}${estimateSection}${tagsSection}${labelsSection}${dueDateSection}

## Description

${item.description || "No description provided."}

## Acceptance Criteria

- [ ] Define specific and measurable acceptance criteria
- [ ] Ensure criteria are testable and verifiable
- [ ] Add more criteria as needed

## Implementation Notes

<!-- Add technical details, approach, or constraints here -->

## Dependencies

<!-- List any dependencies on other tasks or external factors -->

## Progress Log

- ${item.createdAt.toISOString().split("T")[0]}: Task created

## Resources

<!-- Add links, references, documentation, or related materials here -->

${metadataSection}

---

*Generated by ai-trackdown-tools v1.0.0*
`;
}
var import_node_fs7, import_node_path7, import_commander8, import_inquirer4, import_ora4;
var init_track = __esm({
  "src/commands/track.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_fs7 = require("fs");
    import_node_path7 = require("path");
    import_commander8 = require("commander");
    import_inquirer4 = __toESM(require("inquirer"), 1);
    import_ora4 = __toESM(require("ora"), 1);
    init_config();
    init_path_resolver();
    init_formatter();
    init_validation();
    __name(createTrackCommand, "createTrackCommand");
    __name(runInteractiveTaskCreation, "runInteractiveTaskCreation");
    __name(duplicateTask, "duplicateTask");
    __name(generateId, "generateId");
    __name(sanitizeFilename, "sanitizeFilename");
    __name(generateMarkdownContent, "generateMarkdownContent");
  }
});

// src/utils/version.ts
var import_fs, import_path, import_semver, _VersionManager, VersionManager;
var init_version = __esm({
  "src/utils/version.ts"() {
    "use strict";
    init_cjs_shims();
    import_fs = __toESM(require("fs"), 1);
    import_path = __toESM(require("path"), 1);
    import_semver = __toESM(require("semver"), 1);
    _VersionManager = class _VersionManager {
      /**
       * Get the project root directory
       */
      static getProjectRoot() {
        let cliRoot = __dirname;
        while (cliRoot !== import_path.default.dirname(cliRoot)) {
          const packageJsonPath = import_path.default.join(cliRoot, "package.json");
          if (import_fs.default.existsSync(packageJsonPath)) {
            try {
              const packageJson = JSON.parse(import_fs.default.readFileSync(packageJsonPath, "utf8"));
              if (packageJson.name === "@bobmatnyc/ai-trackdown-tools") {
                return cliRoot;
              }
            } catch (error) {
            }
          }
          cliRoot = import_path.default.dirname(cliRoot);
        }
        let current = process.cwd();
        while (current !== import_path.default.dirname(current)) {
          if (import_fs.default.existsSync(import_path.default.join(current, "package.json"))) {
            return current;
          }
          current = import_path.default.dirname(current);
        }
        throw new Error("Could not find project root (no package.json found)");
      }
      /**
       * Read version from VERSION file, with package.json fallback
       */
      static getVersion() {
        const projectRoot = this.getProjectRoot();
        const versionFile = import_path.default.join(projectRoot, this.VERSION_FILE);
        let versionString;
        if (import_fs.default.existsSync(versionFile)) {
          versionString = import_fs.default.readFileSync(versionFile, "utf8").trim();
        } else {
          const packageJsonPath = import_path.default.join(projectRoot, this.PACKAGE_JSON);
          if (import_fs.default.existsSync(packageJsonPath)) {
            const packageJson = JSON.parse(import_fs.default.readFileSync(packageJsonPath, "utf8"));
            versionString = packageJson.version;
          } else {
            throw new Error("Neither VERSION file nor package.json found");
          }
        }
        if (!import_semver.default.valid(versionString)) {
          throw new Error(`Invalid version format: ${versionString}`);
        }
        const parsed = import_semver.default.parse(versionString);
        if (!parsed) {
          throw new Error(`Could not parse version: ${versionString}`);
        }
        return {
          version: versionString,
          major: parsed.major,
          minor: parsed.minor,
          patch: parsed.patch
        };
      }
      /**
       * Set version in VERSION file
       */
      static setVersion(version) {
        if (!import_semver.default.valid(version)) {
          throw new Error(`Invalid version format: ${version}`);
        }
        const projectRoot = this.getProjectRoot();
        const versionFile = import_path.default.join(projectRoot, this.VERSION_FILE);
        import_fs.default.writeFileSync(versionFile, version);
      }
      /**
       * Bump version according to semver rules
       */
      static bumpVersion(type) {
        const currentVersion = this.getVersion();
        const newVersion = import_semver.default.inc(currentVersion.version, type);
        if (!newVersion) {
          throw new Error(`Could not increment version: ${currentVersion.version}`);
        }
        this.setVersion(newVersion);
        return this.getVersion();
      }
      /**
       * Sync version across all files
       */
      static syncVersion() {
        const versionInfo = this.getVersion();
        const projectRoot = this.getProjectRoot();
        this.updatePackageJsonVersion(projectRoot, versionInfo.version);
      }
      /**
       * Update package.json version
       */
      static updatePackageJsonVersion(projectRoot, version) {
        const packageJsonPath = import_path.default.join(projectRoot, this.PACKAGE_JSON);
        if (!import_fs.default.existsSync(packageJsonPath)) {
          throw new Error("package.json not found");
        }
        const packageJson = JSON.parse(import_fs.default.readFileSync(packageJsonPath, "utf8"));
        packageJson.version = version;
        import_fs.default.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");
      }
      /**
       * Validate version consistency across files
       */
      static validateVersionConsistency() {
        const projectRoot = this.getProjectRoot();
        const versionInfo = this.getVersion();
        const versions = {
          VERSION: versionInfo.version
        };
        const packageJsonPath = import_path.default.join(projectRoot, this.PACKAGE_JSON);
        if (import_fs.default.existsSync(packageJsonPath)) {
          const packageJson = JSON.parse(import_fs.default.readFileSync(packageJsonPath, "utf8"));
          versions["package.json"] = packageJson.version;
        }
        const allVersions = Object.values(versions);
        const consistent = allVersions.every((v) => v === versionInfo.version);
        return { consistent, versions };
      }
    };
    __name(_VersionManager, "VersionManager");
    __publicField(_VersionManager, "VERSION_FILE", "VERSION");
    __publicField(_VersionManager, "PACKAGE_JSON", "package.json");
    VersionManager = _VersionManager;
  }
});

// src/commands/version/show.ts
function createShowCommand() {
  const command = new import_commander9.Command("show");
  command.description("Display current version information").option("--json", "output as JSON").option("--check-consistency", "check version consistency across files").action(async (options) => {
    try {
      const versionInfo = VersionManager.getVersion();
      if (options.json) {
        if (options.checkConsistency) {
          const consistency = VersionManager.validateVersionConsistency();
          console.log(
            JSON.stringify(
              {
                ...versionInfo,
                consistency
              },
              null,
              2
            )
          );
        } else {
          console.log(JSON.stringify(versionInfo, null, 2));
        }
        return;
      }
      console.log(Formatter.success(`\u{1F4E6} AI Trackdown CLI v${versionInfo.version}`));
      console.log(Formatter.info(`   Major: ${versionInfo.major}`));
      console.log(Formatter.info(`   Minor: ${versionInfo.minor}`));
      console.log(Formatter.info(`   Patch: ${versionInfo.patch}`));
      if (options.checkConsistency) {
        console.log("");
        const consistency = VersionManager.validateVersionConsistency();
        if (consistency.consistent) {
          console.log(Formatter.success("\u2705 Version consistency check passed"));
        } else {
          console.log(Formatter.error("\u274C Version inconsistency detected:"));
          for (const [file, version] of Object.entries(consistency.versions)) {
            const status = version === versionInfo.version ? "\u2705" : "\u274C";
            console.log(Formatter.info(`   ${file}: ${version} ${status}`));
          }
        }
      }
    } catch (error) {
      console.error(
        Formatter.error(
          `Failed to get version: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
      process.exit(1);
    }
  });
  return command;
}
var import_commander9;
var init_show = __esm({
  "src/commands/version/show.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander9 = require("commander");
    init_version();
    init_formatter();
    __name(createShowCommand, "createShowCommand");
  }
});

// src/utils/changelog.ts
var import_node_fs8, import_node_path8, import_node_child_process, _ChangelogManager, ChangelogManager;
var init_changelog = __esm({
  "src/utils/changelog.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_fs8 = __toESM(require("fs"), 1);
    import_node_path8 = __toESM(require("path"), 1);
    import_node_child_process = require("child_process");
    init_version();
    _ChangelogManager = class _ChangelogManager {
      /**
       * Get the project root directory
       */
      static getProjectRoot() {
        let current = process.cwd();
        while (current !== import_node_path8.default.dirname(current)) {
          if (import_node_fs8.default.existsSync(import_node_path8.default.join(current, "package.json"))) {
            return current;
          }
          current = import_node_path8.default.dirname(current);
        }
        throw new Error("Could not find project root (no package.json found)");
      }
      /**
       * Parse conventional commits from git log
       */
      static parseCommits(since) {
        const projectRoot = this.getProjectRoot();
        try {
          const sinceFlag = since ? `--since="${since}"` : "";
          const gitLog = (0, import_node_child_process.execSync)(`git log --pretty=format:"%H|%s|%b" --no-merges ${sinceFlag}`, {
            cwd: projectRoot,
            encoding: "utf8"
          });
          if (!gitLog.trim()) {
            return [];
          }
          return gitLog.split("\n").filter((line) => line.trim()).map((line) => {
            const [hash, subject, body] = line.split("|");
            return this.parseConventionalCommit(hash, subject, body || "");
          }).filter((commit) => commit !== null);
        } catch (error) {
          console.warn("Warning: Could not parse git commits. Make sure you are in a git repository.");
          return [];
        }
      }
      /**
       * Parse a single conventional commit
       */
      static parseConventionalCommit(hash, subject, body) {
        const conventionalPattern = /^(\w+)(\([^)]+\))?!?:\s*(.+)$/;
        const match = subject.match(conventionalPattern);
        if (!match) {
          return {
            type: "other",
            description: subject,
            body,
            breaking: subject.includes("BREAKING") || body.includes("BREAKING CHANGE"),
            hash: hash.substring(0, 7)
          };
        }
        const [, type, scopeMatch, description] = match;
        const scope = scopeMatch ? scopeMatch.slice(1, -1) : void 0;
        const breaking = subject.includes("!") || body.includes("BREAKING CHANGE");
        return {
          type,
          scope,
          description,
          body,
          breaking,
          hash: hash.substring(0, 7)
        };
      }
      /**
       * Categorize commits into changelog sections
       */
      static categorizeCommits(commits) {
        const sections = {
          added: [],
          changed: [],
          deprecated: [],
          removed: [],
          fixed: [],
          security: []
        };
        for (const commit of commits) {
          const entry = commit.scope ? `**${commit.scope}**: ${commit.description} (${commit.hash})` : `${commit.description} (${commit.hash})`;
          switch (commit.type) {
            case "feat":
              sections.added.push(entry);
              break;
            case "fix":
              sections.fixed.push(entry);
              break;
            case "perf":
              sections.changed.push(entry);
              break;
            case "refactor":
              sections.changed.push(entry);
              break;
            case "docs":
              sections.changed.push(entry);
              break;
            case "style":
              sections.changed.push(entry);
              break;
            case "test":
              sections.changed.push(entry);
              break;
            case "chore":
              sections.changed.push(entry);
              break;
            case "security":
              sections.security.push(entry);
              break;
            default:
              if (commit.breaking) {
                sections.changed.push(entry);
              } else {
                sections.changed.push(entry);
              }
          }
          if (commit.breaking) {
            const breakingEntry = `**BREAKING**: ${commit.description} (${commit.hash})`;
            if (!sections.changed.includes(breakingEntry)) {
              sections.changed.unshift(breakingEntry);
            }
          }
        }
        return sections;
      }
      /**
       * Generate changelog entry for current version
       */
      static generateChangelogEntry(version, since) {
        const currentVersion = version || VersionManager.getVersion().version;
        const commits = this.parseCommits(since);
        const sections = this.categorizeCommits(commits);
        return {
          version: currentVersion,
          date: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
          sections
        };
      }
      /**
       * Format changelog entry as markdown
       */
      static formatChangelogEntry(entry) {
        const lines = [];
        lines.push(`## [${entry.version}] - ${entry.date}`);
        lines.push("");
        const sectionNames = {
          added: "Added",
          changed: "Changed",
          deprecated: "Deprecated",
          removed: "Removed",
          fixed: "Fixed",
          security: "Security"
        };
        for (const [key, title] of Object.entries(sectionNames)) {
          const items = entry.sections[key];
          if (items.length > 0) {
            lines.push(`### ${title}`);
            for (const item of items) {
              lines.push(`- ${item}`);
            }
            lines.push("");
          }
        }
        return lines.join("\n");
      }
      /**
       * Generate or update CHANGELOG.md
       */
      static generateChangelog(version, since) {
        const projectRoot = this.getProjectRoot();
        const changelogPath = import_node_path8.default.join(projectRoot, this.CHANGELOG_FILE);
        const entry = this.generateChangelogEntry(version, since);
        const entryMarkdown = this.formatChangelogEntry(entry);
        let changelogContent = "";
        if (import_node_fs8.default.existsSync(changelogPath)) {
          const existingContent = import_node_fs8.default.readFileSync(changelogPath, "utf8");
          const headerEndIndex = existingContent.indexOf("\n## ");
          if (headerEndIndex !== -1) {
            const header = existingContent.substring(0, headerEndIndex + 1);
            const rest = existingContent.substring(headerEndIndex + 1);
            changelogContent = header + entryMarkdown + "\n" + rest;
          } else {
            changelogContent = existingContent + "\n" + entryMarkdown;
          }
        } else {
          changelogContent = this.createChangelogHeader() + entryMarkdown;
        }
        import_node_fs8.default.writeFileSync(changelogPath, changelogContent);
      }
      /**
       * Create changelog header
       */
      static createChangelogHeader() {
        return `# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

`;
      }
      /**
       * Get the latest version from CHANGELOG.md
       */
      static getLatestChangelogVersion() {
        const projectRoot = this.getProjectRoot();
        const changelogPath = import_node_path8.default.join(projectRoot, this.CHANGELOG_FILE);
        if (!import_node_fs8.default.existsSync(changelogPath)) {
          return null;
        }
        const content = import_node_fs8.default.readFileSync(changelogPath, "utf8");
        const versionMatch = content.match(/## \[([^\]]+)\]/);
        return versionMatch ? versionMatch[1] : null;
      }
    };
    __name(_ChangelogManager, "ChangelogManager");
    __publicField(_ChangelogManager, "CHANGELOG_FILE", "CHANGELOG.md");
    ChangelogManager = _ChangelogManager;
  }
});

// src/utils/git.ts
var import_node_child_process2, import_node_fs9, import_node_path9, _GitManager, GitManager;
var init_git = __esm({
  "src/utils/git.ts"() {
    "use strict";
    init_cjs_shims();
    import_node_child_process2 = require("child_process");
    import_node_fs9 = __toESM(require("fs"), 1);
    import_node_path9 = __toESM(require("path"), 1);
    _GitManager = class _GitManager {
      /**
       * Get the project root directory
       */
      static getProjectRoot() {
        let current = process.cwd();
        while (current !== import_node_path9.default.dirname(current)) {
          if (import_node_fs9.default.existsSync(import_node_path9.default.join(current, ".git"))) {
            return current;
          }
          current = import_node_path9.default.dirname(current);
        }
        throw new Error("Not in a git repository");
      }
      /**
       * Check if we're in a git repository
       */
      static isGitRepository() {
        try {
          (0, import_node_child_process2.execSync)("git rev-parse --git-dir", { stdio: "ignore" });
          return true;
        } catch {
          return false;
        }
      }
      /**
       * Check if there are uncommitted changes
       */
      static hasUncommittedChanges() {
        try {
          const output = (0, import_node_child_process2.execSync)("git status --porcelain", { encoding: "utf8" });
          return output.trim().length > 0;
        } catch {
          return false;
        }
      }
      /**
       * Get the current branch name
       */
      static getCurrentBranch() {
        try {
          return (0, import_node_child_process2.execSync)("git branch --show-current", { encoding: "utf8" }).trim();
        } catch {
          throw new Error("Could not determine current branch");
        }
      }
      /**
       * Create a git tag
       */
      static createTag(version, message) {
        if (!this.isGitRepository()) {
          throw new Error("Not in a git repository");
        }
        const tagName = `v${version}`;
        const tagMessage = message || `Release version ${version}`;
        try {
          (0, import_node_child_process2.execSync)(`git tag -l ${tagName}`, { stdio: "ignore" });
          throw new Error(`Tag ${tagName} already exists`);
        } catch (error) {
        }
        try {
          (0, import_node_child_process2.execSync)(`git tag -a ${tagName} -m "${tagMessage}"`);
        } catch (error) {
          throw new Error(`Failed to create tag: ${error}`);
        }
      }
      /**
       * Push tags to remote
       */
      static pushTags() {
        if (!this.isGitRepository()) {
          throw new Error("Not in a git repository");
        }
        try {
          (0, import_node_child_process2.execSync)("git push --tags");
        } catch (error) {
          throw new Error(`Failed to push tags: ${error}`);
        }
      }
      /**
       * Get list of existing tags
       */
      static getTags() {
        if (!this.isGitRepository()) {
          return [];
        }
        try {
          const output = (0, import_node_child_process2.execSync)("git tag -l", { encoding: "utf8" });
          return output.trim().split("\n").filter((tag) => tag.trim());
        } catch {
          return [];
        }
      }
      /**
       * Get the last tag
       */
      static getLastTag() {
        if (!this.isGitRepository()) {
          return null;
        }
        try {
          const output = (0, import_node_child_process2.execSync)("git describe --tags --abbrev=0", { encoding: "utf8" });
          return output.trim();
        } catch {
          return null;
        }
      }
      /**
       * Commit changes with a message
       */
      static commit(message, files) {
        if (!this.isGitRepository()) {
          throw new Error("Not in a git repository");
        }
        try {
          if (files && files.length > 0) {
            for (const file of files) {
              (0, import_node_child_process2.execSync)(`git add "${file}"`);
            }
          }
          (0, import_node_child_process2.execSync)(`git commit -m "${message}"`);
        } catch (error) {
          throw new Error(`Failed to commit changes: ${error}`);
        }
      }
      /**
       * Get commits since a specific tag or commit
       */
      static getCommitsSince(since) {
        if (!this.isGitRepository()) {
          return [];
        }
        try {
          const output = (0, import_node_child_process2.execSync)(`git log ${since}..HEAD --oneline`, { encoding: "utf8" });
          return output.trim().split("\n").filter((line) => line.trim());
        } catch {
          return [];
        }
      }
      /**
       * Check if a tag exists
       */
      static tagExists(tag) {
        if (!this.isGitRepository()) {
          return false;
        }
        try {
          (0, import_node_child_process2.execSync)(`git tag -l ${tag}`, { stdio: "ignore" });
          return true;
        } catch {
          return false;
        }
      }
      /**
       * Get repository URL
       */
      static getRepositoryUrl() {
        if (!this.isGitRepository()) {
          return null;
        }
        try {
          const output = (0, import_node_child_process2.execSync)("git config --get remote.origin.url", { encoding: "utf8" });
          return output.trim();
        } catch {
          return null;
        }
      }
    };
    __name(_GitManager, "GitManager");
    GitManager = _GitManager;
  }
});

// src/commands/version/bump.ts
function createBumpCommand() {
  const command = new import_commander10.Command("bump");
  command.description("Bump version following semantic versioning").argument("<type>", "version bump type (major, minor, patch)").option("--no-changelog", "skip changelog generation").option("--no-commit", "skip git commit").option("--dry-run", "show what would be done without making changes").option("--message <msg>", "custom commit message").action(async (type, options) => {
    try {
      if (!["major", "minor", "patch"].includes(type)) {
        console.error(Formatter.error("Invalid bump type. Must be: major, minor, or patch"));
        process.exit(1);
      }
      const currentVersion = VersionManager.getVersion();
      if (GitManager.isGitRepository() && GitManager.hasUncommittedChanges() && !options.noCommit) {
        console.error(
          Formatter.error("Uncommitted changes detected. Please commit or stash changes first.")
        );
        process.exit(1);
      }
      if (options.dryRun) {
        console.log(Formatter.info("\u{1F50D} Dry run mode - no changes will be made"));
        const semver2 = await import("semver");
        const newVersion2 = semver2.inc(currentVersion.version, type);
        console.log(Formatter.info(`\u{1F4E6} Current version: ${currentVersion.version}`));
        console.log(Formatter.info(`\u{1F680} New version: ${newVersion2}`));
        if (!options.noChangelog) {
          console.log(Formatter.info("\u{1F4DD} Would generate changelog entry"));
        }
        if (!options.noCommit && GitManager.isGitRepository()) {
          console.log(Formatter.info("\u{1F4DD} Would commit changes to git"));
        }
        return;
      }
      console.log(Formatter.info(`\u{1F4E6} Bumping version from ${currentVersion.version}...`));
      const lastTag = GitManager.getLastTag();
      const newVersion = VersionManager.bumpVersion(type);
      console.log(Formatter.success(`\u{1F680} Version bumped to ${newVersion.version}`));
      VersionManager.syncVersion();
      console.log(Formatter.success("\u{1F504} Version synchronized across all files"));
      if (!options.noChangelog) {
        const since = lastTag || void 0;
        ChangelogManager.generateChangelog(newVersion.version, since);
        console.log(Formatter.success("\u{1F4DD} Changelog updated"));
      }
      if (!options.noCommit && GitManager.isGitRepository()) {
        const commitMessage = options.message || `chore: bump version to ${newVersion.version}`;
        const filesToCommit = ["VERSION", "package.json"];
        if (!options.noChangelog) {
          filesToCommit.push("CHANGELOG.md");
        }
        GitManager.commit(commitMessage, filesToCommit);
        console.log(Formatter.success(`\u{1F4DD} Changes committed: ${commitMessage}`));
      }
      console.log("");
      console.log(Formatter.success(`\u2705 Version bump complete!`));
      console.log(Formatter.info(`   Previous: ${currentVersion.version}`));
      console.log(Formatter.info(`   Current:  ${newVersion.version}`));
      if (GitManager.isGitRepository()) {
        console.log("");
        console.log(Formatter.info("\u{1F4A1} Next steps:"));
        console.log(Formatter.info("   - Review the changes"));
        console.log(Formatter.info(`   - Create a release tag: trackdown version tag`));
        console.log(
          Formatter.info(`   - Push changes: git push origin ${GitManager.getCurrentBranch()}`)
        );
      }
    } catch (error) {
      console.error(
        Formatter.error(
          `Failed to bump version: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
      process.exit(1);
    }
  });
  return command;
}
var import_commander10;
var init_bump = __esm({
  "src/commands/version/bump.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander10 = require("commander");
    init_version();
    init_changelog();
    init_git();
    init_formatter();
    __name(createBumpCommand, "createBumpCommand");
  }
});

// src/commands/version/changelog.ts
function createChangelogCommand() {
  const command = new import_commander11.Command("changelog");
  command.description("Generate or update CHANGELOG.md").option(
    "--since <ref>",
    "generate changelog since a specific git reference (tag, commit, etc.)"
  ).option("--version <version>", "specify version for the changelog entry").option("--dry-run", "show what would be generated without writing to file").option("--format <format>", "output format (markdown, json)", "markdown").action(async (options) => {
    try {
      if (!GitManager.isGitRepository()) {
        console.warn(
          Formatter.warning("Not in a git repository. Changelog generation may be limited.")
        );
      }
      const version = options.version || VersionManager.getVersion().version;
      const since = options.since || GitManager.getLastTag() || void 0;
      console.log(Formatter.info(`\u{1F4DD} Generating changelog for version ${version}...`));
      if (since) {
        console.log(Formatter.info(`\u{1F4C5} Including changes since: ${since}`));
      }
      const entry = ChangelogManager.generateChangelogEntry(version, since);
      if (options.format === "json") {
        if (options.dryRun) {
          console.log("\u{1F4C4} Generated changelog entry (JSON):");
          console.log(JSON.stringify(entry, null, 2));
        } else {
          console.log(JSON.stringify(entry, null, 2));
        }
        return;
      }
      const markdown = ChangelogManager.formatChangelogEntry(entry);
      if (options.dryRun) {
        console.log("\u{1F4C4} Generated changelog entry:");
        console.log("");
        console.log(markdown);
        return;
      }
      ChangelogManager.generateChangelog(version, since);
      console.log(Formatter.success("\u2705 CHANGELOG.md updated successfully!"));
      const totalChanges = Object.values(entry.sections).reduce(
        (sum, items) => sum + items.length,
        0
      );
      console.log(Formatter.info(`\u{1F4CA} Summary:`));
      console.log(Formatter.info(`   - Version: ${entry.version}`));
      console.log(Formatter.info(`   - Date: ${entry.date}`));
      console.log(Formatter.info(`   - Total changes: ${totalChanges}`));
      const sectionNames = {
        added: "Added",
        changed: "Changed",
        deprecated: "Deprecated",
        removed: "Removed",
        fixed: "Fixed",
        security: "Security"
      };
      for (const [key, name] of Object.entries(sectionNames)) {
        const count = entry.sections[key].length;
        if (count > 0) {
          console.log(Formatter.info(`   - ${name}: ${count} items`));
        }
      }
      console.log("");
      console.log(Formatter.info("\u{1F4A1} Tip: Review CHANGELOG.md and edit manually if needed"));
    } catch (error) {
      console.error(
        Formatter.error(
          `Failed to generate changelog: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
      process.exit(1);
    }
  });
  return command;
}
var import_commander11;
var init_changelog2 = __esm({
  "src/commands/version/changelog.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander11 = require("commander");
    init_changelog();
    init_version();
    init_git();
    init_formatter();
    __name(createChangelogCommand, "createChangelogCommand");
  }
});

// src/commands/version/tag.ts
function createTagCommand() {
  const command = new import_commander12.Command("tag");
  command.description("Create a git tag for the current version").option("--push", "push the tag to remote repository").option("--message <msg>", "custom tag message").option("--dry-run", "show what would be done without creating the tag").option("--force", "force create tag even if it exists").action(async (options) => {
    try {
      if (!GitManager.isGitRepository()) {
        console.error(Formatter.error("Not in a git repository. Cannot create tags."));
        process.exit(1);
      }
      const versionInfo = VersionManager.getVersion();
      const tagName = `v${versionInfo.version}`;
      const tagMessage = options.message || `Release version ${versionInfo.version}`;
      console.log(Formatter.info(`\u{1F3F7}\uFE0F  Creating tag ${tagName}...`));
      if (GitManager.tagExists(tagName) && !options.force) {
        console.error(
          Formatter.error(`Tag ${tagName} already exists. Use --force to recreate it.`)
        );
        process.exit(1);
      }
      if (GitManager.hasUncommittedChanges()) {
        console.warn(Formatter.warning("\u26A0\uFE0F  Warning: You have uncommitted changes."));
        console.log(Formatter.info("Consider committing changes before creating a release tag."));
      }
      if (options.dryRun) {
        console.log(Formatter.info("\u{1F50D} Dry run mode - no tag will be created"));
        console.log(Formatter.info(`Tag name: ${tagName}`));
        console.log(Formatter.info(`Tag message: ${tagMessage}`));
        if (options.push) {
          console.log(Formatter.info("Would push tag to remote repository"));
        }
        return;
      }
      try {
        GitManager.createTag(versionInfo.version, tagMessage);
        console.log(Formatter.success(`\u2705 Tag ${tagName} created successfully!`));
      } catch (error) {
        if (options.force && error instanceof Error && error.message.includes("already exists")) {
          console.log(Formatter.warning(`\u{1F504} Recreating existing tag ${tagName}...`));
          try {
            (0, import_child_process.execSync)(`git tag -d ${tagName}`, { stdio: "ignore" });
            GitManager.createTag(versionInfo.version, tagMessage);
            console.log(Formatter.success(`\u2705 Tag ${tagName} recreated successfully!`));
          } catch (recreateError) {
            throw new Error(`Failed to recreate tag: ${recreateError}`);
          }
        } else {
          throw error;
        }
      }
      if (options.push) {
        console.log(Formatter.info("\u{1F4E4} Pushing tag to remote repository..."));
        try {
          GitManager.pushTags();
          console.log(Formatter.success("\u2705 Tag pushed successfully!"));
        } catch (error) {
          console.error(
            Formatter.error(
              `Failed to push tag: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
          console.log(
            Formatter.info(`\u{1F4A1} You can push manually later with: git push origin ${tagName}`)
          );
        }
      }
      console.log("");
      console.log(Formatter.success("\u{1F389} Tag created successfully!"));
      console.log(Formatter.info(`   Tag: ${tagName}`));
      console.log(Formatter.info(`   Message: ${tagMessage}`));
      console.log(Formatter.info(`   Branch: ${GitManager.getCurrentBranch()}`));
      if (!options.push) {
        console.log("");
        console.log(Formatter.info("\u{1F4A1} Next steps:"));
        console.log(Formatter.info(`   - Push the tag: git push origin ${tagName}`));
        console.log(Formatter.info("   - Create a GitHub release from this tag"));
      }
      const allTags = GitManager.getTags();
      if (allTags.length > 1) {
        console.log("");
        console.log(Formatter.info("\u{1F4CB} All tags:"));
        allTags.slice(-5).forEach((tag) => {
          const indicator = tag === tagName ? " \u2190 current" : "";
          console.log(Formatter.info(`   ${tag}${indicator}`));
        });
        if (allTags.length > 5) {
          console.log(Formatter.info(`   ... and ${allTags.length - 5} more`));
        }
      }
    } catch (error) {
      console.error(
        Formatter.error(
          `Failed to create tag: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
      process.exit(1);
    }
  });
  return command;
}
var import_commander12, import_child_process;
var init_tag = __esm({
  "src/commands/version/tag.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander12 = require("commander");
    import_child_process = require("child_process");
    init_version();
    init_git();
    init_formatter();
    __name(createTagCommand, "createTagCommand");
  }
});

// src/commands/version/sync.ts
function createSyncCommand() {
  const command = new import_commander13.Command("sync");
  command.description("Synchronize version across all files").option("--check-only", "only check consistency without making changes").option("--verbose", "show detailed information about each file").action(async (options) => {
    try {
      console.log(Formatter.info("\u{1F504} Checking version consistency..."));
      const consistency = VersionManager.validateVersionConsistency();
      const versionInfo = VersionManager.getVersion();
      if (options.verbose || options.checkOnly) {
        console.log(Formatter.info(`\u{1F4E6} Source version (VERSION file): ${versionInfo.version}`));
        console.log("");
        for (const [file, version] of Object.entries(consistency.versions)) {
          const status = version === versionInfo.version ? "\u2705" : "\u274C";
          const message = version === versionInfo.version ? "synchronized" : "needs update";
          console.log(Formatter.info(`   ${file}: ${version} ${status} (${message})`));
        }
      }
      if (consistency.consistent) {
        console.log(Formatter.success("\u2705 All files are already synchronized!"));
        return;
      }
      if (options.checkOnly) {
        console.log("");
        console.log(Formatter.error("\u274C Version inconsistency detected."));
        console.log(Formatter.info("Run without --check-only to fix the inconsistencies."));
        process.exit(1);
      }
      console.log("");
      console.log(Formatter.warning("\u26A0\uFE0F  Version inconsistency detected. Synchronizing..."));
      VersionManager.syncVersion();
      const newConsistency = VersionManager.validateVersionConsistency();
      if (newConsistency.consistent) {
        console.log(Formatter.success("\u2705 Version synchronization completed successfully!"));
        if (options.verbose) {
          console.log("");
          console.log(Formatter.info("\u{1F4CB} Updated files:"));
          for (const [file, version] of Object.entries(newConsistency.versions)) {
            console.log(Formatter.info(`   ${file}: ${version} \u2705`));
          }
        }
        console.log("");
        console.log(Formatter.info(`\u{1F3AF} All files now use version: ${versionInfo.version}`));
      } else {
        console.log(
          Formatter.error("\u274C Synchronization failed. Some files could not be updated.")
        );
        console.log("");
        console.log(Formatter.info("\u{1F4CB} Current status:"));
        for (const [file, version] of Object.entries(newConsistency.versions)) {
          const status = version === versionInfo.version ? "\u2705" : "\u274C";
          console.log(Formatter.info(`   ${file}: ${version} ${status}`));
        }
        process.exit(1);
      }
    } catch (error) {
      console.error(
        Formatter.error(
          `Failed to synchronize versions: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
      process.exit(1);
    }
  });
  return command;
}
var import_commander13;
var init_sync = __esm({
  "src/commands/version/sync.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander13 = require("commander");
    init_version();
    init_formatter();
    __name(createSyncCommand, "createSyncCommand");
  }
});

// src/commands/version/release.ts
function createReleaseCommand() {
  const command = new import_commander14.Command("release");
  command.description("Create a complete release with version bump, changelog, and git tag").argument("[type]", "version bump type (major, minor, patch)", "patch").option("--no-changelog", "skip changelog generation").option("--no-commit", "skip git commit").option("--no-tag", "skip git tag creation").option("--push", "push changes and tags to remote").option("--dry-run", "show what would be done without making changes").option("--message <msg>", "custom release message").action(async (type, options) => {
    try {
      if (!["major", "minor", "patch"].includes(type)) {
        console.error(Formatter.error("Invalid release type. Must be: major, minor, or patch"));
        process.exit(1);
      }
      const currentVersion = VersionManager.getVersion();
      if (GitManager.isGitRepository()) {
        if (GitManager.hasUncommittedChanges() && !options.noCommit) {
          console.error(
            Formatter.error("Uncommitted changes detected. Please commit or stash changes first.")
          );
          process.exit(1);
        }
      } else {
        console.warn(
          Formatter.warning("Not in a git repository. Git operations will be skipped.")
        );
        options.noCommit = true;
        options.noTag = true;
      }
      const semver2 = await import("semver");
      const newVersion = semver2.inc(currentVersion.version, type);
      if (!newVersion) {
        throw new Error(`Could not calculate new version from ${currentVersion.version}`);
      }
      console.log(Formatter.info("\u{1F680} Starting release process..."));
      console.log("");
      if (options.dryRun) {
        console.log(Formatter.info("\u{1F50D} Dry run mode - no changes will be made"));
        console.log("");
        console.log(Formatter.info("\u{1F4CB} Release plan:"));
        console.log(Formatter.info(`   \u{1F4E6} Current version: ${currentVersion.version}`));
        console.log(Formatter.info(`   \u{1F3AF} New version: ${newVersion}`));
        if (!options.noChangelog) {
          console.log(Formatter.info("   \u{1F4DD} Generate changelog"));
        }
        if (!options.noCommit && GitManager.isGitRepository()) {
          console.log(Formatter.info("   \u{1F4DD} Commit changes"));
        }
        if (!options.noTag && GitManager.isGitRepository()) {
          console.log(Formatter.info(`   \u{1F3F7}\uFE0F  Create tag v${newVersion}`));
        }
        if (options.push && GitManager.isGitRepository()) {
          console.log(Formatter.info("   \u{1F4E4} Push to remote"));
        }
        return;
      }
      console.log(
        Formatter.info(`\u{1F4E6} Bumping version from ${currentVersion.version} to ${newVersion}...`)
      );
      VersionManager.bumpVersion(type);
      VersionManager.syncVersion();
      console.log(Formatter.success("\u2705 Version updated"));
      if (!options.noChangelog) {
        console.log(Formatter.info("\u{1F4DD} Generating changelog..."));
        const lastTag = GitManager.getLastTag();
        const since = lastTag || void 0;
        ChangelogManager.generateChangelog(newVersion, since);
        console.log(Formatter.success("\u2705 Changelog updated"));
      }
      if (!options.noCommit && GitManager.isGitRepository()) {
        console.log(Formatter.info("\u{1F4DD} Committing changes..."));
        const commitMessage = options.message || `chore: release version ${newVersion}`;
        const filesToCommit = ["VERSION", "package.json"];
        if (!options.noChangelog) {
          filesToCommit.push("CHANGELOG.md");
        }
        GitManager.commit(commitMessage, filesToCommit);
        console.log(Formatter.success("\u2705 Changes committed"));
      }
      if (!options.noTag && GitManager.isGitRepository()) {
        console.log(Formatter.info(`\u{1F3F7}\uFE0F  Creating tag v${newVersion}...`));
        const tagMessage = `Release version ${newVersion}`;
        GitManager.createTag(newVersion, tagMessage);
        console.log(Formatter.success("\u2705 Tag created"));
      }
      if (options.push && GitManager.isGitRepository()) {
        console.log(Formatter.info("\u{1F4E4} Pushing to remote..."));
        try {
          const { execSync: execSync4 } = await import("child_process");
          const currentBranch = GitManager.getCurrentBranch();
          execSync4(`git push origin ${currentBranch}`);
          console.log(Formatter.success("\u2705 Commits pushed"));
          if (!options.noTag) {
            GitManager.pushTags();
            console.log(Formatter.success("\u2705 Tags pushed"));
          }
        } catch (error) {
          console.error(Formatter.error(`Failed to push to remote: ${error}`));
          console.log(Formatter.info("\u{1F4A1} You can push manually later"));
        }
      }
      console.log("");
      console.log(Formatter.success("\u{1F389} Release completed successfully!"));
      console.log("");
      console.log(Formatter.info("\u{1F4CB} Release summary:"));
      console.log(Formatter.info(`   \u{1F4E6} Version: ${currentVersion.version} \u2192 ${newVersion}`));
      console.log(Formatter.info(`   \u{1F4C5} Date: ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`));
      if (!options.noChangelog) {
        console.log(Formatter.info("   \u{1F4DD} Changelog: Updated"));
      }
      if (!options.noCommit && GitManager.isGitRepository()) {
        console.log(Formatter.info("   \u{1F4DD} Git: Changes committed"));
      }
      if (!options.noTag && GitManager.isGitRepository()) {
        console.log(Formatter.info(`   \u{1F3F7}\uFE0F  Tag: v${newVersion} created`));
      }
      if (!options.push && GitManager.isGitRepository()) {
        console.log("");
        console.log(Formatter.info("\u{1F4A1} Next steps:"));
        console.log(
          Formatter.info(`   - Push changes: git push origin ${GitManager.getCurrentBranch()}`)
        );
        if (!options.noTag) {
          console.log(Formatter.info(`   - Push tags: git push origin v${newVersion}`));
        }
        console.log(Formatter.info("   - Create GitHub release from the tag"));
      }
    } catch (error) {
      console.error(
        Formatter.error(
          `Release failed: ${error instanceof Error ? error.message : "Unknown error"}`
        )
      );
      process.exit(1);
    }
  });
  return command;
}
var import_commander14;
var init_release = __esm({
  "src/commands/version/release.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander14 = require("commander");
    init_version();
    init_changelog();
    init_git();
    init_formatter();
    __name(createReleaseCommand, "createReleaseCommand");
  }
});

// src/commands/version.ts
function createVersionCommand() {
  const command = new import_commander15.Command("version");
  command.description("Version management commands").addHelpText(
    "after",
    `
Examples:
  $ aitrackdown version show                    # Display current version
  $ aitrackdown version bump patch             # Bump patch version (0.1.0 \u2192 0.1.1)
  $ aitrackdown version bump minor             # Bump minor version (0.1.0 \u2192 0.2.0)
  $ aitrackdown version bump major             # Bump major version (0.1.0 \u2192 1.0.0)
  $ aitrackdown version changelog generate     # Generate/update CHANGELOG.md
  $ aitrackdown version tag --push             # Create and push git tag
  $ aitrackdown version sync                   # Sync version across all files
  $ aitrackdown version release minor --push   # Complete release process

Version Management:
  This tool follows semantic versioning (semver.org) and conventional commits.
  The VERSION file is the source of truth for the project version.
    `
  );
  command.addCommand(createShowCommand());
  command.addCommand(createBumpCommand());
  command.addCommand(createChangelogCommand());
  command.addCommand(createTagCommand());
  command.addCommand(createSyncCommand());
  command.addCommand(createReleaseCommand());
  return command;
}
var import_commander15;
var init_version2 = __esm({
  "src/commands/version.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander15 = require("commander");
    init_show();
    init_bump();
    init_changelog2();
    init_tag();
    init_sync();
    init_release();
    __name(createVersionCommand, "createVersionCommand");
  }
});

// src/utils/simple-id-generator.ts
var fs11, path11, _IdGenerator, IdGenerator;
var init_simple_id_generator = __esm({
  "src/utils/simple-id-generator.ts"() {
    "use strict";
    init_cjs_shims();
    fs11 = __toESM(require("fs"), 1);
    path11 = __toESM(require("path"), 1);
    _IdGenerator = class _IdGenerator {
      countersPath;
      counters = {
        epic: 1,
        issue: 1,
        task: 1,
        pr: 1
      };
      constructor() {
        this.countersPath = path11.join(process.cwd(), ".ai-trackdown", "counters.json");
        this.loadCounters();
      }
      /**
       * Generate unique Epic ID
       */
      generateEpicId(title) {
        const id = `EP-${this.counters.epic.toString().padStart(4, "0")}`;
        this.counters.epic++;
        this.saveCounters();
        return id;
      }
      /**
       * Generate unique Issue ID
       */
      generateIssueId(epic_id, title) {
        const id = `ISS-${this.counters.issue.toString().padStart(4, "0")}`;
        this.counters.issue++;
        this.saveCounters();
        return id;
      }
      /**
       * Generate unique Task ID
       */
      generateTaskId(issue_id, title) {
        const id = `TSK-${this.counters.task.toString().padStart(4, "0")}`;
        this.counters.task++;
        this.saveCounters();
        return id;
      }
      /**
       * Generate unique PR ID
       */
      generatePRId(issue_id, title) {
        const id = `PR-${this.counters.pr.toString().padStart(4, "0")}`;
        this.counters.pr++;
        this.saveCounters();
        return id;
      }
      /**
       * Load counters from file
       */
      loadCounters() {
        try {
          if (fs11.existsSync(this.countersPath)) {
            const data = fs11.readFileSync(this.countersPath, "utf8");
            const loaded = JSON.parse(data);
            this.counters.epic = Math.max(1, loaded.epic || 1);
            this.counters.issue = Math.max(1, loaded.issue || 1);
            this.counters.task = Math.max(1, loaded.task || 1);
            this.counters.pr = Math.max(1, loaded.pr || 1);
          }
        } catch (error) {
        }
      }
      /**
       * Save counters to file
       */
      saveCounters() {
        try {
          const dir = path11.dirname(this.countersPath);
          if (!fs11.existsSync(dir)) {
            fs11.mkdirSync(dir, { recursive: true });
          }
          const data = JSON.stringify(this.counters, null, 2);
          fs11.writeFileSync(this.countersPath, data, "utf8");
        } catch (error) {
        }
      }
    };
    __name(_IdGenerator, "IdGenerator");
    IdGenerator = _IdGenerator;
  }
});

// src/commands/epic/create.ts
function createEpicCreateCommand() {
  const cmd = new import_commander16.Command("create");
  cmd.description("Create a new epic").argument("<title>", "epic title").option("-d, --description <text>", "epic description").option("-a, --assignee <username>", "assignee username").option("-p, --priority <level>", "priority level (low|medium|high|critical)", "medium").option("-s, --status <status>", "initial status (planning|active|completed|archived)", "planning").option("-t, --template <name>", "template to use", "default").option("-e, --estimated-tokens <number>", "estimated token usage", "0").option("--tags <tags>", "comma-separated tags").option("-m, --milestone <name>", "milestone name").option("--dry-run", "show what would be created without creating").action(async (title, options) => {
    try {
      await createEpic(title, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to create epic: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function createEpic(title, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const idGenerator = new IdGenerator();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const epicId = idGenerator.generateEpicId(title);
  const template = configManager.getTemplateWithFallback("epic", options.template || "default");
  if (!template) {
    throw new Error(`Epic template '${options.template || "default"}' not found`);
  }
  const tags = options.tags ? options.tags.split(",").map((tag) => tag.trim()) : [];
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const epicFrontmatter = {
    epic_id: epicId,
    title,
    description: options.description || template.frontmatter_template.description || "",
    status: options.status || "planning",
    priority: options.priority || "medium",
    assignee: options.assignee || config.default_assignee || "unassigned",
    created_date: now,
    updated_date: now,
    estimated_tokens: parseInt(options.estimatedTokens || "0", 10),
    actual_tokens: 0,
    ai_context: template.ai_context_defaults || config.ai_context_templates || [],
    sync_status: "local",
    related_issues: [],
    tags: tags.length > 0 ? tags : void 0,
    milestone: options.milestone,
    dependencies: [],
    completion_percentage: 0
  };
  const content = template.content_template.replace(/\{\{title\}\}/g, title).replace(/\{\{description\}\}/g, epicFrontmatter.description);
  const filename = `${epicId}-${title.toLowerCase().replace(/[^a-z0-9]+/g, "-")}${config.naming_conventions.file_extension}`;
  const filePath = path12.join(paths.epicsDir, filename);
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - Epic would be created with:"));
    console.log(Formatter.debug(`File: ${filePath}`));
    console.log(Formatter.debug(`Epic ID: ${epicId}`));
    console.log(Formatter.debug(`Title: ${title}`));
    console.log(Formatter.debug(`Status: ${epicFrontmatter.status}`));
    console.log(Formatter.debug(`Priority: ${epicFrontmatter.priority}`));
    console.log(Formatter.debug(`Assignee: ${epicFrontmatter.assignee}`));
    if (tags.length > 0) {
      console.log(Formatter.debug(`Tags: ${tags.join(", ")}`));
    }
    if (options.milestone) {
      console.log(Formatter.debug(`Milestone: ${options.milestone}`));
    }
    return;
  }
  if (fs12.existsSync(filePath)) {
    throw new Error(`Epic file already exists: ${filePath}`);
  }
  parser.writeEpic(filePath, epicFrontmatter, content);
  try {
    const indexManager = new TrackdownIndexManager(config, paths.projectRoot, cliTasksDir);
    await indexManager.updateItem("epic", epicId);
  } catch (error) {
    console.warn(Formatter.warning(`Index update failed (non-critical): ${error instanceof Error ? error.message : "Unknown error"}`));
  }
  console.log(Formatter.success(`Epic created successfully!`));
  console.log(Formatter.info(`Epic ID: ${epicId}`));
  console.log(Formatter.info(`File: ${filePath}`));
  console.log(Formatter.info(`Title: ${title}`));
  console.log(Formatter.info(`Status: ${epicFrontmatter.status}`));
  console.log(Formatter.info(`Priority: ${epicFrontmatter.priority}`));
  console.log(Formatter.info(`Assignee: ${epicFrontmatter.assignee}`));
  if (tags.length > 0) {
    console.log(Formatter.info(`Tags: ${tags.join(", ")}`));
  }
  if (options.milestone) {
    console.log(Formatter.info(`Milestone: ${options.milestone}`));
  }
}
var import_commander16, path12, fs12;
var init_create = __esm({
  "src/commands/epic/create.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander16 = require("commander");
    path12 = __toESM(require("path"), 1);
    fs12 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_simple_id_generator();
    init_trackdown_index_manager();
    init_formatter();
    __name(createEpicCreateCommand, "createEpicCreateCommand");
    __name(createEpic, "createEpic");
  }
});

// src/utils/relationship-manager.ts
var _RelationshipManager, RelationshipManager;
var init_relationship_manager = __esm({
  "src/utils/relationship-manager.ts"() {
    "use strict";
    init_cjs_shims();
    init_frontmatter_parser();
    init_unified_path_resolver();
    _RelationshipManager = class _RelationshipManager {
      parser;
      config;
      projectRoot;
      cliTasksDir;
      // In-memory caches for performance
      epicCache = /* @__PURE__ */ new Map();
      issueCache = /* @__PURE__ */ new Map();
      taskCache = /* @__PURE__ */ new Map();
      prCache = /* @__PURE__ */ new Map();
      lastCacheUpdate = 0;
      cacheExpiry = 3e5;
      // 5 minutes
      constructor(config, projectRoot, cliTasksDir) {
        this.parser = new FrontmatterParser();
        this.config = config;
        this.projectRoot = projectRoot || process.cwd();
        this.cliTasksDir = cliTasksDir;
      }
      /**
       * Get complete hierarchy for an epic (epic + all issues + all tasks)
       */
      getEpicHierarchy(epicId) {
        this.refreshCacheIfNeeded();
        const epic = this.epicCache.get(epicId);
        if (!epic) {
          return null;
        }
        const issues = Array.from(this.issueCache.values()).filter((issue) => issue.epic_id === epicId).sort((a, b) => a.created_date.localeCompare(b.created_date));
        const tasks = Array.from(this.taskCache.values()).filter((task) => task.epic_id === epicId).sort((a, b) => a.created_date.localeCompare(b.created_date));
        const prs = Array.from(this.prCache.values()).filter((pr) => pr.epic_id === epicId).sort((a, b) => a.created_date.localeCompare(b.created_date));
        return {
          epic,
          issues,
          tasks,
          prs
        };
      }
      /**
       * Get hierarchy for an issue (issue + its tasks + parent epic)
       */
      getIssueHierarchy(issueId) {
        this.refreshCacheIfNeeded();
        const issue = this.issueCache.get(issueId);
        if (!issue) {
          return null;
        }
        const tasks = Array.from(this.taskCache.values()).filter((task) => task.issue_id === issueId).sort((a, b) => a.created_date.localeCompare(b.created_date));
        const prs = Array.from(this.prCache.values()).filter((pr) => pr.issue_id === issueId).sort((a, b) => a.created_date.localeCompare(b.created_date));
        const epic = this.epicCache.get(issue.epic_id);
        return {
          issue,
          tasks,
          prs,
          epic
        };
      }
      /**
       * Get hierarchy for a PR (PR + parent issue + parent epic)
       */
      getPRHierarchy(prId) {
        this.refreshCacheIfNeeded();
        const pr = this.prCache.get(prId);
        if (!pr) {
          return null;
        }
        const issue = this.issueCache.get(pr.issue_id);
        if (!issue) {
          return null;
        }
        const epic = this.epicCache.get(pr.epic_id);
        return {
          pr,
          issue,
          epic
        };
      }
      /**
       * Get all children items for a parent ID
       */
      getChildren(parentId, type) {
        this.refreshCacheIfNeeded();
        if (type === "epic") {
          return Array.from(this.issueCache.values()).filter((issue) => issue.epic_id === parentId);
        } else if (type === "issue") {
          return Array.from(this.taskCache.values()).filter((task) => task.issue_id === parentId);
        }
        return [];
      }
      /**
       * Get parent item for a child ID
       */
      getParent(childId, childType) {
        this.refreshCacheIfNeeded();
        if (childType === "issue") {
          const issue = this.issueCache.get(childId);
          return issue ? this.epicCache.get(issue.epic_id) || null : null;
        } else if (childType === "task") {
          const task = this.taskCache.get(childId);
          return task ? this.issueCache.get(task.issue_id) || null : null;
        } else if (childType === "pr") {
          const pr = this.prCache.get(childId);
          return pr ? this.issueCache.get(pr.issue_id) || null : null;
        }
        return null;
      }
      /**
       * Get all related items (siblings and dependencies)
       */
      getRelatedItems(itemId) {
        this.refreshCacheIfNeeded();
        const item = this.findItemById(itemId);
        if (!item) {
          return { siblings: [], dependencies: [], dependents: [], blocked_by: [], blocks: [] };
        }
        let siblings = [];
        if ("task_id" in item) {
          siblings = Array.from(this.taskCache.values()).filter((task) => task.issue_id === item.issue_id && task.task_id !== itemId);
        } else if ("pr_id" in item) {
          siblings = Array.from(this.prCache.values()).filter((pr) => pr.issue_id === item.issue_id && pr.pr_id !== itemId);
        } else if ("issue_id" in item && !("task_id" in item) && !("pr_id" in item)) {
          siblings = Array.from(this.issueCache.values()).filter((issue) => issue.epic_id === item.epic_id && issue.issue_id !== itemId);
        }
        const dependencies = this.resolveDependencies(item.dependencies || []);
        const dependents = this.findDependents(itemId);
        const blocked_by = "blocked_by" in item ? this.resolveDependencies(item.blocked_by || []) : [];
        const blocks = "blocks" in item ? this.resolveDependencies(item.blocks || []) : [];
        return {
          siblings,
          dependencies,
          dependents,
          blocked_by,
          blocks
        };
      }
      /**
       * Search across all items with filters
       */
      search(filters) {
        const startTime = Date.now();
        this.refreshCacheIfNeeded();
        let allItems = [
          ...Array.from(this.epicCache.values()),
          ...Array.from(this.issueCache.values()),
          ...Array.from(this.taskCache.values()),
          ...Array.from(this.prCache.values())
        ];
        if (filters.status) {
          const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
          allItems = allItems.filter((item) => statuses.includes(item.status));
        }
        if (filters.priority) {
          const priorities = Array.isArray(filters.priority) ? filters.priority : [filters.priority];
          allItems = allItems.filter((item) => priorities.includes(item.priority));
        }
        if (filters.assignee) {
          const assignees = Array.isArray(filters.assignee) ? filters.assignee : [filters.assignee];
          allItems = allItems.filter((item) => assignees.includes(item.assignee));
        }
        if (filters.tags) {
          const tags = Array.isArray(filters.tags) ? filters.tags : [filters.tags];
          allItems = allItems.filter((item) => {
            const itemTags = "tags" in item ? item.tags || [] : [];
            return tags.some((tag) => itemTags.includes(tag));
          });
        }
        if (filters.created_after) {
          allItems = allItems.filter((item) => item.created_date >= filters.created_after);
        }
        if (filters.created_before) {
          allItems = allItems.filter((item) => item.created_date <= filters.created_before);
        }
        if (filters.updated_after) {
          allItems = allItems.filter((item) => item.updated_date >= filters.updated_after);
        }
        if (filters.updated_before) {
          allItems = allItems.filter((item) => item.updated_date <= filters.updated_before);
        }
        if (filters.content_search) {
          const searchTerm = filters.content_search.toLowerCase();
          allItems = allItems.filter(
            (item) => item.title.toLowerCase().includes(searchTerm) || item.description.toLowerCase().includes(searchTerm) || item.content.toLowerCase().includes(searchTerm)
          );
        }
        if (filters.ai_context_search) {
          const searchTerm = filters.ai_context_search.toLowerCase();
          allItems = allItems.filter(
            (item) => item.ai_context.some((context) => context.toLowerCase().includes(searchTerm))
          );
        }
        const executionTime = Date.now() - startTime;
        return {
          items: allItems,
          total_count: allItems.length,
          search_query: filters,
          execution_time: executionTime
        };
      }
      /**
       * Validate relationships and hierarchical integrity
       */
      validateRelationships() {
        this.refreshCacheIfNeeded();
        const errors = [];
        const warnings = [];
        for (const issue of this.issueCache.values()) {
          if (!this.epicCache.has(issue.epic_id)) {
            errors.push({
              field: "epic_id",
              message: `Issue ${issue.issue_id} references non-existent epic ${issue.epic_id}`,
              severity: "error"
            });
          }
        }
        for (const task of this.taskCache.values()) {
          if (!this.issueCache.has(task.issue_id)) {
            errors.push({
              field: "issue_id",
              message: `Task ${task.task_id} references non-existent issue ${task.issue_id}`,
              severity: "error"
            });
          }
          if (!this.epicCache.has(task.epic_id)) {
            errors.push({
              field: "epic_id",
              message: `Task ${task.task_id} references non-existent epic ${task.epic_id}`,
              severity: "error"
            });
          }
        }
        for (const pr of this.prCache.values()) {
          if (!this.issueCache.has(pr.issue_id)) {
            errors.push({
              field: "issue_id",
              message: `PR ${pr.pr_id} references non-existent issue ${pr.issue_id}`,
              severity: "error"
            });
          }
          if (!this.epicCache.has(pr.epic_id)) {
            errors.push({
              field: "epic_id",
              message: `PR ${pr.pr_id} references non-existent epic ${pr.epic_id}`,
              severity: "error"
            });
          }
        }
        const circularDeps = this.findCircularDependencies();
        for (const cycle of circularDeps) {
          errors.push({
            field: "dependencies",
            message: `Circular dependency detected: ${cycle.join(" \u2192 ")}`,
            severity: "error"
          });
        }
        for (const task of this.taskCache.values()) {
          const issue = this.issueCache.get(task.issue_id);
          if (issue && task.epic_id !== issue.epic_id) {
            warnings.push({
              field: "epic_id",
              message: `Task ${task.task_id} epic_id (${task.epic_id}) doesn't match issue's epic_id (${issue.epic_id})`,
              severity: "warning"
            });
          }
        }
        for (const pr of this.prCache.values()) {
          const issue = this.issueCache.get(pr.issue_id);
          if (issue && pr.epic_id !== issue.epic_id) {
            warnings.push({
              field: "epic_id",
              message: `PR ${pr.pr_id} epic_id (${pr.epic_id}) doesn't match issue's epic_id (${issue.epic_id})`,
              severity: "warning"
            });
          }
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
      /**
       * Rebuild all caches from filesystem
       */
      rebuildCache() {
        this.epicCache.clear();
        this.issueCache.clear();
        this.taskCache.clear();
        this.prCache.clear();
        const pathResolver = new UnifiedPathResolver(this.config, this.projectRoot, this.cliTasksDir);
        const paths = pathResolver.getUnifiedPaths();
        const epics = this.parser.parseDirectory(paths.epicsDir, "epic");
        for (const epic of epics) {
          this.epicCache.set(epic.epic_id, epic);
        }
        const issues = this.parser.parseDirectory(paths.issuesDir, "issue");
        for (const issue of issues) {
          this.issueCache.set(issue.issue_id, issue);
        }
        const tasks = this.parser.parseDirectory(paths.tasksDir, "task");
        for (const task of tasks) {
          this.taskCache.set(task.task_id, task);
        }
        const prs = this.parser.parseDirectory(paths.prsDir, "pr");
        for (const pr of prs) {
          this.prCache.set(pr.pr_id, pr);
        }
        this.lastCacheUpdate = Date.now();
      }
      /**
       * Get cache statistics
       */
      getCacheStats() {
        return {
          epics: this.epicCache.size,
          issues: this.issueCache.size,
          tasks: this.taskCache.size,
          prs: this.prCache.size,
          lastUpdate: new Date(this.lastCacheUpdate),
          isStale: Date.now() - this.lastCacheUpdate > this.cacheExpiry
        };
      }
      /**
       * Force refresh cache if stale
       */
      refreshCacheIfNeeded() {
        if (Date.now() - this.lastCacheUpdate > this.cacheExpiry) {
          this.rebuildCache();
        }
      }
      /**
       * Find item by ID across all caches
       */
      findItemById(itemId) {
        return this.epicCache.get(itemId) || this.issueCache.get(itemId) || this.taskCache.get(itemId) || this.prCache.get(itemId) || null;
      }
      /**
       * Resolve dependency IDs to actual items
       */
      resolveDependencies(dependencyIds) {
        const dependencies = [];
        for (const depId of dependencyIds) {
          const item = this.findItemById(depId);
          if (item) {
            dependencies.push(item);
          }
        }
        return dependencies;
      }
      /**
       * Find items that depend on the given item
       */
      findDependents(itemId) {
        const dependents = [];
        const allItems = [
          ...Array.from(this.epicCache.values()),
          ...Array.from(this.issueCache.values()),
          ...Array.from(this.taskCache.values()),
          ...Array.from(this.prCache.values())
        ];
        for (const item of allItems) {
          if (item.dependencies && item.dependencies.includes(itemId)) {
            dependents.push(item);
          }
        }
        return dependents;
      }
      /**
       * Find circular dependencies using DFS
       */
      findCircularDependencies() {
        const cycles = [];
        const visited = /* @__PURE__ */ new Set();
        const recursionStack = /* @__PURE__ */ new Set();
        const allItems = [
          ...Array.from(this.epicCache.values()),
          ...Array.from(this.issueCache.values()),
          ...Array.from(this.taskCache.values()),
          ...Array.from(this.prCache.values())
        ];
        for (const item of allItems) {
          const itemId = this.getItemId(item);
          if (!visited.has(itemId)) {
            const path31 = [];
            this.dfsForCycles(itemId, visited, recursionStack, path31, cycles);
          }
        }
        return cycles;
      }
      /**
       * DFS helper for cycle detection
       */
      dfsForCycles(itemId, visited, recursionStack, path31, cycles) {
        visited.add(itemId);
        recursionStack.add(itemId);
        path31.push(itemId);
        const item = this.findItemById(itemId);
        if (item && item.dependencies) {
          for (const depId of item.dependencies) {
            if (!visited.has(depId)) {
              this.dfsForCycles(depId, visited, recursionStack, path31, cycles);
            } else if (recursionStack.has(depId)) {
              const cycleStart = path31.indexOf(depId);
              const cycle = path31.slice(cycleStart).concat([depId]);
              cycles.push(cycle);
            }
          }
        }
        recursionStack.delete(itemId);
        path31.pop();
      }
      /**
       * Get appropriate ID field from any item
       */
      getItemId(item) {
        if ("epic_id" in item && !("issue_id" in item)) {
          return item.epic_id;
        } else if ("issue_id" in item && !("task_id" in item) && !("pr_id" in item)) {
          return item.issue_id;
        } else if ("task_id" in item) {
          return item.task_id;
        } else if ("pr_id" in item) {
          return item.pr_id;
        }
        throw new Error("Unknown item type");
      }
      /**
       * Get project overview statistics
       */
      getProjectOverview() {
        this.refreshCacheIfNeeded();
        const allItems = [
          ...Array.from(this.epicCache.values()),
          ...Array.from(this.issueCache.values()),
          ...Array.from(this.taskCache.values()),
          ...Array.from(this.prCache.values())
        ];
        const statusBreakdown = {};
        const priorityBreakdown = {};
        for (const item of allItems) {
          statusBreakdown[item.status] = (statusBreakdown[item.status] || 0) + 1;
          priorityBreakdown[item.priority] = (priorityBreakdown[item.priority] || 0) + 1;
        }
        const completedEpics = Array.from(this.epicCache.values()).filter((e) => e.status === "completed").length;
        const completedIssues = Array.from(this.issueCache.values()).filter((i) => i.status === "completed").length;
        const completedTasks = Array.from(this.taskCache.values()).filter((t) => t.status === "completed").length;
        const completedPRs = Array.from(this.prCache.values()).filter((p) => p.status === "completed" || p.pr_status === "merged").length;
        const totalItems = allItems.length;
        const completedItems = completedEpics + completedIssues + completedTasks + completedPRs;
        const overallCompletion = totalItems > 0 ? completedItems / totalItems * 100 : 0;
        return {
          totals: {
            epics: this.epicCache.size,
            issues: this.issueCache.size,
            tasks: this.taskCache.size,
            prs: this.prCache.size
          },
          status_breakdown: statusBreakdown,
          priority_breakdown: priorityBreakdown,
          completion_metrics: {
            completed_epics: completedEpics,
            completed_issues: completedIssues,
            completed_tasks: completedTasks,
            completed_prs: completedPRs,
            overall_completion: Math.round(overallCompletion * 100) / 100
          }
        };
      }
      /**
       * Get all PRs
       */
      getAllPRs() {
        this.refreshCacheIfNeeded();
        return Array.from(this.prCache.values());
      }
      /**
       * Get all epics
       */
      getAllEpics() {
        this.refreshCacheIfNeeded();
        return Array.from(this.epicCache.values());
      }
      /**
       * Get all issues
       */
      getAllIssues() {
        this.refreshCacheIfNeeded();
        return Array.from(this.issueCache.values());
      }
      /**
       * Get all tasks
       */
      getAllTasks() {
        this.refreshCacheIfNeeded();
        return Array.from(this.taskCache.values());
      }
    };
    __name(_RelationshipManager, "RelationshipManager");
    RelationshipManager = _RelationshipManager;
  }
});

// src/types/ai-trackdown.ts
function isEpicFrontmatter(item) {
  return "epic_id" in item && !("issue_id" in item) && !("task_id" in item) && !("pr_id" in item);
}
function isTaskFrontmatter(item) {
  return "task_id" in item && "issue_id" in item && "epic_id" in item && !("pr_id" in item);
}
function isEpicData(item) {
  return isEpicFrontmatter(item);
}
function isTaskData(item) {
  return isTaskFrontmatter(item);
}
var init_ai_trackdown = __esm({
  "src/types/ai-trackdown.ts"() {
    "use strict";
    init_cjs_shims();
    __name(isEpicFrontmatter, "isEpicFrontmatter");
    __name(isTaskFrontmatter, "isTaskFrontmatter");
    __name(isEpicData, "isEpicData");
    __name(isTaskData, "isTaskData");
  }
});

// src/commands/epic/list.ts
function createEpicListCommand() {
  const cmd = new import_commander17.Command("list");
  cmd.description("List epics with filtering options").option("-s, --status <statuses>", "filter by status (comma-separated)").option("-p, --priority <priorities>", "filter by priority (comma-separated)").option("-a, --assignee <username>", "filter by assignee").option("-t, --tags <tags>", "filter by tags (comma-separated)").option("-m, --milestone <name>", "filter by milestone").option("--search <term>", "search in title, description, and content").option("-f, --format <type>", "output format (table|json|yaml)", "table").option("--sort-by <field>", "sort by field (created|updated|title|priority|status)", "created").option("--sort-order <order>", "sort order (asc|desc)", "desc").option("-l, --limit <number>", "limit number of results").option("--show-progress", "show completion progress").option("--show-issues", "show related issues count").option("--active", "show only active epics (equivalent to --status active)").action(async (options) => {
    try {
      await listEpics(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to list epics: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function listEpics(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const filters = {};
  if (options.active) {
    filters.status = "active";
  } else if (options.status) {
    const statuses = options.status.split(",").map((s) => s.trim());
    filters.status = statuses.length === 1 ? statuses[0] : statuses;
  }
  if (options.priority) {
    const priorities = options.priority.split(",").map((p) => p.trim());
    filters.priority = priorities.length === 1 ? priorities[0] : priorities;
  }
  if (options.assignee) {
    filters.assignee = options.assignee;
  }
  if (options.tags) {
    const tags = options.tags.split(",").map((t) => t.trim());
    filters.tags = tags.length === 1 ? tags[0] : tags;
  }
  if (options.search) {
    filters.content_search = options.search;
  }
  const searchResult = relationshipManager.search(filters);
  const epics = searchResult.items.filter(isEpicData);
  let filteredEpics = epics;
  if (options.milestone) {
    filteredEpics = epics.filter((epic) => epic.milestone === options.milestone);
  }
  sortEpics(filteredEpics, options.sortBy || "created", options.sortOrder || "desc");
  if (options.limit) {
    const limit = parseInt(options.limit.toString(), 10);
    filteredEpics = filteredEpics.slice(0, limit);
  }
  switch (options.format) {
    case "json":
      console.log(JSON.stringify(filteredEpics, null, 2));
      break;
    case "yaml":
      const YAML6 = await import("yaml");
      console.log(YAML6.stringify(filteredEpics));
      break;
    default:
      await displayEpicsTable(filteredEpics, options, relationshipManager);
  }
}
function sortEpics(epics, sortBy, sortOrder) {
  epics.sort((a, b) => {
    let aVal, bVal;
    switch (sortBy) {
      case "created":
        aVal = new Date(a.created_date);
        bVal = new Date(b.created_date);
        break;
      case "updated":
        aVal = new Date(a.updated_date);
        bVal = new Date(b.updated_date);
        break;
      case "title":
        aVal = a.title.toLowerCase();
        bVal = b.title.toLowerCase();
        break;
      case "priority":
        const priorityOrder = { "critical": 4, "high": 3, "medium": 2, "low": 1 };
        aVal = priorityOrder[a.priority] || 0;
        bVal = priorityOrder[b.priority] || 0;
        break;
      case "status":
        const statusOrder = { "active": 4, "planning": 3, "completed": 2, "archived": 1 };
        aVal = statusOrder[a.status] || 0;
        bVal = statusOrder[b.status] || 0;
        break;
      default:
        aVal = a.created_date;
        bVal = b.created_date;
    }
    if (sortOrder === "asc") {
      return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
    } else {
      return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
    }
  });
}
async function displayEpicsTable(epics, options, relationshipManager) {
  if (epics.length === 0) {
    console.log(Formatter.info("No epics found matching the criteria."));
    return;
  }
  console.log(Formatter.success(`Found ${epics.length} epic(s):`));
  console.log("");
  const headers = ["ID", "Title", "Status", "Priority", "Assignee"];
  if (options.showProgress) headers.push("Progress");
  if (options.showIssues) headers.push("Issues");
  headers.push("Created");
  const colWidths = headers.map(() => 0);
  const rows = [];
  for (const epic of epics) {
    const row = [
      epic.epic_id,
      truncateText(epic.title, 40),
      getStatusDisplay(epic.status),
      getPriorityDisplay(epic.priority),
      epic.assignee
    ];
    if (options.showProgress) {
      const progress = epic.completion_percentage || 0;
      row.push(`${progress}%`);
    }
    if (options.showIssues) {
      const hierarchy = relationshipManager.getEpicHierarchy(epic.epic_id);
      const issueCount = hierarchy ? hierarchy.issues.length : 0;
      row.push(issueCount.toString());
    }
    row.push(formatDate(epic.created_date));
    rows.push(row);
  }
  for (let i = 0; i < headers.length; i++) {
    colWidths[i] = Math.max(headers[i].length, ...rows.map((row) => row[i].length));
  }
  printTableRow(headers, colWidths, true);
  printSeparator(colWidths);
  for (const row of rows) {
    printTableRow(row, colWidths, false);
  }
  console.log("");
  console.log(Formatter.info(`Total: ${epics.length} epic(s)`));
}
function printTableRow(row, widths, isHeader) {
  const paddedRow = row.map((cell, i) => cell.padEnd(widths[i]));
  const rowText = paddedRow.join(" | ");
  if (isHeader) {
    console.log(Formatter.info(rowText));
  } else {
    console.log(rowText);
  }
}
function printSeparator(widths) {
  const separator = widths.map((width) => "-".repeat(width)).join("-+-");
  console.log(separator);
}
function truncateText(text, maxLength) {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + "...";
}
function getStatusDisplay(status) {
  const statusColors = {
    "planning": /* @__PURE__ */ __name((text) => Formatter.info(text), "planning"),
    "active": /* @__PURE__ */ __name((text) => Formatter.success(text), "active"),
    "completed": /* @__PURE__ */ __name((text) => Formatter.success(text), "completed"),
    "archived": /* @__PURE__ */ __name((text) => Formatter.debug(text), "archived")
  };
  const colorFn = statusColors[status] || ((text) => text);
  return colorFn(status.toUpperCase());
}
function getPriorityDisplay(priority) {
  const priorityColors = {
    "critical": /* @__PURE__ */ __name((text) => Formatter.error(text), "critical"),
    "high": /* @__PURE__ */ __name((text) => Formatter.warning(text), "high"),
    "medium": /* @__PURE__ */ __name((text) => Formatter.info(text), "medium"),
    "low": /* @__PURE__ */ __name((text) => Formatter.debug(text), "low")
  };
  const colorFn = priorityColors[priority] || ((text) => text);
  return colorFn(priority.toUpperCase());
}
function formatDate(dateString) {
  const date = new Date(dateString);
  return date.toLocaleDateString();
}
var import_commander17;
var init_list = __esm({
  "src/commands/epic/list.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander17 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    init_ai_trackdown();
    __name(createEpicListCommand, "createEpicListCommand");
    __name(listEpics, "listEpics");
    __name(sortEpics, "sortEpics");
    __name(displayEpicsTable, "displayEpicsTable");
    __name(printTableRow, "printTableRow");
    __name(printSeparator, "printSeparator");
    __name(truncateText, "truncateText");
    __name(getStatusDisplay, "getStatusDisplay");
    __name(getPriorityDisplay, "getPriorityDisplay");
    __name(formatDate, "formatDate");
  }
});

// src/commands/epic/show.ts
function createEpicShowCommand() {
  const cmd = new import_commander18.Command("show");
  cmd.description("Show detailed information about an epic").argument("<epic-id>", "epic ID to show").option("-f, --format <type>", "output format (detailed|json|yaml)", "detailed").option("--show-issues, --with-issues", "show related issues").option("--show-tasks", "show all related tasks").option("--show-content", "show epic content/description").option("--show-related", "show related epics and dependencies").action(async (epicId, options) => {
    try {
      await showEpic(epicId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to show epic: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function showEpic(epicId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const hierarchy = relationshipManager.getEpicHierarchy(epicId);
  if (!hierarchy) {
    throw new Error(`Epic not found: ${epicId}`);
  }
  const { epic, issues, tasks } = hierarchy;
  switch (options.format) {
    case "json":
      const jsonOutput = {
        epic,
        ...options.showIssues && { issues },
        ...options.showTasks && { tasks }
      };
      console.log(JSON.stringify(jsonOutput, null, 2));
      break;
    case "yaml":
      const YAML6 = await import("yaml");
      const yamlOutput = {
        epic,
        ...options.showIssues && { issues },
        ...options.showTasks && { tasks }
      };
      console.log(YAML6.stringify(yamlOutput));
      break;
    default:
      await displayEpicDetailed(epic, issues, tasks, options, relationshipManager);
  }
}
async function displayEpicDetailed(epic, issues, tasks, options, relationshipManager) {
  console.log(Formatter.success(`
=== EPIC: ${epic.title} ===`));
  console.log(Formatter.info(`ID: ${epic.epic_id}`));
  console.log("");
  console.log(Formatter.success("Basic Information:"));
  console.log(`  Title: ${epic.title}`);
  console.log(`  Status: ${getStatusDisplay2(epic.status)}`);
  console.log(`  Priority: ${getPriorityDisplay2(epic.priority)}`);
  console.log(`  Assignee: ${epic.assignee}`);
  if (epic.milestone) {
    console.log(`  Milestone: ${epic.milestone}`);
  }
  if (epic.tags && epic.tags.length > 0) {
    console.log(`  Tags: ${epic.tags.join(", ")}`);
  }
  if (epic.completion_percentage !== void 0) {
    console.log(`  Progress: ${epic.completion_percentage}%`);
  }
  console.log("");
  console.log(Formatter.success("Tracking Information:"));
  console.log(`  Created: ${formatDateTime(epic.created_date)}`);
  console.log(`  Updated: ${formatDateTime(epic.updated_date)}`);
  console.log(`  Estimated Tokens: ${epic.estimated_tokens || 0}`);
  console.log(`  Actual Tokens: ${epic.actual_tokens || 0}`);
  if (epic.estimated_tokens > 0) {
    const efficiency = epic.actual_tokens / epic.estimated_tokens;
    console.log(`  Token Efficiency: ${(efficiency * 100).toFixed(1)}%`);
  }
  console.log(`  Sync Status: ${epic.sync_status || "local"}`);
  console.log("");
  if (epic.description) {
    console.log(Formatter.success("Description:"));
    console.log(`  ${epic.description}`);
    console.log("");
  }
  if (options.showContent && epic.content) {
    console.log(Formatter.success("Content:"));
    console.log(epic.content);
    console.log("");
  }
  if (epic.ai_context && epic.ai_context.length > 0) {
    console.log(Formatter.success("AI Context:"));
    for (const context of epic.ai_context) {
      console.log(`  \u2022 ${context}`);
    }
    console.log("");
  }
  if (epic.dependencies && epic.dependencies.length > 0) {
    console.log(Formatter.success("Dependencies:"));
    for (const dep of epic.dependencies) {
      console.log(`  \u2022 ${dep}`);
    }
    console.log("");
  }
  if (options.showIssues || issues.length > 0) {
    console.log(Formatter.success(`Related Issues (${issues.length}):`));
    if (issues.length === 0) {
      console.log(Formatter.debug("  No issues found"));
    } else {
      for (const issue of issues) {
        const statusIcon = getStatusIcon3(issue.status);
        const priorityColor = getPriorityDisplay2(issue.priority);
        console.log(`  ${statusIcon} ${issue.issue_id}: ${issue.title} [${priorityColor}]`);
      }
    }
    console.log("");
  }
  if (options.showTasks || tasks.length > 0) {
    console.log(Formatter.success(`All Related Tasks (${tasks.length}):`));
    if (tasks.length === 0) {
      console.log(Formatter.debug("  No tasks found"));
    } else {
      const tasksByIssue = tasks.reduce((acc, task) => {
        if (!acc[task.issue_id]) acc[task.issue_id] = [];
        acc[task.issue_id].push(task);
        return acc;
      }, {});
      for (const [issueId, issueTasks] of Object.entries(tasksByIssue)) {
        const issue = issues.find((i) => i.issue_id === issueId);
        console.log(`  ${issue ? issue.title : issueId}:`);
        for (const task of issueTasks) {
          const statusIcon = getStatusIcon3(task.status);
          console.log(`    ${statusIcon} ${task.task_id}: ${task.title}`);
        }
      }
    }
    console.log("");
  }
  if (options.showRelated) {
    const related = relationshipManager.getRelatedItems(epic.epic_id);
    if (related.dependencies.length > 0) {
      console.log(Formatter.success("Dependencies:"));
      for (const dep of related.dependencies) {
        console.log(`  \u2022 ${getItemId(dep)}: ${dep.title}`);
      }
      console.log("");
    }
    if (related.dependents.length > 0) {
      console.log(Formatter.success("Dependents:"));
      for (const dep of related.dependents) {
        console.log(`  \u2022 ${getItemId(dep)}: ${dep.title}`);
      }
      console.log("");
    }
  }
  console.log(Formatter.success("File Information:"));
  console.log(`  Path: ${epic.file_path}`);
  console.log("");
  const completedIssues = issues.filter((i) => i.status === "completed").length;
  const completedTasks = tasks.filter((t) => t.status === "completed").length;
  console.log(Formatter.success("Summary:"));
  console.log(`  Issues: ${completedIssues}/${issues.length} completed`);
  console.log(`  Tasks: ${completedTasks}/${tasks.length} completed`);
  if (issues.length > 0) {
    const issueCompletionRate = (completedIssues / issues.length * 100).toFixed(1);
    console.log(`  Issue Completion: ${issueCompletionRate}%`);
  }
  if (tasks.length > 0) {
    const taskCompletionRate = (completedTasks / tasks.length * 100).toFixed(1);
    console.log(`  Task Completion: ${taskCompletionRate}%`);
  }
}
function getStatusDisplay2(status) {
  const statusColors = {
    "planning": /* @__PURE__ */ __name((text) => Formatter.info(text), "planning"),
    "active": /* @__PURE__ */ __name((text) => Formatter.success(text), "active"),
    "completed": /* @__PURE__ */ __name((text) => Formatter.success(text), "completed"),
    "archived": /* @__PURE__ */ __name((text) => Formatter.debug(text), "archived")
  };
  const colorFn = statusColors[status] || ((text) => text);
  return colorFn(status.toUpperCase());
}
function getPriorityDisplay2(priority) {
  const priorityColors = {
    "critical": /* @__PURE__ */ __name((text) => Formatter.error(text), "critical"),
    "high": /* @__PURE__ */ __name((text) => Formatter.warning(text), "high"),
    "medium": /* @__PURE__ */ __name((text) => Formatter.info(text), "medium"),
    "low": /* @__PURE__ */ __name((text) => Formatter.debug(text), "low")
  };
  const colorFn = priorityColors[priority] || ((text) => text);
  return colorFn(priority.toUpperCase());
}
function getStatusIcon3(status) {
  const icons = {
    "planning": "\u23F3",
    "active": "\u{1F504}",
    "completed": "\u2705",
    "archived": "\u{1F4E6}"
  };
  return icons[status] || "\u2753";
}
function formatDateTime(dateString) {
  const date = new Date(dateString);
  return date.toLocaleString();
}
function getItemId(item) {
  if (item.epic_id && !item.issue_id && !item.task_id) return item.epic_id;
  if (item.issue_id && !item.task_id) return item.issue_id;
  if (item.task_id) return item.task_id;
  return "UNKNOWN";
}
var import_commander18;
var init_show2 = __esm({
  "src/commands/epic/show.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander18 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    __name(createEpicShowCommand, "createEpicShowCommand");
    __name(showEpic, "showEpic");
    __name(displayEpicDetailed, "displayEpicDetailed");
    __name(getStatusDisplay2, "getStatusDisplay");
    __name(getPriorityDisplay2, "getPriorityDisplay");
    __name(getStatusIcon3, "getStatusIcon");
    __name(formatDateTime, "formatDateTime");
    __name(getItemId, "getItemId");
  }
});

// src/commands/epic/update.ts
function createEpicUpdateCommand() {
  const cmd = new import_commander19.Command("update");
  cmd.description("Update an existing epic").argument("<epic-id>", "epic ID to update").option("-t, --title <text>", "update title").option("-d, --description <text>", "update description").option("-s, --status <status>", "update status (planning|active|completed|archived)").option("-p, --priority <level>", "update priority (low|medium|high|critical)").option("-a, --assignee <username>", "update assignee").option("--add-tags <tags>", "add tags (comma-separated)").option("--remove-tags <tags>", "remove tags (comma-separated)").option("-m, --milestone <name>", "set milestone").option("--clear-milestone", "clear milestone").option("-e, --estimated-tokens <number>", "update estimated tokens").option("--actual-tokens <number>", "update actual tokens").option("--add-dependencies <ids>", "add dependencies (comma-separated IDs)").option("--remove-dependencies <ids>", "remove dependencies (comma-separated IDs)").option("--progress <percentage>", "update completion percentage (0-100)").option("--dry-run", "show what would be updated without updating").action(async (epicId, options) => {
    try {
      await updateEpic(epicId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to update epic: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function updateEpic(epicId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  const hierarchy = relationshipManager.getEpicHierarchy(epicId);
  if (!hierarchy) {
    throw new Error(`Epic not found: ${epicId}`);
  }
  const epic = hierarchy.epic;
  const filePath = epic.file_path;
  const updates = {};
  if (options.title) {
    updates.title = options.title;
  }
  if (options.description) {
    updates.description = options.description;
  }
  if (options.status) {
    updates.status = options.status;
  }
  if (options.priority) {
    updates.priority = options.priority;
  }
  if (options.assignee) {
    updates.assignee = options.assignee;
  }
  if (options.milestone) {
    updates.milestone = options.milestone;
  }
  if (options.clearMilestone) {
    updates.milestone = void 0;
  }
  if (options.estimatedTokens !== void 0) {
    updates.estimated_tokens = parseInt(options.estimatedTokens.toString(), 10);
  }
  if (options.actualTokens !== void 0) {
    updates.actual_tokens = parseInt(options.actualTokens.toString(), 10);
  }
  if (options.progress !== void 0) {
    const progress = parseInt(options.progress.toString(), 10);
    if (progress < 0 || progress > 100) {
      throw new Error("Progress must be between 0 and 100");
    }
    updates.completion_percentage = progress;
  }
  if (options.addTags || options.removeTags) {
    const currentTags = epic.tags || [];
    let newTags = [...currentTags];
    if (options.addTags) {
      const tagsToAdd = options.addTags.split(",").map((tag) => tag.trim());
      for (const tag of tagsToAdd) {
        if (!newTags.includes(tag)) {
          newTags.push(tag);
        }
      }
    }
    if (options.removeTags) {
      const tagsToRemove = options.removeTags.split(",").map((tag) => tag.trim());
      newTags = newTags.filter((tag) => !tagsToRemove.includes(tag));
    }
    updates.tags = newTags.length > 0 ? newTags : void 0;
  }
  if (options.addDependencies || options.removeDependencies) {
    const currentDeps = epic.dependencies || [];
    let newDeps = [...currentDeps];
    if (options.addDependencies) {
      const depsToAdd = options.addDependencies.split(",").map((dep) => dep.trim());
      for (const dep of depsToAdd) {
        if (!newDeps.includes(dep)) {
          newDeps.push(dep);
        }
      }
    }
    if (options.removeDependencies) {
      const depsToRemove = options.removeDependencies.split(",").map((dep) => dep.trim());
      newDeps = newDeps.filter((dep) => !depsToRemove.includes(dep));
    }
    updates.dependencies = newDeps.length > 0 ? newDeps : void 0;
  }
  if (options.dryRun || Object.keys(updates).length === 0) {
    console.log(Formatter.info(`${options.dryRun ? "Dry run - " : ""}Epic would be updated:`));
    console.log(Formatter.debug(`Epic ID: ${epicId}`));
    console.log(Formatter.debug(`File: ${filePath}`));
    if (Object.keys(updates).length === 0) {
      console.log(Formatter.warning("No updates specified"));
      return;
    }
    for (const [key, value] of Object.entries(updates)) {
      const currentValue = epic[key];
      console.log(Formatter.debug(`${key}: ${currentValue} \u2192 ${value}`));
    }
    if (options.dryRun) {
      return;
    }
  }
  const updatedEpic = parser.updateFile(filePath, updates);
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`Epic updated successfully!`));
  console.log(Formatter.info(`Epic ID: ${epicId}`));
  console.log(Formatter.info(`File: ${filePath}`));
  const changedFields = Object.keys(updates);
  if (changedFields.length > 0) {
    console.log(Formatter.info(`Updated fields: ${changedFields.join(", ")}`));
  }
  console.log("");
  console.log(Formatter.success("Current values:"));
  console.log(`  Title: ${updatedEpic.title}`);
  console.log(`  Status: ${getStatusDisplay3(updatedEpic.status)}`);
  console.log(`  Priority: ${getPriorityDisplay3(updatedEpic.priority)}`);
  console.log(`  Assignee: ${updatedEpic.assignee}`);
  if (updatedEpic.milestone) {
    console.log(`  Milestone: ${updatedEpic.milestone}`);
  }
  if (updatedEpic.tags && updatedEpic.tags.length > 0) {
    console.log(`  Tags: ${updatedEpic.tags.join(", ")}`);
  }
  if (updatedEpic.completion_percentage !== void 0) {
    console.log(`  Progress: ${updatedEpic.completion_percentage}%`);
  }
  if (updatedEpic.dependencies && updatedEpic.dependencies.length > 0) {
    console.log(`  Dependencies: ${updatedEpic.dependencies.join(", ")}`);
  }
  console.log(`  Estimated Tokens: ${updatedEpic.estimated_tokens || 0}`);
  console.log(`  Actual Tokens: ${updatedEpic.actual_tokens || 0}`);
}
function getStatusDisplay3(status) {
  const statusColors = {
    "planning": /* @__PURE__ */ __name((text) => Formatter.info(text), "planning"),
    "active": /* @__PURE__ */ __name((text) => Formatter.success(text), "active"),
    "completed": /* @__PURE__ */ __name((text) => Formatter.success(text), "completed"),
    "archived": /* @__PURE__ */ __name((text) => Formatter.debug(text), "archived")
  };
  const colorFn = statusColors[status] || ((text) => text);
  return colorFn(status.toUpperCase());
}
function getPriorityDisplay3(priority) {
  const priorityColors = {
    "critical": /* @__PURE__ */ __name((text) => Formatter.error(text), "critical"),
    "high": /* @__PURE__ */ __name((text) => Formatter.warning(text), "high"),
    "medium": /* @__PURE__ */ __name((text) => Formatter.info(text), "medium"),
    "low": /* @__PURE__ */ __name((text) => Formatter.debug(text), "low")
  };
  const colorFn = priorityColors[priority] || ((text) => text);
  return colorFn(priority.toUpperCase());
}
var import_commander19;
var init_update = __esm({
  "src/commands/epic/update.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander19 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createEpicUpdateCommand, "createEpicUpdateCommand");
    __name(updateEpic, "updateEpic");
    __name(getStatusDisplay3, "getStatusDisplay");
    __name(getPriorityDisplay3, "getPriorityDisplay");
  }
});

// src/commands/epic/delete.ts
function createEpicDeleteCommand() {
  const cmd = new import_commander20.Command("delete");
  cmd.description("Delete an epic").argument("<epic-id>", "epic ID to delete").option("-f, --force", "force deletion without confirmation").option("-r, --recursive", "delete all related issues and tasks").option("--dry-run", "show what would be deleted without deleting").action(async (epicId, options) => {
    try {
      await deleteEpic(epicId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to delete epic: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function deleteEpic(epicId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const hierarchy = relationshipManager.getEpicHierarchy(epicId);
  if (!hierarchy) {
    throw new Error(`Epic not found: ${epicId}`);
  }
  const { epic, issues, tasks } = hierarchy;
  if ((issues.length > 0 || tasks.length > 0) && !options.recursive) {
    console.log(Formatter.warning("Epic has related items:"));
    console.log(`  Issues: ${issues.length}`);
    console.log(`  Tasks: ${tasks.length}`);
    console.log("");
    console.log(Formatter.info("Use --recursive to delete all related items, or reassign them first."));
    console.log(Formatter.info("Related items:"));
    if (issues.length > 0) {
      console.log(Formatter.info("  Issues:"));
      for (const issue of issues.slice(0, 5)) {
        console.log(`    \u2022 ${issue.issue_id}: ${issue.title}`);
      }
      if (issues.length > 5) {
        console.log(`    ... and ${issues.length - 5} more`);
      }
    }
    if (tasks.length > 0) {
      console.log(Formatter.info("  Tasks:"));
      for (const task of tasks.slice(0, 5)) {
        console.log(`    \u2022 ${task.task_id}: ${task.title}`);
      }
      if (tasks.length > 5) {
        console.log(`    ... and ${tasks.length - 5} more`);
      }
    }
    throw new Error("Cannot delete epic with related items without --recursive flag");
  }
  const related = relationshipManager.getRelatedItems(epicId);
  if (related.dependents.length > 0) {
    console.log(Formatter.warning("Epic has items that depend on it:"));
    for (const dependent of related.dependents) {
      const depId = getItemId2(dependent);
      console.log(`  \u2022 ${depId}: ${dependent.title}`);
    }
    if (!options.force) {
      throw new Error("Cannot delete epic with dependents. Use --force to override or remove dependencies first.");
    }
  }
  const filesToDelete = [epic.file_path];
  if (options.recursive) {
    filesToDelete.push(...issues.map((issue) => issue.file_path));
    filesToDelete.push(...tasks.map((task) => task.file_path));
  }
  console.log(Formatter.info(`${options.dryRun ? "Dry run - " : ""}Would delete:`));
  console.log(`  Epic: ${epic.epic_id} - ${epic.title}`);
  console.log(`    File: ${epic.file_path}`);
  if (options.recursive && issues.length > 0) {
    console.log(`  Issues (${issues.length}):`);
    for (const issue of issues) {
      console.log(`    \u2022 ${issue.issue_id}: ${issue.title}`);
      console.log(`      File: ${issue.file_path}`);
    }
  }
  if (options.recursive && tasks.length > 0) {
    console.log(`  Tasks (${tasks.length}):`);
    for (const task of tasks) {
      console.log(`    \u2022 ${task.task_id}: ${task.title}`);
      console.log(`      File: ${task.file_path}`);
    }
  }
  console.log("");
  console.log(Formatter.info(`Total files to delete: ${filesToDelete.length}`));
  if (options.dryRun) {
    return;
  }
  if (!options.force) {
    const readline = await import("readline");
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });
    const answer = await new Promise((resolve5) => {
      rl.question(
        Formatter.warning("Are you sure you want to delete this epic and all related items? (yes/no): "),
        resolve5
      );
    });
    rl.close();
    if (answer.toLowerCase() !== "yes" && answer.toLowerCase() !== "y") {
      console.log(Formatter.info("Deletion cancelled."));
      return;
    }
  }
  let deletedCount = 0;
  const errors = [];
  for (const filePath of filesToDelete) {
    try {
      if (fs13.existsSync(filePath)) {
        fs13.unlinkSync(filePath);
        deletedCount++;
      } else {
        console.log(Formatter.warning(`File not found: ${filePath}`));
      }
    } catch (error) {
      const errorMsg = `Failed to delete ${filePath}: ${error instanceof Error ? error.message : "Unknown error"}`;
      errors.push(errorMsg);
      console.error(Formatter.error(errorMsg));
    }
  }
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`Epic deletion completed!`));
  console.log(Formatter.info(`Files deleted: ${deletedCount}/${filesToDelete.length}`));
  if (errors.length > 0) {
    console.log(Formatter.warning(`Errors encountered: ${errors.length}`));
    for (const error of errors) {
      console.log(Formatter.error(`  \u2022 ${error}`));
    }
  }
  console.log("");
  console.log(Formatter.success(`Epic ${epicId} has been deleted.`));
  if (options.recursive && (issues.length > 0 || tasks.length > 0)) {
    console.log(Formatter.info(`Also deleted ${issues.length} issues and ${tasks.length} tasks.`));
  }
  if (related.dependents.length > 0) {
    console.log(Formatter.warning("Warning: Items that depended on this epic may need to be updated:"));
    for (const dependent of related.dependents) {
      const depId = getItemId2(dependent);
      console.log(`  \u2022 ${depId}: ${dependent.title}`);
    }
  }
}
function getItemId2(item) {
  if (item.epic_id && !item.issue_id && !item.task_id) return item.epic_id;
  if (item.issue_id && !item.task_id) return item.issue_id;
  if (item.task_id) return item.task_id;
  return "UNKNOWN";
}
var import_commander20, fs13;
var init_delete = __esm({
  "src/commands/epic/delete.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander20 = require("commander");
    fs13 = __toESM(require("fs"), 1);
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    __name(createEpicDeleteCommand, "createEpicDeleteCommand");
    __name(deleteEpic, "deleteEpic");
    __name(getItemId2, "getItemId");
  }
});

// src/commands/epic/complete.ts
function createEpicCompleteCommand() {
  const cmd = new import_commander21.Command("complete");
  cmd.description("Mark an epic as completed").argument("<epic-id>", "epic ID to complete").option("-f, --force", "complete even if issues/tasks are not completed").option("--actual-tokens <number>", "set actual token usage").option("--completion-notes <text>", "add completion notes").option("--auto-complete-children", "automatically complete all child issues and tasks").option("--dry-run", "show what would be completed without completing").action(async (epicId, options) => {
    try {
      await completeEpic(epicId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to complete epic: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function completeEpic(epicId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  const hierarchy = relationshipManager.getEpicHierarchy(epicId);
  if (!hierarchy) {
    throw new Error(`Epic not found: ${epicId}`);
  }
  const { epic, issues, tasks } = hierarchy;
  if (epic.status === "completed") {
    console.log(Formatter.warning(`Epic ${epicId} is already completed.`));
    return;
  }
  const incompleteIssues = issues.filter((issue) => issue.status !== "completed");
  const incompleteTasks = tasks.filter((task) => task.status !== "completed");
  console.log(Formatter.info(`Epic: ${epic.title}`));
  console.log(Formatter.info(`Current Status: ${epic.status}`));
  console.log("");
  const issueCompletionRate = issues.length > 0 ? (issues.length - incompleteIssues.length) / issues.length * 100 : 100;
  const taskCompletionRate = tasks.length > 0 ? (tasks.length - incompleteTasks.length) / tasks.length * 100 : 100;
  console.log(Formatter.success("Completion Status:"));
  console.log(`  Issues: ${issues.length - incompleteIssues.length}/${issues.length} completed (${issueCompletionRate.toFixed(1)}%)`);
  console.log(`  Tasks: ${tasks.length - incompleteTasks.length}/${tasks.length} completed (${taskCompletionRate.toFixed(1)}%)`);
  console.log("");
  if ((incompleteIssues.length > 0 || incompleteTasks.length > 0) && !options.force && !options.autoCompleteChildren) {
    console.log(Formatter.warning("Epic has incomplete items:"));
    if (incompleteIssues.length > 0) {
      console.log(Formatter.info(`  Incomplete Issues (${incompleteIssues.length}):`));
      for (const issue of incompleteIssues.slice(0, 5)) {
        console.log(`    \u2022 ${issue.issue_id}: ${issue.title} [${issue.status}]`);
      }
      if (incompleteIssues.length > 5) {
        console.log(`    ... and ${incompleteIssues.length - 5} more`);
      }
    }
    if (incompleteTasks.length > 0) {
      console.log(Formatter.info(`  Incomplete Tasks (${incompleteTasks.length}):`));
      for (const task of incompleteTasks.slice(0, 5)) {
        console.log(`    \u2022 ${task.task_id}: ${task.title} [${task.status}]`);
      }
      if (incompleteTasks.length > 5) {
        console.log(`    ... and ${incompleteTasks.length - 5} more`);
      }
    }
    console.log("");
    console.log(Formatter.info("Options:"));
    console.log("  - Use --force to complete anyway");
    console.log("  - Use --auto-complete-children to complete all child items");
    console.log("  - Complete child items manually first");
    throw new Error("Cannot complete epic with incomplete children without --force or --auto-complete-children");
  }
  const updates = {
    status: "completed",
    completion_percentage: 100,
    updated_date: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (options.actualTokens !== void 0) {
    updates.actual_tokens = parseInt(options.actualTokens.toString(), 10);
  }
  const childUpdates = [];
  if (options.autoCompleteChildren) {
    for (const issue of incompleteIssues) {
      childUpdates.push({
        type: "issue",
        id: issue.issue_id,
        filePath: issue.file_path,
        updates: {
          status: "completed",
          completion_percentage: 100,
          updated_date: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    }
    for (const task of incompleteTasks) {
      childUpdates.push({
        type: "task",
        id: task.task_id,
        filePath: task.file_path,
        updates: {
          status: "completed",
          updated_date: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    }
  }
  console.log(Formatter.info(`${options.dryRun ? "Dry run - " : ""}Would complete:`));
  console.log(`  Epic: ${epic.epic_id} - ${epic.title}`);
  console.log(`    Status: ${epic.status} \u2192 completed`);
  console.log(`    Progress: ${epic.completion_percentage || 0}% \u2192 100%`);
  if (options.actualTokens !== void 0) {
    console.log(`    Actual Tokens: ${epic.actual_tokens || 0} \u2192 ${options.actualTokens}`);
  }
  if (childUpdates.length > 0) {
    console.log(`  Child Items (${childUpdates.length}):`);
    for (const child of childUpdates) {
      console.log(`    \u2022 ${child.id}: ${child.type} \u2192 completed`);
    }
  }
  if (options.dryRun) {
    return;
  }
  try {
    const updatedEpic = parser.updateFile(epic.file_path, updates);
    for (const child of childUpdates) {
      parser.updateFile(child.filePath, child.updates);
    }
    relationshipManager.rebuildCache();
    console.log(Formatter.success(`Epic completed successfully!`));
    console.log(Formatter.info(`Epic ID: ${epicId}`));
    console.log(Formatter.info(`Title: ${updatedEpic.title}`));
    console.log(Formatter.info(`Status: ${updatedEpic.status}`));
    console.log(Formatter.info(`Progress: ${updatedEpic.completion_percentage}%`));
    if (updatedEpic.actual_tokens) {
      console.log(Formatter.info(`Actual Tokens: ${updatedEpic.actual_tokens}`));
      if (updatedEpic.estimated_tokens > 0) {
        const efficiency = updatedEpic.actual_tokens / updatedEpic.estimated_tokens;
        const efficiencyDisplay = efficiency <= 1 ? Formatter.success(`${(efficiency * 100).toFixed(1)}%`) : Formatter.warning(`${(efficiency * 100).toFixed(1)}%`);
        console.log(Formatter.info(`Token Efficiency: ${efficiencyDisplay}`));
      }
    }
    if (childUpdates.length > 0) {
      console.log(Formatter.info(`Also completed ${childUpdates.length} child items.`));
    }
    console.log("");
    console.log(Formatter.success("\u{1F389} Epic completion summary:"));
    console.log(`  \u2022 ${issues.length} issues total`);
    console.log(`  \u2022 ${tasks.length} tasks total`);
    console.log(`  \u2022 Completed on ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`);
    if (options.completionNotes) {
      console.log(`  \u2022 Notes: ${options.completionNotes}`);
    }
  } catch (error) {
    throw new Error(`Failed to update files: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
var import_commander21;
var init_complete = __esm({
  "src/commands/epic/complete.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander21 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createEpicCompleteCommand, "createEpicCompleteCommand");
    __name(completeEpic, "completeEpic");
  }
});

// src/commands/epic.ts
function createEpicCommand() {
  const cmd = new import_commander22.Command("epic");
  cmd.description("Manage epics (top-level organizational units)").addCommand(createEpicCreateCommand()).addCommand(createEpicListCommand()).addCommand(createEpicShowCommand()).addCommand(createEpicUpdateCommand()).addCommand(createEpicDeleteCommand()).addCommand(createEpicCompleteCommand());
  return cmd;
}
var import_commander22;
var init_epic = __esm({
  "src/commands/epic.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander22 = require("commander");
    init_create();
    init_list();
    init_show2();
    init_update();
    init_delete();
    init_complete();
    __name(createEpicCommand, "createEpicCommand");
  }
});

// src/commands/issue/create.ts
function createIssueCreateCommand() {
  const cmd = new import_commander23.Command("create");
  cmd.description("Create a new issue within an epic").argument("<title>", "issue title").option("-e, --epic <epic-id>", "parent epic ID (required for issue creation)").option("-d, --description <text>", "issue description").option("-a, --assignee <username>", "assignee username").option("-p, --priority <level>", "priority level (low|medium|high|critical)", "medium").option("-s, --status <status>", "initial status (planning|active|completed|archived)", "planning").option("-t, --template <name>", "template to use", "default").option("--estimated-tokens <number>", "estimated token usage", "0").option("--tags <tags>", "comma-separated tags").option("-m, --milestone <name>", "milestone name").option("--dependencies <ids>", "comma-separated dependency IDs").option("--dry-run", "show what would be created without creating").action(async (title, options) => {
    try {
      await createIssue(title, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to create issue: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function createIssue(title, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const idGenerator = new IdGenerator();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  if (!options.epic) {
    throw new Error("Epic ID is required for issue creation. Use -e or --epic to specify the parent epic ID.");
  }
  const epicHierarchy = relationshipManager.getEpicHierarchy(options.epic);
  if (!epicHierarchy) {
    throw new Error(`Epic not found: ${options.epic}`);
  }
  const issueId = idGenerator.generateIssueId(options.epic, title);
  const template = configManager.getTemplateWithFallback("issue", options.template || "default");
  if (!template) {
    throw new Error(`Issue template '${options.template || "default"}' not found`);
  }
  const tags = options.tags ? options.tags.split(",").map((tag) => tag.trim()) : [];
  const dependencies = options.dependencies ? options.dependencies.split(",").map((dep) => dep.trim()) : [];
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const issueFrontmatter = {
    issue_id: issueId,
    epic_id: options.epic,
    title,
    description: options.description || template.frontmatter_template.description || "",
    status: options.status || "planning",
    priority: options.priority || "medium",
    assignee: options.assignee || config.default_assignee || "unassigned",
    created_date: now,
    updated_date: now,
    estimated_tokens: parseInt(options.estimatedTokens || "0", 10),
    actual_tokens: 0,
    ai_context: template.ai_context_defaults || config.ai_context_templates || [],
    sync_status: "local",
    related_tasks: [],
    related_issues: [],
    tags: tags.length > 0 ? tags : void 0,
    milestone: options.milestone,
    dependencies: dependencies.length > 0 ? dependencies : void 0,
    completion_percentage: 0,
    blocked_by: [],
    blocks: []
  };
  const content = template.content_template.replace(/\{\{title\}\}/g, title).replace(/\{\{description\}\}/g, issueFrontmatter.description);
  const filename = `${issueId}-${title.toLowerCase().replace(/[^a-z0-9]+/g, "-")}${config.naming_conventions.file_extension}`;
  const filePath = path13.join(paths.issuesDir, filename);
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - Issue would be created with:"));
    console.log(Formatter.debug(`File: ${filePath}`));
    console.log(Formatter.debug(`Issue ID: ${issueId}`));
    console.log(Formatter.debug(`Epic ID: ${options.epic}`));
    console.log(Formatter.debug(`Title: ${title}`));
    console.log(Formatter.debug(`Status: ${issueFrontmatter.status}`));
    console.log(Formatter.debug(`Priority: ${issueFrontmatter.priority}`));
    console.log(Formatter.debug(`Assignee: ${issueFrontmatter.assignee}`));
    if (tags.length > 0) {
      console.log(Formatter.debug(`Tags: ${tags.join(", ")}`));
    }
    if (dependencies.length > 0) {
      console.log(Formatter.debug(`Dependencies: ${dependencies.join(", ")}`));
    }
    return;
  }
  if (fs14.existsSync(filePath)) {
    throw new Error(`Issue file already exists: ${filePath}`);
  }
  parser.writeIssue(filePath, issueFrontmatter, content);
  const epic = epicHierarchy.epic;
  const updatedRelatedIssues = [...epic.related_issues || [], issueId];
  parser.updateFile(epic.file_path, { related_issues: updatedRelatedIssues });
  try {
    const indexManager = new TrackdownIndexManager(config, paths.projectRoot, cliTasksDir);
    await indexManager.updateItem("issue", issueId);
    await indexManager.updateItem("epic", options.epic);
  } catch (error) {
    console.warn(Formatter.warning(`Index update failed (non-critical): ${error instanceof Error ? error.message : "Unknown error"}`));
  }
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`Issue created successfully!`));
  console.log(Formatter.info(`Issue ID: ${issueId}`));
  console.log(Formatter.info(`Epic ID: ${options.epic}`));
  console.log(Formatter.info(`File: ${filePath}`));
  console.log(Formatter.info(`Title: ${title}`));
  console.log(Formatter.info(`Status: ${issueFrontmatter.status}`));
  console.log(Formatter.info(`Priority: ${issueFrontmatter.priority}`));
  console.log(Formatter.info(`Assignee: ${issueFrontmatter.assignee}`));
  if (tags.length > 0) {
    console.log(Formatter.info(`Tags: ${tags.join(", ")}`));
  }
  if (dependencies.length > 0) {
    console.log(Formatter.info(`Dependencies: ${dependencies.join(", ")}`));
  }
  if (options.milestone) {
    console.log(Formatter.info(`Milestone: ${options.milestone}`));
  }
  console.log("");
  console.log(Formatter.success(`Issue added to epic "${epic.title}"`));
}
var import_commander23, path13, fs14;
var init_create2 = __esm({
  "src/commands/issue/create.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander23 = require("commander");
    path13 = __toESM(require("path"), 1);
    fs14 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_simple_id_generator();
    init_relationship_manager();
    init_trackdown_index_manager();
    init_formatter();
    __name(createIssueCreateCommand, "createIssueCreateCommand");
    __name(createIssue, "createIssue");
  }
});

// src/commands/issue/list.ts
function createIssueListCommand() {
  const cmd = new import_commander24.Command("list");
  cmd.description("List issues with filtering options").option("--status <status>", "filter by status (todo|in-progress|done|blocked)").option("--priority <priority>", "filter by priority (low|medium|high|critical)").option("--assignee <assignee>", "filter by assignee").option("--epic <epic-id>", "filter by epic ID").option("--tags <tags...>", "filter by tags").option("-f, --format <type>", "output format (table|json|yaml)", "table").option("--limit <number>", "limit number of results", "50").option("--offset <number>", "offset for pagination", "0").option("--active", "show only active issues (equivalent to --status active)").action(async (options) => {
    try {
      await listIssues(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to list issues: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function listIssues(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  let issues = relationshipManager.getAllIssues();
  if (options.active) {
    issues = issues.filter((issue) => issue.status === "active");
  } else if (options.status) {
    issues = issues.filter((issue) => issue.status === options.status);
  }
  if (options.priority) {
    issues = issues.filter((issue) => issue.priority === options.priority);
  }
  if (options.assignee) {
    issues = issues.filter((issue) => issue.assignee === options.assignee);
  }
  if (options.epic) {
    issues = issues.filter((issue) => issue.epic_id === options.epic);
  }
  if (options.tags && options.tags.length > 0) {
    issues = issues.filter(
      (issue) => issue.tags && options.tags.some((tag) => issue.tags.includes(tag))
    );
  }
  const limit = parseInt(options.limit || "50");
  const offset = parseInt(options.offset || "0");
  const paginatedIssues = issues.slice(offset, offset + limit);
  switch (options.format) {
    case "json":
      console.log(JSON.stringify(paginatedIssues, null, 2));
      break;
    case "yaml":
      const YAML6 = await import("yaml");
      console.log(YAML6.stringify(paginatedIssues));
      break;
    default:
      await displayIssuesTable(paginatedIssues, issues.length, offset, limit);
  }
}
async function displayIssuesTable(issues, totalCount, offset, limit) {
  if (issues.length === 0) {
    console.log(Formatter.info("No issues found matching the criteria"));
    return;
  }
  console.log(Formatter.success(`
=== ISSUES (${issues.length}/${totalCount}) ===`));
  if (totalCount > limit) {
    console.log(Formatter.info(`Showing ${offset + 1}-${Math.min(offset + limit, totalCount)} of ${totalCount} issues`));
  }
  console.log("");
  const headers = ["ID", "Title", "Status", "Priority", "Epic", "Assignee", "Updated"];
  const columnWidths = [12, 40, 12, 10, 12, 15, 12];
  const headerRow = headers.map((header, i) => header.padEnd(columnWidths[i])).join(" ");
  console.log(Formatter.success(headerRow));
  console.log(Formatter.success("-".repeat(headerRow.length)));
  for (const issue of issues) {
    const row = [
      issue.issue_id || "N/A",
      truncate(issue.title || "Untitled", columnWidths[1]),
      getStatusDisplay4(issue.status),
      getPriorityDisplay4(issue.priority),
      issue.epic_id || "N/A",
      issue.assignee || "Unassigned",
      formatDate2(issue.updated_date)
    ];
    const formattedRow = row.map((cell, i) => cell.toString().padEnd(columnWidths[i])).join(" ");
    console.log(formattedRow);
  }
  console.log("");
  if (totalCount > limit) {
    const nextOffset = offset + limit;
    const hasNext = nextOffset < totalCount;
    const prevOffset = Math.max(0, offset - limit);
    const hasPrev = offset > 0;
    console.log(Formatter.info("Pagination:"));
    if (hasPrev) {
      console.log(`  Previous: aitrackdown issue list --offset ${prevOffset} --limit ${limit}`);
    }
    if (hasNext) {
      console.log(`  Next: aitrackdown issue list --offset ${nextOffset} --limit ${limit}`);
    }
    console.log("");
  }
}
function getStatusDisplay4(status) {
  const statusColors = {
    "todo": /* @__PURE__ */ __name((text) => Formatter.info(text), "todo"),
    "in-progress": /* @__PURE__ */ __name((text) => Formatter.warning(text), "in-progress"),
    "done": /* @__PURE__ */ __name((text) => Formatter.success(text), "done"),
    "blocked": /* @__PURE__ */ __name((text) => Formatter.error(text), "blocked")
  };
  const colorFn = statusColors[status] || ((text) => text);
  return colorFn(status.toUpperCase());
}
function getPriorityDisplay4(priority) {
  const priorityColors = {
    "critical": /* @__PURE__ */ __name((text) => Formatter.error(text), "critical"),
    "high": /* @__PURE__ */ __name((text) => Formatter.warning(text), "high"),
    "medium": /* @__PURE__ */ __name((text) => Formatter.info(text), "medium"),
    "low": /* @__PURE__ */ __name((text) => Formatter.debug(text), "low")
  };
  const colorFn = priorityColors[priority] || ((text) => text);
  return colorFn(priority.toUpperCase());
}
function formatDate2(dateString) {
  if (!dateString) return "N/A";
  const date = new Date(dateString);
  return date.toLocaleDateString();
}
function truncate(text, maxLength) {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + "...";
}
var import_commander24;
var init_list2 = __esm({
  "src/commands/issue/list.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander24 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    __name(createIssueListCommand, "createIssueListCommand");
    __name(listIssues, "listIssues");
    __name(displayIssuesTable, "displayIssuesTable");
    __name(getStatusDisplay4, "getStatusDisplay");
    __name(getPriorityDisplay4, "getPriorityDisplay");
    __name(formatDate2, "formatDate");
    __name(truncate, "truncate");
  }
});

// src/commands/issue/show.ts
function createIssueShowCommand() {
  const cmd = new import_commander25.Command("show");
  cmd.description("Show detailed information about an issue").argument("<issue-id>", "issue ID to show").action(async (issueId) => {
    console.log(Formatter.info(`Issue show command not yet implemented for ${issueId}`));
  });
  return cmd;
}
var import_commander25;
var init_show3 = __esm({
  "src/commands/issue/show.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander25 = require("commander");
    init_formatter();
    __name(createIssueShowCommand, "createIssueShowCommand");
  }
});

// src/commands/issue/update.ts
function createIssueUpdateCommand() {
  const cmd = new import_commander26.Command("update");
  cmd.description("Update an existing issue").argument("<issue-id>", "issue ID to update").action(async (issueId) => {
    console.log(Formatter.info(`Issue update command not yet implemented for ${issueId}`));
  });
  return cmd;
}
var import_commander26;
var init_update2 = __esm({
  "src/commands/issue/update.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander26 = require("commander");
    init_formatter();
    __name(createIssueUpdateCommand, "createIssueUpdateCommand");
  }
});

// src/commands/issue/delete.ts
function createIssueDeleteCommand() {
  const cmd = new import_commander27.Command("delete");
  cmd.description("Delete an issue").argument("<issue-id>", "issue ID to delete").action(async (issueId) => {
    console.log(Formatter.info(`Issue delete command not yet implemented for ${issueId}`));
  });
  return cmd;
}
var import_commander27;
var init_delete2 = __esm({
  "src/commands/issue/delete.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander27 = require("commander");
    init_formatter();
    __name(createIssueDeleteCommand, "createIssueDeleteCommand");
  }
});

// src/commands/issue/complete.ts
function createIssueCompleteCommand() {
  const cmd = new import_commander28.Command("complete");
  cmd.description("Mark an issue as completed").argument("<issue-id>", "issue ID to complete").option("-f, --force", "complete even if tasks are not completed").option("--actual-tokens <number>", "set actual token usage").option("--completion-notes <text>", "add completion notes").option("--auto-complete-tasks", "automatically complete all child tasks").option("--dry-run", "show what would be completed without completing").action(async (issueId, options) => {
    try {
      await completeIssue(issueId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to complete issue: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function completeIssue(issueId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  const hierarchy = relationshipManager.getIssueHierarchy(issueId);
  if (!hierarchy) {
    throw new Error(`Issue not found: ${issueId}`);
  }
  const { issue, tasks } = hierarchy;
  if (issue.status === "completed") {
    console.log(Formatter.warning(`Issue ${issueId} is already completed.`));
    return;
  }
  const incompleteTasks = tasks.filter((task) => task.status !== "completed");
  console.log(Formatter.info(`Issue: ${issue.title}`));
  console.log(Formatter.info(`Current Status: ${issue.status}`));
  console.log("");
  const taskCompletionRate = tasks.length > 0 ? (tasks.length - incompleteTasks.length) / tasks.length * 100 : 100;
  console.log(Formatter.success("Completion Status:"));
  console.log(`  Tasks: ${tasks.length - incompleteTasks.length}/${tasks.length} completed (${taskCompletionRate.toFixed(1)}%)`);
  console.log("");
  if (incompleteTasks.length > 0 && !options.force && !options.autoCompleteTasks) {
    console.log(Formatter.warning("Issue has incomplete tasks:"));
    for (const task of incompleteTasks.slice(0, 5)) {
      console.log(`    \u2022 ${task.task_id}: ${task.title} [${task.status}]`);
    }
    if (incompleteTasks.length > 5) {
      console.log(`    ... and ${incompleteTasks.length - 5} more`);
    }
    console.log("");
    console.log(Formatter.info("Options:"));
    console.log("  - Use --force to complete anyway");
    console.log("  - Use --auto-complete-tasks to complete all tasks");
    console.log("  - Complete tasks manually first");
    throw new Error("Cannot complete issue with incomplete tasks without --force or --auto-complete-tasks");
  }
  const updates = {
    status: "completed",
    completion_percentage: 100,
    updated_date: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (options.actualTokens !== void 0) {
    updates.actual_tokens = parseInt(options.actualTokens.toString(), 10);
  }
  const taskUpdates = [];
  if (options.autoCompleteTasks) {
    for (const task of incompleteTasks) {
      taskUpdates.push({
        id: task.task_id,
        filePath: task.file_path,
        updates: {
          status: "completed",
          updated_date: (/* @__PURE__ */ new Date()).toISOString()
        }
      });
    }
  }
  console.log(Formatter.info(`${options.dryRun ? "Dry run - " : ""}Would complete:`));
  console.log(`  Issue: ${issue.issue_id} - ${issue.title}`);
  console.log(`    Status: ${issue.status} \u2192 completed`);
  console.log(`    Progress: ${issue.completion_percentage || 0}% \u2192 100%`);
  if (options.actualTokens !== void 0) {
    console.log(`    Actual Tokens: ${issue.actual_tokens || 0} \u2192 ${options.actualTokens}`);
  }
  if (taskUpdates.length > 0) {
    console.log(`  Tasks (${taskUpdates.length}):`);
    for (const task of taskUpdates) {
      console.log(`    \u2022 ${task.id}: \u2192 completed`);
    }
  }
  if (options.dryRun) {
    return;
  }
  try {
    const updatedIssue = parser.updateFile(issue.file_path, updates);
    for (const task of taskUpdates) {
      parser.updateFile(task.filePath, task.updates);
    }
    relationshipManager.rebuildCache();
    console.log(Formatter.success(`Issue completed successfully!`));
    console.log(Formatter.info(`Issue ID: ${issueId}`));
    console.log(Formatter.info(`Title: ${updatedIssue.title}`));
    console.log(Formatter.info(`Status: ${updatedIssue.status}`));
    console.log(Formatter.info(`Progress: ${updatedIssue.completion_percentage}%`));
    if (updatedIssue.actual_tokens) {
      console.log(Formatter.info(`Actual Tokens: ${updatedIssue.actual_tokens}`));
      if (updatedIssue.estimated_tokens > 0) {
        const efficiency = updatedIssue.actual_tokens / updatedIssue.estimated_tokens;
        const efficiencyDisplay = efficiency <= 1 ? Formatter.success(`${(efficiency * 100).toFixed(1)}%`) : Formatter.warning(`${(efficiency * 100).toFixed(1)}%`);
        console.log(Formatter.info(`Token Efficiency: ${efficiencyDisplay}`));
      }
    }
    if (taskUpdates.length > 0) {
      console.log(Formatter.info(`Also completed ${taskUpdates.length} tasks.`));
    }
    console.log("");
    console.log(Formatter.success("\u{1F389} Issue completion summary:"));
    console.log(`  \u2022 ${tasks.length} tasks total`);
    console.log(`  \u2022 Completed on ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`);
    if (options.completionNotes) {
      console.log(`  \u2022 Notes: ${options.completionNotes}`);
    }
  } catch (error) {
    throw new Error(`Failed to update files: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
var import_commander28;
var init_complete2 = __esm({
  "src/commands/issue/complete.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander28 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createIssueCompleteCommand, "createIssueCompleteCommand");
    __name(completeIssue, "completeIssue");
  }
});

// src/commands/issue/assign.ts
function createIssueAssignCommand() {
  const cmd = new import_commander29.Command("assign");
  cmd.description("Assign an issue to a user").argument("<issue-id>", "issue ID to assign").argument("<assignee>", "username to assign to").option("--dry-run", "show what would be assigned without assigning").action(async (issueId, assignee, options) => {
    try {
      await assignIssue(issueId, assignee, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to assign issue: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function assignIssue(issueId, assignee, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  const hierarchy = relationshipManager.getIssueHierarchy(issueId);
  if (!hierarchy) {
    throw new Error(`Issue not found: ${issueId}`);
  }
  const issue = hierarchy.issue;
  const currentAssignee = issue.assignee;
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - Issue would be assigned:"));
    console.log(Formatter.debug(`Issue ID: ${issueId}`));
    console.log(Formatter.debug(`Title: ${issue.title}`));
    console.log(Formatter.debug(`Current Assignee: ${currentAssignee}`));
    console.log(Formatter.debug(`New Assignee: ${assignee}`));
    return;
  }
  if (currentAssignee === assignee) {
    console.log(Formatter.warning(`Issue ${issueId} is already assigned to ${assignee}`));
    return;
  }
  const updatedIssue = parser.updateFile(issue.file_path, {
    assignee,
    updated_date: (/* @__PURE__ */ new Date()).toISOString()
  });
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`Issue assigned successfully!`));
  console.log(Formatter.info(`Issue ID: ${issueId}`));
  console.log(Formatter.info(`Title: ${issue.title}`));
  console.log(Formatter.info(`Previous Assignee: ${currentAssignee}`));
  console.log(Formatter.info(`New Assignee: ${assignee}`));
}
var import_commander29;
var init_assign = __esm({
  "src/commands/issue/assign.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander29 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createIssueAssignCommand, "createIssueAssignCommand");
    __name(assignIssue, "assignIssue");
  }
});

// src/commands/issue.ts
function createIssueCommand() {
  const cmd = new import_commander30.Command("issue");
  cmd.description("Manage issues (mid-level work units within epics)").alias("issues").addCommand(createIssueCreateCommand()).addCommand(createIssueListCommand()).addCommand(createIssueShowCommand()).addCommand(createIssueUpdateCommand()).addCommand(createIssueDeleteCommand()).addCommand(createIssueCompleteCommand()).addCommand(createIssueAssignCommand());
  return cmd;
}
var import_commander30;
var init_issue = __esm({
  "src/commands/issue.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander30 = require("commander");
    init_create2();
    init_list2();
    init_show3();
    init_update2();
    init_delete2();
    init_complete2();
    init_assign();
    __name(createIssueCommand, "createIssueCommand");
  }
});

// src/commands/task/create.ts
function createTaskCreateCommand() {
  const cmd = new import_commander31.Command("create");
  cmd.description("Create a new task within an issue").argument("<title>", "task title").requiredOption("-i, --issue <issue-id>", "parent issue ID").option("-d, --description <text>", "task description").option("-a, --assignee <username>", "assignee username").option("-p, --priority <level>", "priority level (low|medium|high|critical)", "medium").option("-s, --status <status>", "initial status (planning|active|completed|archived)", "planning").option("-t, --template <name>", "template to use", "default").option("--estimated-tokens <number>", "estimated token usage", "0").option("--time-estimate <duration>", "estimated time (e.g., 2h, 30m, 1d)").option("--tags <tags>", "comma-separated tags").option("--dependencies <ids>", "comma-separated dependency IDs").option("--dry-run", "show what would be created without creating").action(async (title, options) => {
    try {
      await createTask(title, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to create task: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function createTask(title, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const idGenerator = new IdGenerator();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const issueHierarchy = relationshipManager.getIssueHierarchy(options.issue);
  if (!issueHierarchy) {
    throw new Error(`Issue not found: ${options.issue}`);
  }
  const issue = issueHierarchy.issue;
  const epicId = issue.epic_id;
  const taskId = idGenerator.generateTaskId(options.issue, title);
  const template = configManager.getTemplateWithFallback("task", options.template || "default");
  if (!template) {
    throw new Error(`Task template '${options.template || "default"}' not found`);
  }
  const tags = options.tags ? options.tags.split(",").map((tag) => tag.trim()) : [];
  const dependencies = options.dependencies ? options.dependencies.split(",").map((dep) => dep.trim()) : [];
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const taskFrontmatter = {
    task_id: taskId,
    issue_id: options.issue,
    epic_id: epicId,
    title,
    description: options.description || template.frontmatter_template.description || "",
    status: options.status || "planning",
    priority: options.priority || "medium",
    assignee: options.assignee || config.default_assignee || "unassigned",
    created_date: now,
    updated_date: now,
    estimated_tokens: parseInt(options.estimatedTokens || "0", 10),
    actual_tokens: 0,
    ai_context: template.ai_context_defaults || config.ai_context_templates || [],
    sync_status: "local",
    subtasks: [],
    parent_task: void 0,
    tags: tags.length > 0 ? tags : void 0,
    dependencies: dependencies.length > 0 ? dependencies : void 0,
    time_estimate: options.timeEstimate,
    time_spent: void 0,
    blocked_by: [],
    blocks: []
  };
  const content = template.content_template.replace(/\{\{title\}\}/g, title).replace(/\{\{description\}\}/g, taskFrontmatter.description);
  const filename = `${taskId}-${title.toLowerCase().replace(/[^a-z0-9]+/g, "-")}${config.naming_conventions.file_extension}`;
  const filePath = path14.join(paths.tasksDir, filename);
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - Task would be created with:"));
    console.log(Formatter.debug(`File: ${filePath}`));
    console.log(Formatter.debug(`Task ID: ${taskId}`));
    console.log(Formatter.debug(`Issue ID: ${options.issue}`));
    console.log(Formatter.debug(`Epic ID: ${epicId}`));
    console.log(Formatter.debug(`Title: ${title}`));
    console.log(Formatter.debug(`Status: ${taskFrontmatter.status}`));
    console.log(Formatter.debug(`Priority: ${taskFrontmatter.priority}`));
    console.log(Formatter.debug(`Assignee: ${taskFrontmatter.assignee}`));
    if (options.timeEstimate) {
      console.log(Formatter.debug(`Time Estimate: ${options.timeEstimate}`));
    }
    if (tags.length > 0) {
      console.log(Formatter.debug(`Tags: ${tags.join(", ")}`));
    }
    if (dependencies.length > 0) {
      console.log(Formatter.debug(`Dependencies: ${dependencies.join(", ")}`));
    }
    return;
  }
  if (fs15.existsSync(filePath)) {
    throw new Error(`Task file already exists: ${filePath}`);
  }
  parser.writeTask(filePath, taskFrontmatter, content);
  const updatedRelatedTasks = [...issue.related_tasks || [], taskId];
  parser.updateFile(issue.file_path, { related_tasks: updatedRelatedTasks });
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`Task created successfully!`));
  console.log(Formatter.info(`Task ID: ${taskId}`));
  console.log(Formatter.info(`Issue ID: ${options.issue}`));
  console.log(Formatter.info(`Epic ID: ${epicId}`));
  console.log(Formatter.info(`File: ${filePath}`));
  console.log(Formatter.info(`Title: ${title}`));
  console.log(Formatter.info(`Status: ${taskFrontmatter.status}`));
  console.log(Formatter.info(`Priority: ${taskFrontmatter.priority}`));
  console.log(Formatter.info(`Assignee: ${taskFrontmatter.assignee}`));
  if (options.timeEstimate) {
    console.log(Formatter.info(`Time Estimate: ${options.timeEstimate}`));
  }
  if (tags.length > 0) {
    console.log(Formatter.info(`Tags: ${tags.join(", ")}`));
  }
  if (dependencies.length > 0) {
    console.log(Formatter.info(`Dependencies: ${dependencies.join(", ")}`));
  }
  console.log("");
  console.log(Formatter.success(`Task added to issue "${issue.title}"`));
}
var import_commander31, path14, fs15;
var init_create3 = __esm({
  "src/commands/task/create.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander31 = require("commander");
    path14 = __toESM(require("path"), 1);
    fs15 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_simple_id_generator();
    init_relationship_manager();
    init_formatter();
    __name(createTaskCreateCommand, "createTaskCreateCommand");
    __name(createTask, "createTask");
  }
});

// src/commands/task/list.ts
function createTaskListCommand() {
  const cmd = new import_commander32.Command("list");
  cmd.description("List tasks with filtering options").option("-s, --status <statuses>", "filter by status (comma-separated)").option("-p, --priority <priorities>", "filter by priority (comma-separated)").option("-a, --assignee <username>", "filter by assignee").option("-i, --issue <issue-id>", "filter by issue ID").option("-e, --epic <epic-id>", "filter by epic ID").option("-t, --tags <tags>", "filter by tags (comma-separated)").option("--search <term>", "search in title, description, and content").option("-f, --format <type>", "output format (table|json|yaml)", "table").option("--sort-by <field>", "sort by field (created|updated|title|priority|status)", "created").option("--sort-order <order>", "sort order (asc|desc)", "desc").option("-l, --limit <number>", "limit number of results").option("--show-time", "show time estimates and spent").action(async (options) => {
    try {
      await listTasks(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to list tasks: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function listTasks(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const filters = {};
  if (options.status) {
    const statuses = options.status.split(",").map((s) => s.trim());
    filters.status = statuses.length === 1 ? statuses[0] : statuses;
  }
  if (options.priority) {
    const priorities = options.priority.split(",").map((p) => p.trim());
    filters.priority = priorities.length === 1 ? priorities[0] : priorities;
  }
  if (options.assignee) {
    filters.assignee = options.assignee;
  }
  if (options.tags) {
    const tags = options.tags.split(",").map((t) => t.trim());
    filters.tags = tags.length === 1 ? tags[0] : tags;
  }
  if (options.search) {
    filters.content_search = options.search;
  }
  const searchResult = relationshipManager.search(filters);
  let tasks = searchResult.items.filter(isTaskData);
  if (options.issue) {
    tasks = tasks.filter((task) => task.issue_id === options.issue);
  }
  if (options.epic) {
    tasks = tasks.filter((task) => task.epic_id === options.epic);
  }
  sortTasks(tasks, options.sortBy || "created", options.sortOrder || "desc");
  if (options.limit) {
    const limit = parseInt(options.limit.toString(), 10);
    tasks = tasks.slice(0, limit);
  }
  switch (options.format) {
    case "json":
      console.log(JSON.stringify(tasks, null, 2));
      break;
    case "yaml":
      const YAML6 = await import("yaml");
      console.log(YAML6.stringify(tasks));
      break;
    default:
      await displayTasksTable(tasks, options);
  }
}
function sortTasks(tasks, sortBy, sortOrder) {
  tasks.sort((a, b) => {
    let aVal, bVal;
    switch (sortBy) {
      case "created":
        aVal = new Date(a.created_date);
        bVal = new Date(b.created_date);
        break;
      case "updated":
        aVal = new Date(a.updated_date);
        bVal = new Date(b.updated_date);
        break;
      case "title":
        aVal = a.title.toLowerCase();
        bVal = b.title.toLowerCase();
        break;
      case "priority":
        const priorityOrder = { "critical": 4, "high": 3, "medium": 2, "low": 1 };
        aVal = priorityOrder[a.priority] || 0;
        bVal = priorityOrder[b.priority] || 0;
        break;
      case "status":
        const statusOrder = { "active": 4, "planning": 3, "completed": 2, "archived": 1 };
        aVal = statusOrder[a.status] || 0;
        bVal = statusOrder[b.status] || 0;
        break;
      default:
        aVal = a.created_date;
        bVal = b.created_date;
    }
    if (sortOrder === "asc") {
      return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
    } else {
      return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
    }
  });
}
async function displayTasksTable(tasks, options) {
  if (tasks.length === 0) {
    console.log(Formatter.info("No tasks found matching the criteria."));
    return;
  }
  console.log(Formatter.success(`Found ${tasks.length} task(s):`));
  console.log("");
  const headers = ["ID", "Title", "Status", "Priority", "Issue", "Assignee"];
  if (options.showTime) {
    headers.push("Time Est.");
    headers.push("Time Spent");
  }
  headers.push("Created");
  const colWidths = headers.map(() => 0);
  const rows = [];
  for (const task of tasks) {
    const row = [
      task.task_id,
      truncateText2(task.title, 30),
      getStatusDisplay5(task.status),
      getPriorityDisplay5(task.priority),
      task.issue_id,
      truncateText2(task.assignee, 15)
    ];
    if (options.showTime) {
      row.push(task.time_estimate || "-");
      row.push(task.time_spent || "-");
    }
    row.push(formatDate3(task.created_date));
    rows.push(row);
  }
  for (let i = 0; i < headers.length; i++) {
    colWidths[i] = Math.max(headers[i].length, ...rows.map((row) => row[i].length));
  }
  printTableRow2(headers, colWidths, true);
  printSeparator2(colWidths);
  for (const row of rows) {
    printTableRow2(row, colWidths, false);
  }
  console.log("");
  console.log(Formatter.info(`Total: ${tasks.length} task(s)`));
}
function printTableRow2(row, widths, isHeader) {
  const paddedRow = row.map((cell, i) => cell.padEnd(widths[i]));
  const rowText = paddedRow.join(" | ");
  if (isHeader) {
    console.log(Formatter.info(rowText));
  } else {
    console.log(rowText);
  }
}
function printSeparator2(widths) {
  const separator = widths.map((width) => "-".repeat(width)).join("-+-");
  console.log(separator);
}
function truncateText2(text, maxLength) {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + "...";
}
function getStatusDisplay5(status) {
  const statusColors = {
    "planning": /* @__PURE__ */ __name((text) => Formatter.info(text), "planning"),
    "active": /* @__PURE__ */ __name((text) => Formatter.success(text), "active"),
    "completed": /* @__PURE__ */ __name((text) => Formatter.success(text), "completed"),
    "archived": /* @__PURE__ */ __name((text) => Formatter.debug(text), "archived")
  };
  const colorFn = statusColors[status] || ((text) => text);
  return colorFn(status.toUpperCase());
}
function getPriorityDisplay5(priority) {
  const priorityColors = {
    "critical": /* @__PURE__ */ __name((text) => Formatter.error(text), "critical"),
    "high": /* @__PURE__ */ __name((text) => Formatter.warning(text), "high"),
    "medium": /* @__PURE__ */ __name((text) => Formatter.info(text), "medium"),
    "low": /* @__PURE__ */ __name((text) => Formatter.debug(text), "low")
  };
  const colorFn = priorityColors[priority] || ((text) => text);
  return colorFn(priority.toUpperCase());
}
function formatDate3(dateString) {
  const date = new Date(dateString);
  return date.toLocaleDateString();
}
var import_commander32;
var init_list3 = __esm({
  "src/commands/task/list.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander32 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    init_ai_trackdown();
    __name(createTaskListCommand, "createTaskListCommand");
    __name(listTasks, "listTasks");
    __name(sortTasks, "sortTasks");
    __name(displayTasksTable, "displayTasksTable");
    __name(printTableRow2, "printTableRow");
    __name(printSeparator2, "printSeparator");
    __name(truncateText2, "truncateText");
    __name(getStatusDisplay5, "getStatusDisplay");
    __name(getPriorityDisplay5, "getPriorityDisplay");
    __name(formatDate3, "formatDate");
  }
});

// src/commands/task/show.ts
function createTaskShowCommand() {
  const cmd = new import_commander33.Command("show");
  cmd.description("Show detailed information about a task").argument("<task-id>", "task ID to show").action(async (taskId) => {
    console.log(Formatter.info(`Task show command not yet implemented for ${taskId}`));
    console.log(Formatter.info("This command will display detailed task information including content, time tracking, and related items."));
  });
  return cmd;
}
var import_commander33;
var init_show4 = __esm({
  "src/commands/task/show.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander33 = require("commander");
    init_formatter();
    __name(createTaskShowCommand, "createTaskShowCommand");
  }
});

// src/commands/task/update.ts
function createTaskUpdateCommand() {
  const cmd = new import_commander34.Command("update");
  cmd.description("Update an existing task").argument("<task-id>", "task ID to update").action(async (taskId) => {
    console.log(Formatter.info(`Task update command not yet implemented for ${taskId}`));
    console.log(Formatter.info("This command will allow updating task fields like title, description, status, priority, time estimates, etc."));
  });
  return cmd;
}
var import_commander34;
var init_update3 = __esm({
  "src/commands/task/update.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander34 = require("commander");
    init_formatter();
    __name(createTaskUpdateCommand, "createTaskUpdateCommand");
  }
});

// src/commands/task/delete.ts
function createTaskDeleteCommand() {
  const cmd = new import_commander35.Command("delete");
  cmd.description("Delete a task").argument("<task-id>", "task ID to delete").action(async (taskId) => {
    console.log(Formatter.info(`Task delete command not yet implemented for ${taskId}`));
    console.log(Formatter.info("This command will safely delete tasks with appropriate confirmations and relationship cleanup."));
  });
  return cmd;
}
var import_commander35;
var init_delete3 = __esm({
  "src/commands/task/delete.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander35 = require("commander");
    init_formatter();
    __name(createTaskDeleteCommand, "createTaskDeleteCommand");
  }
});

// src/commands/task/complete.ts
function createTaskCompleteCommand() {
  const cmd = new import_commander36.Command("complete");
  cmd.description("Mark a task as completed").argument("<task-id>", "task ID to complete").option("--actual-tokens <number>", "set actual token usage").option("--time-spent <duration>", "time spent on task (e.g., 2h, 30m, 1d)").option("--completion-notes <text>", "add completion notes").option("--dry-run", "show what would be completed without completing").action(async (taskId, options) => {
    try {
      await completeTask(taskId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to complete task: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function completeTask(taskId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  const allTasks = relationshipManager.search({ content_search: taskId }).items.filter(
    (item) => "task_id" in item && item.task_id === taskId
  );
  if (allTasks.length === 0) {
    throw new Error(`Task not found: ${taskId}`);
  }
  const task = allTasks[0];
  if (task.status === "completed") {
    console.log(Formatter.warning(`Task ${taskId} is already completed.`));
    return;
  }
  console.log(Formatter.info(`Task: ${task.title}`));
  console.log(Formatter.info(`Current Status: ${task.status}`));
  console.log("");
  const updates = {
    status: "completed",
    updated_date: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (options.actualTokens !== void 0) {
    updates.actual_tokens = parseInt(options.actualTokens.toString(), 10);
  }
  if (options.timeSpent) {
    updates.time_spent = options.timeSpent;
  }
  console.log(Formatter.info(`${options.dryRun ? "Dry run - " : ""}Would complete:`));
  console.log(`  Task: ${task.task_id} - ${task.title}`);
  console.log(`    Status: ${task.status} \u2192 completed`);
  if (options.actualTokens !== void 0) {
    console.log(`    Actual Tokens: ${task.actual_tokens || 0} \u2192 ${options.actualTokens}`);
  }
  if (options.timeSpent) {
    console.log(`    Time Spent: ${task.time_spent || "none"} \u2192 ${options.timeSpent}`);
  }
  if (options.dryRun) {
    return;
  }
  try {
    const updatedTask = parser.updateFile(task.file_path, updates);
    relationshipManager.rebuildCache();
    console.log(Formatter.success(`Task completed successfully!`));
    console.log(Formatter.info(`Task ID: ${taskId}`));
    console.log(Formatter.info(`Title: ${updatedTask.title}`));
    console.log(Formatter.info(`Status: ${updatedTask.status}`));
    if (updatedTask.actual_tokens) {
      console.log(Formatter.info(`Actual Tokens: ${updatedTask.actual_tokens}`));
      if (updatedTask.estimated_tokens > 0) {
        const efficiency = updatedTask.actual_tokens / updatedTask.estimated_tokens;
        const efficiencyDisplay = efficiency <= 1 ? Formatter.success(`${(efficiency * 100).toFixed(1)}%`) : Formatter.warning(`${(efficiency * 100).toFixed(1)}%`);
        console.log(Formatter.info(`Token Efficiency: ${efficiencyDisplay}`));
      }
    }
    if (updatedTask.time_spent) {
      console.log(Formatter.info(`Time Spent: ${updatedTask.time_spent}`));
    }
    console.log("");
    console.log(Formatter.success("\u2705 Task completed!"));
    console.log(`  \u2022 Completed on ${(/* @__PURE__ */ new Date()).toLocaleDateString()}`);
    if (options.completionNotes) {
      console.log(`  \u2022 Notes: ${options.completionNotes}`);
    }
    if (updatedTask.time_estimate && updatedTask.time_spent) {
      console.log(`  \u2022 Time: ${updatedTask.time_spent} (estimated: ${updatedTask.time_estimate})`);
    }
  } catch (error) {
    throw new Error(`Failed to update task: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
var import_commander36;
var init_complete3 = __esm({
  "src/commands/task/complete.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander36 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createTaskCompleteCommand, "createTaskCompleteCommand");
    __name(completeTask, "completeTask");
  }
});

// src/commands/task.ts
function createTaskCommand() {
  const cmd = new import_commander37.Command("task");
  cmd.description("Manage tasks (granular work items within issues)").alias("tasks").addCommand(createTaskCreateCommand()).addCommand(createTaskListCommand()).addCommand(createTaskShowCommand()).addCommand(createTaskUpdateCommand()).addCommand(createTaskDeleteCommand()).addCommand(createTaskCompleteCommand());
  return cmd;
}
var import_commander37;
var init_task = __esm({
  "src/commands/task.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander37 = require("commander");
    init_create3();
    init_list3();
    init_show4();
    init_update3();
    init_delete3();
    init_complete3();
    __name(createTaskCommand, "createTaskCommand");
  }
});

// src/commands/pr/create.ts
function createPRCreateCommand() {
  const cmd = new import_commander38.Command("create");
  cmd.description("Create a new PR within an issue").argument("<title>", "PR title").requiredOption("-i, --issue <issue-id>", "parent issue ID").option("-d, --description <text>", "PR description").option("-a, --assignee <username>", "assignee username").option("-p, --priority <level>", "priority level (low|medium|high|critical)", "medium").option("-s, --pr-status <status>", "initial PR status (draft|open|review|approved|merged|closed)", "draft").option("-t, --template <name>", "template to use", "default").option("--estimated-tokens <number>", "estimated token usage", "0").option("--tags <tags>", "comma-separated tags").option("-b, --branch-name <name>", "branch name for the PR").option("--source-branch <name>", "source branch name").option("--target-branch <name>", "target branch name (default: main)").option("--repository-url <url>", "repository URL").option("--reviewers <usernames>", "comma-separated reviewer usernames").option("--dependencies <ids>", "comma-separated dependency IDs").option("--dry-run", "show what would be created without creating").action(async (title, options) => {
    try {
      await createPR(title, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to create PR: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function createPR(title, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const idGenerator = new IdGenerator();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const issueHierarchy = relationshipManager.getIssueHierarchy(options.issue);
  if (!issueHierarchy) {
    throw new Error(`Issue not found: ${options.issue}`);
  }
  const prId = idGenerator.generatePRId(options.issue, title);
  const template = configManager.getTemplateWithFallback("pr", options.template || "default");
  if (!template) {
    throw new Error(`PR template '${options.template || "default"}' not found`);
  }
  const tags = options.tags ? options.tags.split(",").map((tag) => tag.trim()) : [];
  const reviewers = options.reviewers ? options.reviewers.split(",").map((r) => r.trim()) : [];
  const dependencies = options.dependencies ? options.dependencies.split(",").map((dep) => dep.trim()) : [];
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const prFrontmatter = {
    pr_id: prId,
    issue_id: options.issue,
    epic_id: issueHierarchy.issue.epic_id,
    title,
    description: options.description || template.frontmatter_template.description || "",
    status: "planning",
    // Keep base status as 'planning'
    pr_status: options.prStatus || "draft",
    priority: options.priority || "medium",
    assignee: options.assignee || config.default_assignee || "unassigned",
    created_date: now,
    updated_date: now,
    estimated_tokens: parseInt(options.estimatedTokens || "0", 10),
    actual_tokens: 0,
    ai_context: template.ai_context_defaults || config.ai_context_templates || [],
    sync_status: "local",
    branch_name: options.branchName,
    source_branch: options.sourceBranch,
    target_branch: options.targetBranch || "main",
    repository_url: options.repositoryUrl,
    reviewers: reviewers.length > 0 ? reviewers : void 0,
    approvals: [],
    tags: tags.length > 0 ? tags : void 0,
    dependencies: dependencies.length > 0 ? dependencies : void 0,
    blocked_by: [],
    blocks: [],
    related_prs: [],
    template_used: options.template || "default"
  };
  const content = template.content_template.replace(/\{\{title\}\}/g, title).replace(/\{\{description\}\}/g, prFrontmatter.description).replace(/\{\{issue_id\}\}/g, options.issue).replace(/\{\{branch_name\}\}/g, prFrontmatter.branch_name || "").replace(/\{\{target_branch\}\}/g, prFrontmatter.target_branch || "main");
  const filename = `${prId}-${title.toLowerCase().replace(/[^a-z0-9]+/g, "-")}${config.naming_conventions.file_extension}`;
  const filePath = path15.join(paths.prsDir, filename);
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - PR would be created with:"));
    console.log(Formatter.debug(`File: ${filePath}`));
    console.log(Formatter.debug(`PR ID: ${prId}`));
    console.log(Formatter.debug(`Issue ID: ${options.issue}`));
    console.log(Formatter.debug(`Epic ID: ${issueHierarchy.issue.epic_id}`));
    console.log(Formatter.debug(`Title: ${title}`));
    console.log(Formatter.debug(`PR Status: ${prFrontmatter.pr_status}`));
    console.log(Formatter.debug(`Priority: ${prFrontmatter.priority}`));
    console.log(Formatter.debug(`Assignee: ${prFrontmatter.assignee}`));
    console.log(Formatter.debug(`Target Branch: ${prFrontmatter.target_branch}`));
    if (prFrontmatter.branch_name) {
      console.log(Formatter.debug(`Branch Name: ${prFrontmatter.branch_name}`));
    }
    if (tags.length > 0) {
      console.log(Formatter.debug(`Tags: ${tags.join(", ")}`));
    }
    if (reviewers.length > 0) {
      console.log(Formatter.debug(`Reviewers: ${reviewers.join(", ")}`));
    }
    if (dependencies.length > 0) {
      console.log(Formatter.debug(`Dependencies: ${dependencies.join(", ")}`));
    }
    return;
  }
  if (fs16.existsSync(filePath)) {
    throw new Error(`PR file already exists: ${filePath}`);
  }
  parser.writePR(filePath, prFrontmatter, content);
  const issue = issueHierarchy.issue;
  const updatedRelatedPRs = [...issue.related_prs || [], prId];
  parser.updateFile(issue.file_path, { related_prs: updatedRelatedPRs });
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`PR created successfully!`));
  console.log(Formatter.info(`PR ID: ${prId}`));
  console.log(Formatter.info(`Issue ID: ${options.issue}`));
  console.log(Formatter.info(`Epic ID: ${issueHierarchy.issue.epic_id}`));
  console.log(Formatter.info(`File: ${filePath}`));
  console.log(Formatter.info(`Title: ${title}`));
  console.log(Formatter.info(`PR Status: ${prFrontmatter.pr_status}`));
  console.log(Formatter.info(`Priority: ${prFrontmatter.priority}`));
  console.log(Formatter.info(`Assignee: ${prFrontmatter.assignee}`));
  console.log(Formatter.info(`Target Branch: ${prFrontmatter.target_branch}`));
  if (prFrontmatter.branch_name) {
    console.log(Formatter.info(`Branch Name: ${prFrontmatter.branch_name}`));
  }
  if (tags.length > 0) {
    console.log(Formatter.info(`Tags: ${tags.join(", ")}`));
  }
  if (reviewers.length > 0) {
    console.log(Formatter.info(`Reviewers: ${reviewers.join(", ")}`));
  }
  if (dependencies.length > 0) {
    console.log(Formatter.info(`Dependencies: ${dependencies.join(", ")}`));
  }
  if (options.repositoryUrl) {
    console.log(Formatter.info(`Repository: ${options.repositoryUrl}`));
  }
  console.log("");
  console.log(Formatter.success(`PR added to issue "${issue.title}"`));
}
var import_commander38, path15, fs16;
var init_create4 = __esm({
  "src/commands/pr/create.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander38 = require("commander");
    path15 = __toESM(require("path"), 1);
    fs16 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_simple_id_generator();
    init_relationship_manager();
    init_formatter();
    __name(createPRCreateCommand, "createPRCreateCommand");
    __name(createPR, "createPR");
  }
});

// src/commands/pr/list.ts
function createPRListCommand() {
  const cmd = new import_commander39.Command("list");
  cmd.description("List PRs with filtering options").option("-s, --status <status>", "filter by base status (planning|active|completed|archived)").option("--pr-status <status>", "filter by PR status (draft|open|review|approved|merged|closed)").option("-p, --priority <level>", "filter by priority (low|medium|high|critical)").option("-a, --assignee <username>", "filter by assignee").option("-i, --issue <issue-id>", "filter by issue ID").option("-e, --epic <epic-id>", "filter by epic ID").option("-t, --tags <tags>", "filter by tags (comma-separated)").option("-r, --reviewer <username>", "filter by reviewer").option("-b, --branch <name>", "filter by branch name").option("--repository <url>", "filter by repository URL").option("-l, --limit <number>", "limit number of results (default: 50)").option("--sort-by <field>", "sort by field (created_date|updated_date|priority|pr_status|title)", "updated_date").option("--sort-order <order>", "sort order (asc|desc)", "desc").option("--show-details", "show detailed information").option("--format <format>", "output format (table|json|csv)", "table").action(async (options) => {
    try {
      await listPRs(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to list PRs: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function listPRs(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const allPRs = relationshipManager.getAllPRs();
  if (allPRs.length === 0) {
    console.log(Formatter.info("No PRs found."));
    return;
  }
  let filteredPRs = allPRs;
  if (options.status) {
    filteredPRs = filteredPRs.filter((pr) => pr.status === options.status);
  }
  if (options.prStatus) {
    filteredPRs = filteredPRs.filter((pr) => pr.pr_status === options.prStatus);
  }
  if (options.priority) {
    filteredPRs = filteredPRs.filter((pr) => pr.priority === options.priority);
  }
  if (options.assignee) {
    filteredPRs = filteredPRs.filter((pr) => pr.assignee === options.assignee);
  }
  if (options.issue) {
    filteredPRs = filteredPRs.filter((pr) => pr.issue_id === options.issue);
  }
  if (options.epic) {
    filteredPRs = filteredPRs.filter((pr) => pr.epic_id === options.epic);
  }
  if (options.tags) {
    const filterTags = options.tags.split(",").map((tag) => tag.trim());
    filteredPRs = filteredPRs.filter(
      (pr) => pr.tags && pr.tags.some((tag) => filterTags.includes(tag))
    );
  }
  if (options.reviewer) {
    filteredPRs = filteredPRs.filter(
      (pr) => pr.reviewers && pr.reviewers.includes(options.reviewer)
    );
  }
  if (options.branch) {
    filteredPRs = filteredPRs.filter(
      (pr) => {
        var _a, _b, _c;
        return ((_a = pr.branch_name) == null ? void 0 : _a.includes(options.branch)) || ((_b = pr.source_branch) == null ? void 0 : _b.includes(options.branch)) || ((_c = pr.target_branch) == null ? void 0 : _c.includes(options.branch));
      }
    );
  }
  if (options.repository) {
    filteredPRs = filteredPRs.filter(
      (pr) => {
        var _a;
        return (_a = pr.repository_url) == null ? void 0 : _a.includes(options.repository);
      }
    );
  }
  const sortField = options.sortBy || "updated_date";
  const sortOrder = options.sortOrder || "desc";
  filteredPRs.sort((a, b) => {
    let aValue;
    let bValue;
    switch (sortField) {
      case "created_date":
        aValue = new Date(a.created_date);
        bValue = new Date(b.created_date);
        break;
      case "updated_date":
        aValue = new Date(a.updated_date);
        bValue = new Date(b.updated_date);
        break;
      case "priority":
        const priorityOrder = { "critical": 4, "high": 3, "medium": 2, "low": 1 };
        aValue = priorityOrder[a.priority];
        bValue = priorityOrder[b.priority];
        break;
      case "pr_status":
        const statusOrder = { "merged": 6, "closed": 5, "approved": 4, "review": 3, "open": 2, "draft": 1 };
        aValue = statusOrder[a.pr_status];
        bValue = statusOrder[b.pr_status];
        break;
      case "title":
        aValue = a.title.toLowerCase();
        bValue = b.title.toLowerCase();
        break;
      default:
        aValue = a.updated_date;
        bValue = b.updated_date;
    }
    if (aValue < bValue) return sortOrder === "asc" ? -1 : 1;
    if (aValue > bValue) return sortOrder === "asc" ? 1 : -1;
    return 0;
  });
  const limit = parseInt(options.limit || "50", 10);
  const displayPRs = filteredPRs.slice(0, limit);
  if (options.format === "json") {
    console.log(JSON.stringify(displayPRs, null, 2));
    return;
  }
  if (options.format === "csv") {
    console.log("PR_ID,Title,PR_Status,Priority,Assignee,Issue_ID,Epic_ID,Branch_Name,Target_Branch,Created_Date,Updated_Date");
    displayPRs.forEach((pr) => {
      console.log([
        pr.pr_id,
        `"${pr.title.replace(/"/g, '""')}"`,
        pr.pr_status,
        pr.priority,
        pr.assignee,
        pr.issue_id,
        pr.epic_id,
        pr.branch_name || "",
        pr.target_branch || "",
        pr.created_date,
        pr.updated_date
      ].join(","));
    });
    return;
  }
  console.log(Formatter.header(`
\u{1F4CB} PRs (${displayPRs.length}${filteredPRs.length > limit ? ` of ${filteredPRs.length}` : ""})`));
  if (displayPRs.length === 0) {
    console.log(Formatter.info("No PRs match the specified filters."));
    return;
  }
  displayPRs.forEach((pr) => {
    const statusColor = getPRStatusColor(pr.pr_status);
    const priorityColor = getPriorityColor4(pr.priority);
    console.log(`
${Formatter.info(`${pr.pr_id}`)} ${pr.title}`);
    console.log(`  Status: ${statusColor(pr.pr_status)} | Priority: ${priorityColor(pr.priority)} | Assignee: ${pr.assignee}`);
    console.log(`  Issue: ${pr.issue_id} | Epic: ${pr.epic_id}`);
    if (pr.branch_name) {
      console.log(`  Branch: ${pr.branch_name} \u2192 ${pr.target_branch || "main"}`);
    }
    if (pr.reviewers && pr.reviewers.length > 0) {
      console.log(`  Reviewers: ${pr.reviewers.join(", ")}`);
    }
    if (pr.tags && pr.tags.length > 0) {
      console.log(`  Tags: ${pr.tags.join(", ")}`);
    }
    if (options.showDetails) {
      console.log(`  Description: ${pr.description || "No description"}`);
      console.log(`  Created: ${formatDate4(pr.created_date)} | Updated: ${formatDate4(pr.updated_date)}`);
      console.log(`  File: ${pr.file_path}`);
      if (pr.repository_url) {
        console.log(`  Repository: ${pr.repository_url}`);
      }
      if (pr.pr_number) {
        console.log(`  PR Number: #${pr.pr_number}`);
      }
    }
  });
  console.log(`
${Formatter.info("Summary:")}`);
  console.log(`  Total PRs: ${allPRs.length}`);
  console.log(`  Filtered: ${filteredPRs.length}`);
  console.log(`  Displayed: ${displayPRs.length}`);
  const statusBreakdown = {};
  filteredPRs.forEach((pr) => {
    statusBreakdown[pr.pr_status] = (statusBreakdown[pr.pr_status] || 0) + 1;
  });
  console.log(`  Status breakdown: ${Object.entries(statusBreakdown).map(([status, count]) => `${status}: ${count}`).join(", ")}`);
}
function getPRStatusColor(status) {
  switch (status) {
    case "draft":
      return Formatter.debug;
    case "open":
      return Formatter.info;
    case "review":
      return Formatter.warning;
    case "approved":
      return Formatter.success;
    case "merged":
      return Formatter.success;
    case "closed":
      return Formatter.error;
    default:
      return Formatter.info;
  }
}
function getPriorityColor4(priority) {
  switch (priority) {
    case "critical":
      return Formatter.error;
    case "high":
      return Formatter.warning;
    case "medium":
      return Formatter.info;
    case "low":
      return Formatter.debug;
    default:
      return Formatter.info;
  }
}
function formatDate4(dateString) {
  const date = new Date(dateString);
  return date.toLocaleDateString() + " " + date.toLocaleTimeString();
}
var import_commander39;
var init_list4 = __esm({
  "src/commands/pr/list.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander39 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    __name(createPRListCommand, "createPRListCommand");
    __name(listPRs, "listPRs");
    __name(getPRStatusColor, "getPRStatusColor");
    __name(getPriorityColor4, "getPriorityColor");
    __name(formatDate4, "formatDate");
  }
});

// src/commands/pr/show.ts
function createPRShowCommand() {
  const cmd = new import_commander40.Command("show");
  cmd.description("Show detailed information about a specific PR").argument("<pr-id>", "PR ID to display").option("-f, --format <format>", "output format (detailed|json|yaml)", "detailed").option("-c, --show-content", "include PR content/description").option("-r, --show-relationships", "show related items (issue, epic, dependencies)").option("-h, --show-history", "show change history (if available)").action(async (prId, options) => {
    try {
      await showPR(prId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to show PR: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function showPR(prId, options) {
  var _a;
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const prHierarchy = relationshipManager.getPRHierarchy(prId);
  if (!prHierarchy) {
    console.error(Formatter.error(`PR not found: ${prId}`));
    process.exit(1);
  }
  const pr = prHierarchy.pr;
  if (options.format === "json") {
    const output = {
      pr,
      ...options.showRelationships && {
        relationships: {
          issue: prHierarchy.issue,
          epic: prHierarchy.epic
        }
      }
    };
    console.log(JSON.stringify(output, null, 2));
    return;
  }
  if (options.format === "yaml") {
    const yamlOutput = {
      pr_id: pr.pr_id,
      title: pr.title,
      description: pr.description,
      status: pr.status,
      pr_status: pr.pr_status,
      priority: pr.priority,
      assignee: pr.assignee,
      issue_id: pr.issue_id,
      epic_id: pr.epic_id,
      created_date: pr.created_date,
      updated_date: pr.updated_date,
      estimated_tokens: pr.estimated_tokens,
      actual_tokens: pr.actual_tokens,
      branch_name: pr.branch_name,
      source_branch: pr.source_branch,
      target_branch: pr.target_branch,
      repository_url: pr.repository_url,
      pr_number: pr.pr_number,
      reviewers: pr.reviewers,
      approvals: pr.approvals,
      merge_commit: pr.merge_commit,
      tags: pr.tags,
      dependencies: pr.dependencies,
      blocked_by: pr.blocked_by,
      blocks: pr.blocks,
      related_prs: pr.related_prs,
      template_used: pr.template_used,
      ai_context: pr.ai_context,
      sync_status: pr.sync_status
    };
    console.log("---");
    Object.entries(yamlOutput).forEach(([key, value]) => {
      if (value !== void 0 && value !== null) {
        if (Array.isArray(value)) {
          if (value.length > 0) {
            console.log(`${key}:`);
            value.forEach((item) => console.log(`  - ${item}`));
          }
        } else {
          console.log(`${key}: ${value}`);
        }
      }
    });
    console.log("---");
    return;
  }
  const statusColor = getPRStatusColor2(pr.pr_status);
  const priorityColor = getPriorityColor5(pr.priority);
  console.log(Formatter.header(`
\u{1F4CB} PR Details: ${pr.pr_id}`));
  console.log(`
${Formatter.info("Title:")} ${pr.title}`);
  console.log(`${Formatter.info("Status:")} ${statusColor(pr.pr_status)} | ${Formatter.info("Priority:")} ${priorityColor(pr.priority)}`);
  console.log(`${Formatter.info("Assignee:")} ${pr.assignee}`);
  console.log(`
${Formatter.info("Hierarchy:")}`);
  console.log(`  Epic: ${pr.epic_id} (${((_a = prHierarchy.epic) == null ? void 0 : _a.title) || "Unknown"})`);
  console.log(`  Issue: ${pr.issue_id} (${prHierarchy.issue.title})`);
  console.log(`  PR: ${pr.pr_id}`);
  console.log(`
${Formatter.info("Branch Information:")}`);
  if (pr.branch_name) {
    console.log(`  Branch: ${pr.branch_name}`);
  }
  if (pr.source_branch) {
    console.log(`  Source: ${pr.source_branch}`);
  }
  console.log(`  Target: ${pr.target_branch || "main"}`);
  if (pr.repository_url) {
    console.log(`  Repository: ${pr.repository_url}`);
  }
  if (pr.pr_number) {
    console.log(`  PR Number: #${pr.pr_number}`);
  }
  console.log(`
${Formatter.info("Dates:")}`);
  console.log(`  Created: ${formatDate5(pr.created_date)}`);
  console.log(`  Updated: ${formatDate5(pr.updated_date)}`);
  if (pr.reviewers && pr.reviewers.length > 0) {
    console.log(`
${Formatter.info("Reviewers:")}`);
    pr.reviewers.forEach((reviewer) => {
      var _a2;
      const isApproved = (_a2 = pr.approvals) == null ? void 0 : _a2.includes(reviewer);
      console.log(`  ${reviewer} ${isApproved ? "\u2705" : "\u23F3"}`);
    });
  }
  if (pr.approvals && pr.approvals.length > 0) {
    console.log(`
${Formatter.info("Approvals:")}`);
    pr.approvals.forEach((approval) => {
      console.log(`  \u2705 ${approval}`);
    });
  }
  if (pr.merge_commit) {
    console.log(`
${Formatter.info("Merge Commit:")} ${pr.merge_commit}`);
  }
  if (pr.tags && pr.tags.length > 0) {
    console.log(`
${Formatter.info("Tags:")} ${pr.tags.join(", ")}`);
  }
  if (pr.estimated_tokens > 0 || pr.actual_tokens > 0) {
    console.log(`
${Formatter.info("Token Usage:")}`);
    console.log(`  Estimated: ${pr.estimated_tokens}`);
    console.log(`  Actual: ${pr.actual_tokens}`);
    if (pr.estimated_tokens > 0) {
      const efficiency = (pr.actual_tokens / pr.estimated_tokens * 100).toFixed(1);
      console.log(`  Efficiency: ${efficiency}%`);
    }
  }
  if (pr.dependencies && pr.dependencies.length > 0) {
    console.log(`
${Formatter.info("Dependencies:")}`);
    pr.dependencies.forEach((dep) => {
      console.log(`  \u{1F4CE} ${dep}`);
    });
  }
  if (pr.blocked_by && pr.blocked_by.length > 0) {
    console.log(`
${Formatter.warning("Blocked By:")}`);
    pr.blocked_by.forEach((blocker) => {
      console.log(`  \u{1F6AB} ${blocker}`);
    });
  }
  if (pr.blocks && pr.blocks.length > 0) {
    console.log(`
${Formatter.warning("Blocks:")}`);
    pr.blocks.forEach((blocked) => {
      console.log(`  \u{1F6AB} ${blocked}`);
    });
  }
  if (pr.related_prs && pr.related_prs.length > 0) {
    console.log(`
${Formatter.info("Related PRs:")}`);
    pr.related_prs.forEach((relatedPR) => {
      console.log(`  \u{1F517} ${relatedPR}`);
    });
  }
  if (pr.ai_context && pr.ai_context.length > 0) {
    console.log(`
${Formatter.info("AI Context:")}`);
    pr.ai_context.forEach((context) => {
      console.log(`  \u{1F916} ${context}`);
    });
  }
  if (pr.template_used) {
    console.log(`
${Formatter.info("Template Used:")} ${pr.template_used}`);
  }
  console.log(`
${Formatter.info("Sync Status:")} ${pr.sync_status}`);
  console.log(`${Formatter.info("File Path:")} ${pr.file_path}`);
  if (options.showContent && pr.description) {
    console.log(`
${Formatter.info("Description:")}`);
    console.log(pr.description);
  }
  if (options.showContent && pr.content) {
    console.log(`
${Formatter.info("Content:")}`);
    console.log(pr.content);
  }
  if (options.showRelationships) {
    console.log(`
${Formatter.header("Related Items:")}`);
    const issue = prHierarchy.issue;
    console.log(`
${Formatter.info("Parent Issue:")} ${issue.issue_id}`);
    console.log(`  Title: ${issue.title}`);
    console.log(`  Status: ${issue.status}`);
    console.log(`  Priority: ${issue.priority}`);
    console.log(`  Assignee: ${issue.assignee}`);
    if (prHierarchy.epic) {
      const epic = prHierarchy.epic;
      console.log(`
${Formatter.info("Parent Epic:")} ${epic.epic_id}`);
      console.log(`  Title: ${epic.title}`);
      console.log(`  Status: ${epic.status}`);
      console.log(`  Priority: ${epic.priority}`);
      console.log(`  Assignee: ${epic.assignee}`);
      if (epic.completion_percentage !== void 0) {
        console.log(`  Completion: ${epic.completion_percentage}%`);
      }
    }
  }
  console.log(`
${Formatter.success("PR Summary:")}`);
  console.log(`  PR ${pr.pr_id} "${pr.title}"`);
  console.log(`  Status: ${pr.pr_status} | Priority: ${pr.priority} | Assignee: ${pr.assignee}`);
  console.log(`  Branch: ${pr.branch_name || "N/A"} \u2192 ${pr.target_branch || "main"}`);
  console.log(`  Created: ${formatDate5(pr.created_date)}`);
  console.log(`  Last Updated: ${formatDate5(pr.updated_date)}`);
}
function getPRStatusColor2(status) {
  switch (status) {
    case "draft":
      return Formatter.debug;
    case "open":
      return Formatter.info;
    case "review":
      return Formatter.warning;
    case "approved":
      return Formatter.success;
    case "merged":
      return Formatter.success;
    case "closed":
      return Formatter.error;
    default:
      return Formatter.info;
  }
}
function getPriorityColor5(priority) {
  switch (priority) {
    case "critical":
      return Formatter.error;
    case "high":
      return Formatter.warning;
    case "medium":
      return Formatter.info;
    case "low":
      return Formatter.debug;
    default:
      return Formatter.info;
  }
}
function formatDate5(dateString) {
  const date = new Date(dateString);
  return date.toLocaleDateString() + " " + date.toLocaleTimeString();
}
var import_commander40;
var init_show5 = __esm({
  "src/commands/pr/show.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander40 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    __name(createPRShowCommand, "createPRShowCommand");
    __name(showPR, "showPR");
    __name(getPRStatusColor2, "getPRStatusColor");
    __name(getPriorityColor5, "getPriorityColor");
    __name(formatDate5, "formatDate");
  }
});

// src/commands/pr/review.ts
function createPRReviewCommand() {
  const cmd = new import_commander41.Command("review");
  cmd.description("Create or update a PR review").argument("<pr-id>", "PR ID to review").option("-c, --comments <text>", "review comments").option("-a, --approve", "approve the PR").option("-r, --request-changes", "request changes to the PR").option("-s, --status <status>", "update PR status (draft|open|review|approved|merged|closed)").option("--reviewer <username>", "reviewer username (defaults to current user)").option("-t, --template <name>", "review template to use").option("--add-reviewer <username>", "add a reviewer to the PR").option("--remove-reviewer <username>", "remove a reviewer from the PR").option("--dry-run", "show what would be done without making changes").action(async (prId, options) => {
    try {
      await reviewPR(prId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to review PR: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function reviewPR(prId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const prHierarchy = relationshipManager.getPRHierarchy(prId);
  if (!prHierarchy) {
    throw new Error(`PR not found: ${prId}`);
  }
  const pr = prHierarchy.pr;
  if (options.approve && options.requestChanges) {
    throw new Error("Cannot both approve and request changes in the same review");
  }
  let reviewType = "comment";
  if (options.approve) {
    reviewType = "approve";
  } else if (options.requestChanges) {
    reviewType = "request_changes";
  }
  const reviewer = options.reviewer || config.default_assignee || "current-user";
  const reviewId = `${prId}-review-${Date.now()}`;
  let reviewTemplate = "";
  if (options.template) {
    const template = configManager.getTemplateWithFallback("pr-review", options.template);
    if (template) {
      reviewTemplate = template.content_template || "";
    }
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const reviewFrontmatter = {
    review_id: reviewId,
    pr_id: prId,
    reviewer,
    review_type: reviewType,
    created_date: now,
    updated_date: now,
    status: "submitted",
    comments: options.comments
  };
  const reviewContent = `# PR Review: ${pr.title}

**PR**: ${prId}  
**Reviewer**: ${reviewer}  
**Review Type**: ${reviewType.toUpperCase()}  
**Date**: ${now}

## Review Comments

${options.comments || ""}

${reviewTemplate}

## Files Reviewed

- Review pending

## Review Checklist

- [ ] Code quality and standards
- [ ] Functionality and logic
- [ ] Test coverage
- [ ] Documentation
- [ ] Performance considerations
- [ ] Security considerations

## Decision

${reviewType === "approve" ? "\u2705 **APPROVED** - Ready to merge" : ""}
${reviewType === "request_changes" ? "\u274C **CHANGES REQUESTED** - Please address comments" : ""}
${reviewType === "comment" ? "\u{1F4AC} **COMMENTED** - General feedback provided" : ""}
`;
  let updatedReviewers = [...pr.reviewers || []];
  if (options.addReviewer) {
    if (!updatedReviewers.includes(options.addReviewer)) {
      updatedReviewers.push(options.addReviewer);
    }
  }
  if (options.removeReviewer) {
    updatedReviewers = updatedReviewers.filter((r) => r !== options.removeReviewer);
  }
  if (!updatedReviewers.includes(reviewer)) {
    updatedReviewers.push(reviewer);
  }
  let updatedApprovals = [...pr.approvals || []];
  if (reviewType === "approve" && !updatedApprovals.includes(reviewer)) {
    updatedApprovals.push(reviewer);
  } else if (reviewType === "request_changes") {
    updatedApprovals = updatedApprovals.filter((a) => a !== reviewer);
  }
  let newPRStatus = pr.pr_status;
  if (options.status) {
    newPRStatus = options.status;
  } else if (reviewType === "approve") {
    if (updatedReviewers.length > 0 && updatedApprovals.length >= updatedReviewers.length) {
      newPRStatus = "approved";
    } else if (pr.pr_status === "draft" || pr.pr_status === "open") {
      newPRStatus = "review";
    }
  } else if (reviewType === "request_changes") {
    newPRStatus = "open";
  }
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - Review would be created with:"));
    console.log(Formatter.debug(`PR ID: ${prId}`));
    console.log(Formatter.debug(`Review ID: ${reviewId}`));
    console.log(Formatter.debug(`Reviewer: ${reviewer}`));
    console.log(Formatter.debug(`Review Type: ${reviewType}`));
    console.log(Formatter.debug(`Current PR Status: ${pr.pr_status}`));
    console.log(Formatter.debug(`New PR Status: ${newPRStatus}`));
    console.log(Formatter.debug(`Reviewers: ${updatedReviewers.join(", ")}`));
    console.log(Formatter.debug(`Approvals: ${updatedApprovals.join(", ")}`));
    if (options.comments) {
      console.log(Formatter.debug(`Comments: ${options.comments}`));
    }
    return;
  }
  const reviewsDir = path16.join(paths.prsDir, "reviews");
  if (!fs17.existsSync(reviewsDir)) {
    fs17.mkdirSync(reviewsDir, { recursive: true });
  }
  const reviewFileName = `${reviewId}.md`;
  const reviewFilePath = path16.join(reviewsDir, reviewFileName);
  parser.writeFile(reviewFilePath, reviewFrontmatter, reviewContent);
  const prUpdates = {
    reviewers: updatedReviewers.length > 0 ? updatedReviewers : void 0,
    approvals: updatedApprovals.length > 0 ? updatedApprovals : void 0,
    pr_status: newPRStatus,
    updated_date: now
  };
  parser.updateFile(pr.file_path, prUpdates);
  if (newPRStatus !== pr.pr_status) {
    await handleStatusTransition(pr, newPRStatus, paths, configManager);
  }
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`PR review created successfully!`));
  console.log(Formatter.info(`Review ID: ${reviewId}`));
  console.log(Formatter.info(`PR: ${prId} - ${pr.title}`));
  console.log(Formatter.info(`Reviewer: ${reviewer}`));
  console.log(Formatter.info(`Review Type: ${reviewType.toUpperCase()}`));
  console.log(Formatter.info(`Review File: ${reviewFilePath}`));
  if (newPRStatus !== pr.pr_status) {
    console.log(Formatter.info(`PR Status Changed: ${pr.pr_status} \u2192 ${newPRStatus}`));
  }
  console.log(Formatter.info(`Reviewers: ${updatedReviewers.join(", ")}`));
  console.log(Formatter.info(`Approvals: ${updatedApprovals.length}/${updatedReviewers.length}`));
  if (options.comments) {
    console.log(Formatter.info(`Comments: ${options.comments}`));
  }
  if (reviewType === "approve" && newPRStatus === "approved") {
    console.log("");
    console.log(Formatter.success("\u2705 PR is now approved and ready to merge!"));
    console.log(Formatter.info("Use `aitrackdown pr merge` to merge the PR"));
  } else if (reviewType === "request_changes") {
    console.log("");
    console.log(Formatter.warning("\u26A0\uFE0F  Changes requested - PR returned to open status"));
    console.log(Formatter.info("Author should address comments and update the PR"));
  }
}
async function handleStatusTransition(pr, newStatus, paths, configManager) {
  const parser = new FrontmatterParser();
  const statusDirs = {
    draft: path16.join(paths.prsDir, "draft"),
    open: path16.join(paths.prsDir, "active"),
    review: path16.join(paths.prsDir, "active"),
    approved: path16.join(paths.prsDir, "active"),
    merged: path16.join(paths.prsDir, "merged"),
    closed: path16.join(paths.prsDir, "closed")
  };
  const currentDir = path16.dirname(pr.file_path);
  const targetDir = statusDirs[newStatus];
  if (currentDir !== targetDir) {
    if (!fs17.existsSync(targetDir)) {
      fs17.mkdirSync(targetDir, { recursive: true });
    }
    const fileName = path16.basename(pr.file_path);
    const newFilePath = path16.join(targetDir, fileName);
    fs17.renameSync(pr.file_path, newFilePath);
    console.log(Formatter.info(`Moved PR file: ${currentDir} \u2192 ${targetDir}`));
  }
}
var import_commander41, path16, fs17;
var init_review = __esm({
  "src/commands/pr/review.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander41 = require("commander");
    path16 = __toESM(require("path"), 1);
    fs17 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_relationship_manager();
    init_formatter();
    __name(createPRReviewCommand, "createPRReviewCommand");
    __name(reviewPR, "reviewPR");
    __name(handleStatusTransition, "handleStatusTransition");
  }
});

// src/commands/pr/approve.ts
function createPRApproveCommand() {
  const cmd = new import_commander42.Command("approve");
  cmd.description("Approve a PR and update its status").argument("<pr-id>", "PR ID to approve").option("-c, --comments <text>", "approval comments").option("-m, --auto-merge", "automatically merge after approval").option("--merge-strategy <strategy>", "merge strategy (merge|squash|rebase)", "merge").option("--reviewer <username>", "approver username (defaults to current user)").option("--bypass-checks", "bypass approval requirement checks").option("--dry-run", "show what would be done without making changes").action(async (prId, options) => {
    try {
      await approvePR(prId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to approve PR: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function approvePR(prId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const prHierarchy = relationshipManager.getPRHierarchy(prId);
  if (!prHierarchy) {
    throw new Error(`PR not found: ${prId}`);
  }
  const pr = prHierarchy.pr;
  if (pr.pr_status === "merged") {
    throw new Error("Cannot approve a PR that is already merged");
  }
  if (pr.pr_status === "closed") {
    throw new Error("Cannot approve a PR that is closed");
  }
  const approver = options.reviewer || config.default_assignee || "current-user";
  const currentApprovals = pr.approvals || [];
  if (currentApprovals.includes(approver)) {
    console.log(Formatter.warning(`PR ${prId} is already approved by ${approver}`));
    if (!options.bypassChecks) {
      return;
    }
  }
  const currentReviewers = pr.reviewers || [];
  const updatedReviewers = currentReviewers.includes(approver) ? currentReviewers : [...currentReviewers, approver];
  const updatedApprovals = currentApprovals.includes(approver) ? currentApprovals : [...currentApprovals, approver];
  let newStatus = "review";
  const allApproved = updatedReviewers.length > 0 && updatedApprovals.length >= updatedReviewers.length;
  if (allApproved || options.bypassChecks) {
    newStatus = "approved";
  }
  const shouldAutoMerge = options.autoMerge && (allApproved || options.bypassChecks);
  if (shouldAutoMerge) {
    newStatus = "merged";
  }
  const validMergeStrategies = ["merge", "squash", "rebase"];
  if (options.mergeStrategy && !validMergeStrategies.includes(options.mergeStrategy)) {
    throw new Error(`Invalid merge strategy: ${options.mergeStrategy}. Must be one of: ${validMergeStrategies.join(", ")}`);
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - PR would be approved with:"));
    console.log(Formatter.debug(`PR ID: ${prId}`));
    console.log(Formatter.debug(`Approver: ${approver}`));
    console.log(Formatter.debug(`Current Status: ${pr.pr_status}`));
    console.log(Formatter.debug(`New Status: ${newStatus}`));
    console.log(Formatter.debug(`Current Reviewers: ${currentReviewers.join(", ") || "none"}`));
    console.log(Formatter.debug(`Updated Reviewers: ${updatedReviewers.join(", ")}`));
    console.log(Formatter.debug(`Current Approvals: ${currentApprovals.join(", ") || "none"}`));
    console.log(Formatter.debug(`Updated Approvals: ${updatedApprovals.join(", ")}`));
    console.log(Formatter.debug(`All Approved: ${allApproved}`));
    console.log(Formatter.debug(`Auto-merge: ${shouldAutoMerge}`));
    if (options.mergeStrategy) {
      console.log(Formatter.debug(`Merge Strategy: ${options.mergeStrategy}`));
    }
    if (options.comments) {
      console.log(Formatter.debug(`Comments: ${options.comments}`));
    }
    return;
  }
  const reviewsDir = path17.join(paths.prsDir, "reviews");
  if (!fs18.existsSync(reviewsDir)) {
    fs18.mkdirSync(reviewsDir, { recursive: true });
  }
  const approvalReviewId = `${prId}-approval-${Date.now()}`;
  const approvalContent = `# PR Approval: ${pr.title}

**PR**: ${prId}  
**Approver**: ${approver}  
**Date**: ${now}  
**Status**: \u2705 APPROVED

## Approval Comments

${options.comments || "No additional comments provided."}

## Approval Details

- **Review Type**: Approval
- **Approver**: ${approver}
- **Auto-merge**: ${shouldAutoMerge ? "Yes" : "No"}
${options.mergeStrategy ? `- **Merge Strategy**: ${options.mergeStrategy}` : ""}

## Approval Checklist

- [x] Code quality meets standards
- [x] Functionality works as expected
- [x] Tests pass (if applicable)
- [x] Documentation updated (if applicable)
- [x] No security concerns identified
- [x] Performance impact acceptable

## Decision

\u2705 **APPROVED** - This PR is ready to merge.

${shouldAutoMerge ? "\u{1F680} **AUTO-MERGE ENABLED** - PR will be automatically merged." : ""}
`;
  const approvalFrontmatter = {
    review_id: approvalReviewId,
    pr_id: prId,
    reviewer: approver,
    review_type: "approve",
    created_date: now,
    updated_date: now,
    status: "submitted",
    comments: options.comments,
    auto_merge: shouldAutoMerge,
    merge_strategy: options.mergeStrategy
  };
  const approvalFilePath = path17.join(reviewsDir, `${approvalReviewId}.md`);
  parser.writeFile(approvalFilePath, approvalFrontmatter, approvalContent);
  const prUpdates = {
    reviewers: updatedReviewers,
    approvals: updatedApprovals,
    pr_status: newStatus,
    updated_date: now
  };
  if (shouldAutoMerge) {
    prUpdates.merge_commit = `auto-merge-${Date.now()}`;
  }
  parser.updateFile(pr.file_path, prUpdates);
  if (newStatus !== pr.pr_status) {
    await handleStatusTransition2(pr, newStatus, paths);
  }
  if (shouldAutoMerge && prHierarchy.issue) {
    await updateLinkedTasks(prHierarchy.issue, relationshipManager, parser);
  }
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`PR approved successfully!`));
  console.log(Formatter.info(`PR: ${prId} - ${pr.title}`));
  console.log(Formatter.info(`Approver: ${approver}`));
  console.log(Formatter.info(`Status: ${pr.pr_status} \u2192 ${newStatus}`));
  console.log(Formatter.info(`Approval File: ${approvalFilePath}`));
  if (options.comments) {
    console.log(Formatter.info(`Comments: ${options.comments}`));
  }
  console.log("");
  console.log(Formatter.info(`\u{1F4CA} Approval Status:`));
  console.log(Formatter.info(`   Reviewers: ${updatedReviewers.join(", ")}`));
  console.log(Formatter.info(`   Approvals: ${updatedApprovals.length}/${updatedReviewers.length}`));
  console.log(Formatter.info(`   All Approved: ${allApproved ? "\u2705" : "\u274C"}`));
  if (shouldAutoMerge) {
    console.log("");
    console.log(Formatter.success("\u{1F680} PR automatically merged!"));
    console.log(Formatter.info(`Merge Strategy: ${options.mergeStrategy || "merge"}`));
    console.log(Formatter.info("Linked tasks updated if applicable"));
  } else if (newStatus === "approved") {
    console.log("");
    console.log(Formatter.success("\u2705 PR is now approved and ready to merge!"));
    console.log(Formatter.info("Use `aitrackdown pr merge` to merge the PR"));
  } else {
    console.log("");
    console.log(Formatter.warning("\u26A0\uFE0F  PR approved but waiting for additional reviewers"));
    console.log(Formatter.info(`Need ${updatedReviewers.length - updatedApprovals.length} more approvals`));
  }
}
async function handleStatusTransition2(pr, newStatus, paths) {
  const statusDirs = {
    draft: path17.join(paths.prsDir, "draft"),
    open: path17.join(paths.prsDir, "active"),
    review: path17.join(paths.prsDir, "active"),
    approved: path17.join(paths.prsDir, "active"),
    merged: path17.join(paths.prsDir, "merged"),
    closed: path17.join(paths.prsDir, "closed")
  };
  const currentDir = path17.dirname(pr.file_path);
  const targetDir = statusDirs[newStatus];
  if (currentDir !== targetDir) {
    if (!fs18.existsSync(targetDir)) {
      fs18.mkdirSync(targetDir, { recursive: true });
    }
    const fileName = path17.basename(pr.file_path);
    const newFilePath = path17.join(targetDir, fileName);
    fs18.renameSync(pr.file_path, newFilePath);
    console.log(Formatter.info(`Moved PR file: ${currentDir} \u2192 ${targetDir}`));
  }
}
async function updateLinkedTasks(issue, relationshipManager, parser) {
  try {
    const issueHierarchy = relationshipManager.getIssueHierarchy(issue.issue_id);
    if (!issueHierarchy) {
      return;
    }
    const tasks = issueHierarchy.tasks;
    const now = (/* @__PURE__ */ new Date()).toISOString();
    for (const task of tasks) {
      if (task.status === "completed") {
        const taskUpdates = {
          updated_date: now,
          sync_status: "synced"
        };
        parser.updateFile(task.file_path, taskUpdates);
      }
    }
    console.log(Formatter.info(`Updated ${tasks.length} linked tasks`));
  } catch (error) {
    console.warn(Formatter.warning(`Failed to update linked tasks: ${error instanceof Error ? error.message : "Unknown error"}`));
  }
}
var import_commander42, path17, fs18;
var init_approve = __esm({
  "src/commands/pr/approve.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander42 = require("commander");
    path17 = __toESM(require("path"), 1);
    fs18 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_relationship_manager();
    init_formatter();
    __name(createPRApproveCommand, "createPRApproveCommand");
    __name(approvePR, "approvePR");
    __name(handleStatusTransition2, "handleStatusTransition");
    __name(updateLinkedTasks, "updateLinkedTasks");
  }
});

// src/commands/pr/update.ts
function createPRUpdateCommand() {
  const cmd = new import_commander43.Command("update");
  cmd.description("Update PR status, metadata, and properties").argument("<pr-id>", "PR ID to update").option("-s, --status <status>", "update PR status (draft|open|review|approved|merged|closed)").option("-p, --priority <priority>", "update priority (low|medium|high|critical)").option("-a, --assignee <username>", "update assignee").option("-t, --title <title>", "update title").option("-d, --description <text>", "update description").option("--branch-name <name>", "update branch name").option("--source-branch <name>", "update source branch").option("--target-branch <name>", "update target branch").option("--repository-url <url>", "update repository URL").option("--add-reviewer <username>", "add a reviewer").option("--remove-reviewer <username>", "remove a reviewer").option("--add-tag <tag>", "add a tag").option("--remove-tag <tag>", "remove a tag").option("--add-dependency <id>", "add a dependency").option("--remove-dependency <id>", "remove a dependency").option("--milestone <milestone>", "update milestone").option("--estimated-tokens <number>", "update estimated tokens").option("--dry-run", "show what would be updated without making changes").action(async (prId, options) => {
    try {
      await updatePR(prId, options);
    } catch (error) {
      console.error(Formatter.error(`Failed to update PR: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function updatePR(prId, options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const parser = new FrontmatterParser();
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const prHierarchy = relationshipManager.getPRHierarchy(prId);
  if (!prHierarchy) {
    throw new Error(`PR not found: ${prId}`);
  }
  const pr = prHierarchy.pr;
  const originalStatus = pr.pr_status;
  if (options.status && !isValidStatusTransition(originalStatus, options.status)) {
    throw new Error(`Invalid status transition: ${originalStatus} \u2192 ${options.status}`);
  }
  if (options.priority && !["low", "medium", "high", "critical"].includes(options.priority)) {
    throw new Error(`Invalid priority: ${options.priority}. Must be one of: low, medium, high, critical`);
  }
  if (options.status && !["draft", "open", "review", "approved", "merged", "closed"].includes(options.status)) {
    throw new Error(`Invalid PR status: ${options.status}. Must be one of: draft, open, review, approved, merged, closed`);
  }
  let updatedReviewers = [...pr.reviewers || []];
  if (options.addReviewer) {
    if (!updatedReviewers.includes(options.addReviewer)) {
      updatedReviewers.push(options.addReviewer);
    }
  }
  if (options.removeReviewer) {
    updatedReviewers = updatedReviewers.filter((r) => r !== options.removeReviewer);
  }
  let updatedTags = [...pr.tags || []];
  if (options.addTag) {
    if (!updatedTags.includes(options.addTag)) {
      updatedTags.push(options.addTag);
    }
  }
  if (options.removeTag) {
    updatedTags = updatedTags.filter((t) => t !== options.removeTag);
  }
  let updatedDependencies = [...pr.dependencies || []];
  if (options.addDependency) {
    if (!updatedDependencies.includes(options.addDependency)) {
      updatedDependencies.push(options.addDependency);
    }
  }
  if (options.removeDependency) {
    updatedDependencies = updatedDependencies.filter((d) => d !== options.removeDependency);
  }
  let updatedApprovals = [...pr.approvals || []];
  if (options.status && (options.status === "draft" || options.status === "open")) {
    updatedApprovals = [];
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const updates = {
    updated_date: now
  };
  if (options.status) updates.pr_status = options.status;
  if (options.priority) updates.priority = options.priority;
  if (options.assignee) updates.assignee = options.assignee;
  if (options.title) updates.title = options.title;
  if (options.description) updates.description = options.description;
  if (options.branchName) updates.branch_name = options.branchName;
  if (options.sourceBranch) updates.source_branch = options.sourceBranch;
  if (options.targetBranch) updates.target_branch = options.targetBranch;
  if (options.repositoryUrl) updates.repository_url = options.repositoryUrl;
  if (options.milestone) updates.milestone = options.milestone;
  if (options.estimatedTokens !== void 0) updates.estimated_tokens = options.estimatedTokens;
  if (options.addReviewer || options.removeReviewer) {
    updates.reviewers = updatedReviewers.length > 0 ? updatedReviewers : void 0;
  }
  if (options.addTag || options.removeTag) {
    updates.tags = updatedTags.length > 0 ? updatedTags : void 0;
  }
  if (options.addDependency || options.removeDependency) {
    updates.dependencies = updatedDependencies.length > 0 ? updatedDependencies : void 0;
  }
  if (options.status && (options.status === "draft" || options.status === "open")) {
    updates.approvals = updatedApprovals.length > 0 ? updatedApprovals : void 0;
  }
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - PR would be updated with:"));
    console.log(Formatter.debug(`PR ID: ${prId}`));
    console.log(Formatter.debug(`Current Title: ${pr.title}`));
    console.log(Formatter.debug(`Current Status: ${pr.pr_status}`));
    console.log(Formatter.debug(`Current Priority: ${pr.priority}`));
    console.log(Formatter.debug(`Current Assignee: ${pr.assignee}`));
    console.log("");
    console.log(Formatter.info("Proposed Changes:"));
    Object.entries(updates).forEach(([key, value]) => {
      if (key !== "updated_date") {
        console.log(Formatter.debug(`  ${key}: ${JSON.stringify(value)}`));
      }
    });
    if (options.status && options.status !== originalStatus) {
      console.log(Formatter.debug(`Status Change: ${originalStatus} \u2192 ${options.status}`));
    }
    return;
  }
  const hasChanges = Object.keys(updates).length > 1;
  if (!hasChanges) {
    console.log(Formatter.warning("No changes specified. Use --help to see available options."));
    return;
  }
  parser.updateFile(pr.file_path, updates);
  if (options.status && options.status !== originalStatus) {
    await handleStatusTransition3(pr, options.status, paths);
  }
  const updateLogEntry = {
    timestamp: now,
    pr_id: prId,
    changes: updates,
    previous_status: originalStatus,
    new_status: options.status || originalStatus
  };
  await logPRUpdate(updateLogEntry, paths);
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`PR updated successfully!`));
  console.log(Formatter.info(`PR: ${prId} - ${updates.title || pr.title}`));
  console.log(Formatter.info(`File: ${pr.file_path}`));
  if (options.status && options.status !== originalStatus) {
    console.log(Formatter.info(`Status: ${originalStatus} \u2192 ${options.status}`));
  }
  console.log("");
  console.log(Formatter.info("Updated Fields:"));
  Object.entries(updates).forEach(([key, value]) => {
    if (key !== "updated_date") {
      console.log(Formatter.info(`  ${key}: ${JSON.stringify(value)}`));
    }
  });
  if (options.status) {
    console.log("");
    switch (options.status) {
      case "draft":
        console.log(Formatter.info("\u{1F4DD} PR is now in draft status"));
        console.log(Formatter.info("Use `aitrackdown pr update --status open` when ready for review"));
        break;
      case "open":
        console.log(Formatter.info("\u{1F513} PR is now open for review"));
        console.log(Formatter.info("Use `aitrackdown pr review` to add reviews"));
        break;
      case "review":
        console.log(Formatter.info("\u{1F440} PR is under review"));
        console.log(Formatter.info("Use `aitrackdown pr approve` to approve"));
        break;
      case "approved":
        console.log(Formatter.info("\u2705 PR is approved"));
        console.log(Formatter.info("Use `aitrackdown pr merge` to merge"));
        break;
      case "merged":
        console.log(Formatter.success("\u{1F389} PR is merged"));
        console.log(Formatter.info("Linked tasks updated if applicable"));
        break;
      case "closed":
        console.log(Formatter.info("\u{1F512} PR is closed"));
        console.log(Formatter.info("Use `aitrackdown pr update --status open` to reopen"));
        break;
    }
  }
}
function isValidStatusTransition(currentStatus, newStatus) {
  const validTransitions = {
    draft: ["open", "closed"],
    open: ["draft", "review", "approved", "merged", "closed"],
    review: ["open", "approved", "closed"],
    approved: ["review", "merged", "closed"],
    merged: [],
    // Merged PRs cannot transition to other states
    closed: ["draft", "open"]
    // Closed PRs can be reopened
  };
  return validTransitions[currentStatus].includes(newStatus);
}
async function handleStatusTransition3(pr, newStatus, paths) {
  const statusDirs = {
    draft: path18.join(paths.prsDir, "draft"),
    open: path18.join(paths.prsDir, "active"),
    review: path18.join(paths.prsDir, "active"),
    approved: path18.join(paths.prsDir, "active"),
    merged: path18.join(paths.prsDir, "merged"),
    closed: path18.join(paths.prsDir, "closed")
  };
  const currentDir = path18.dirname(pr.file_path);
  const targetDir = statusDirs[newStatus];
  if (currentDir !== targetDir) {
    if (!fs19.existsSync(targetDir)) {
      fs19.mkdirSync(targetDir, { recursive: true });
    }
    const fileName = path18.basename(pr.file_path);
    const newFilePath = path18.join(targetDir, fileName);
    fs19.renameSync(pr.file_path, newFilePath);
    console.log(Formatter.info(`Moved PR file: ${currentDir} \u2192 ${targetDir}`));
  }
}
async function logPRUpdate(updateLogEntry, paths) {
  try {
    const logDir = path18.join(paths.prsDir, "logs");
    if (!fs19.existsSync(logDir)) {
      fs19.mkdirSync(logDir, { recursive: true });
    }
    const logFile = path18.join(logDir, "pr-updates.log");
    const logLine = JSON.stringify(updateLogEntry) + "\n";
    fs19.appendFileSync(logFile, logLine);
  } catch (error) {
    console.warn(Formatter.warning(`Failed to log update: ${error instanceof Error ? error.message : "Unknown error"}`));
  }
}
var import_commander43, path18, fs19;
var init_update4 = __esm({
  "src/commands/pr/update.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander43 = require("commander");
    path18 = __toESM(require("path"), 1);
    fs19 = __toESM(require("fs"), 1);
    init_config_manager();
    init_frontmatter_parser();
    init_relationship_manager();
    init_formatter();
    __name(createPRUpdateCommand, "createPRUpdateCommand");
    __name(updatePR, "updatePR");
    __name(isValidStatusTransition, "isValidStatusTransition");
    __name(handleStatusTransition3, "handleStatusTransition");
    __name(logPRUpdate, "logPRUpdate");
  }
});

// src/utils/pr-status-manager.ts
var path19, fs20, _PRStatusManager, PRStatusManager;
var init_pr_status_manager = __esm({
  "src/utils/pr-status-manager.ts"() {
    "use strict";
    init_cjs_shims();
    path19 = __toESM(require("path"), 1);
    fs20 = __toESM(require("fs"), 1);
    _PRStatusManager = class _PRStatusManager {
      configManager;
      constructor(configManager) {
        this.configManager = configManager;
      }
      /**
       * Validates if a status transition is allowed
       */
      isValidStatusTransition(currentStatus, newStatus) {
        const validTransitions = {
          draft: ["open", "closed"],
          open: ["draft", "review", "approved", "merged", "closed"],
          review: ["open", "approved", "closed"],
          approved: ["review", "merged", "closed"],
          merged: [],
          // Merged PRs cannot transition to other states
          closed: ["draft", "open"]
          // Closed PRs can be reopened
        };
        return validTransitions[currentStatus].includes(newStatus);
      }
      /**
       * Gets the directory path for a given PR status
       */
      getStatusDirectory(status, basePRsDir) {
        const statusDirs = {
          draft: path19.join(basePRsDir, "draft"),
          open: path19.join(basePRsDir, "active"),
          review: path19.join(basePRsDir, "active"),
          approved: path19.join(basePRsDir, "active"),
          merged: path19.join(basePRsDir, "merged"),
          closed: path19.join(basePRsDir, "closed")
        };
        return statusDirs[status];
      }
      /**
       * Moves a PR file to the appropriate directory based on status
       */
      async moveToStatusDirectory(pr, newStatus, basePRsDir) {
        const currentDir = path19.dirname(pr.file_path);
        const targetDir = this.getStatusDirectory(newStatus, basePRsDir);
        if (currentDir === targetDir) {
          return null;
        }
        if (!fs20.existsSync(targetDir)) {
          fs20.mkdirSync(targetDir, { recursive: true });
        }
        const fileName = path19.basename(pr.file_path);
        const newFilePath = path19.join(targetDir, fileName);
        if (fs20.existsSync(newFilePath)) {
          throw new Error(`Target file already exists: ${newFilePath}`);
        }
        fs20.renameSync(pr.file_path, newFilePath);
        return newFilePath;
      }
      /**
       * Validates PR status transition business rules
       */
      validateStatusTransition(pr, newStatus, options = {}) {
        const errors = [];
        const warnings = [];
        if (!this.isValidStatusTransition(pr.pr_status, newStatus)) {
          errors.push(`Invalid status transition: ${pr.pr_status} \u2192 ${newStatus}`);
        }
        if (!options.bypassChecks) {
          switch (newStatus) {
            case "approved":
              if (!pr.reviewers || pr.reviewers.length === 0) {
                warnings.push("PR has no reviewers assigned");
              }
              const approvals = pr.approvals || [];
              const reviewers = pr.reviewers || [];
              const requiredApprovals = options.requiredApprovals || reviewers.length;
              if (approvals.length < requiredApprovals) {
                warnings.push(`PR needs ${requiredApprovals - approvals.length} more approvals`);
              }
              break;
            case "merged":
              if (pr.pr_status !== "approved") {
                errors.push("PR must be approved before merging");
              }
              if (pr.blocked_by && pr.blocked_by.length > 0) {
                errors.push(`PR is blocked by: ${pr.blocked_by.join(", ")}`);
              }
              break;
            case "closed":
              if (pr.pr_status === "approved") {
                warnings.push("Closing an approved PR - consider merging instead");
              }
              break;
          }
        }
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
      /**
       * Gets the next recommended status for a PR
       */
      getNextRecommendedStatus(pr) {
        switch (pr.pr_status) {
          case "draft":
            return "open";
          case "open":
            return "review";
          case "review":
            const approvals = pr.approvals || [];
            const reviewers = pr.reviewers || [];
            return approvals.length >= reviewers.length ? "approved" : "review";
          case "approved":
            return "merged";
          default:
            return null;
        }
      }
      /**
       * Gets status-specific requirements and suggestions
       */
      getStatusRequirements(status) {
        const requirements = {
          draft: {
            required: [],
            recommended: ["title", "description", "branch_name"],
            nextActions: ["Add reviewers", "Update to open when ready"]
          },
          open: {
            required: ["title", "description"],
            recommended: ["reviewers", "target_branch"],
            nextActions: ["Request reviews", "Update to review status"]
          },
          review: {
            required: ["reviewers"],
            recommended: ["approval_count"],
            nextActions: ["Wait for reviews", "Address feedback"]
          },
          approved: {
            required: ["approvals"],
            recommended: ["merge_strategy"],
            nextActions: ["Merge PR", "Deploy changes"]
          },
          merged: {
            required: ["merge_commit"],
            recommended: ["linked_tasks_updated"],
            nextActions: ["Close related tasks", "Update documentation"]
          },
          closed: {
            required: [],
            recommended: ["close_reason"],
            nextActions: ["Archive or reopen if needed"]
          }
        };
        return requirements[status];
      }
      /**
       * Applies automatic status transitions based on PR state
       */
      getAutoStatusTransition(pr) {
        if (pr.pr_status === "review") {
          const approvals = pr.approvals || [];
          const reviewers = pr.reviewers || [];
          if (reviewers.length > 0 && approvals.length >= reviewers.length) {
            return "approved";
          }
        }
        return null;
      }
      /**
       * Creates status-specific directories if they don't exist
       */
      ensureStatusDirectories(basePRsDir) {
        const statusDirs = [
          "draft",
          "active",
          "merged",
          "closed",
          "reviews",
          "logs"
        ];
        statusDirs.forEach((dir) => {
          const dirPath = path19.join(basePRsDir, dir);
          if (!fs20.existsSync(dirPath)) {
            fs20.mkdirSync(dirPath, { recursive: true });
          }
        });
      }
      /**
       * Generates a status transition report
       */
      generateStatusReport(pr, fromStatus, toStatus, metadata = {}) {
        const now = (/* @__PURE__ */ new Date()).toISOString();
        return {
          pr_id: pr.pr_id,
          from_status: fromStatus,
          to_status: toStatus,
          timestamp: now,
          triggered_by: metadata.triggered_by || "manual",
          file_moved: metadata.file_moved || false,
          new_file_path: metadata.new_file_path,
          approvals_count: (pr.approvals || []).length,
          reviewers_count: (pr.reviewers || []).length,
          validation_passed: metadata.validation_passed || true,
          validation_warnings: metadata.validation_warnings || []
        };
      }
    };
    __name(_PRStatusManager, "PRStatusManager");
    PRStatusManager = _PRStatusManager;
  }
});

// src/utils/pr-file-manager.ts
var path20, fs21, _PRFileManager, PRFileManager;
var init_pr_file_manager = __esm({
  "src/utils/pr-file-manager.ts"() {
    "use strict";
    init_cjs_shims();
    path20 = __toESM(require("path"), 1);
    fs21 = __toESM(require("fs"), 1);
    init_pr_status_manager();
    _PRFileManager = class _PRFileManager {
      configManager;
      statusManager;
      constructor(configManager) {
        this.configManager = configManager;
        this.statusManager = new PRStatusManager(configManager);
      }
      /**
       * Initialize PR directory structure
       */
      initializePRDirectories(basePRsDir) {
        const directories = [
          "draft",
          // Draft PRs
          "active",
          // Open, review, approved PRs
          "merged",
          // Merged PRs
          "closed",
          // Closed PRs
          "reviews",
          // Review files
          "logs",
          // Activity logs
          "templates",
          // PR templates
          "attachments"
          // File attachments
        ];
        directories.forEach((dir) => {
          const dirPath = path20.join(basePRsDir, dir);
          if (!fs21.existsSync(dirPath)) {
            fs21.mkdirSync(dirPath, { recursive: true });
          }
        });
        const activeDirs = ["open", "review", "approved"];
        activeDirs.forEach((subdir) => {
          const subDirPath = path20.join(basePRsDir, "active", subdir);
          if (!fs21.existsSync(subDirPath)) {
            fs21.mkdirSync(subDirPath, { recursive: true });
          }
        });
      }
      /**
       * Get the appropriate directory for a PR based on its status
       */
      getPRDirectory(status, basePRsDir) {
        const statusDirectories = {
          draft: path20.join(basePRsDir, "draft"),
          open: path20.join(basePRsDir, "active", "open"),
          review: path20.join(basePRsDir, "active", "review"),
          approved: path20.join(basePRsDir, "active", "approved"),
          merged: path20.join(basePRsDir, "merged"),
          closed: path20.join(basePRsDir, "closed")
        };
        return statusDirectories[status];
      }
      /**
       * Move PR file to status-appropriate directory
       */
      async movePRToStatusDirectory(pr, newStatus, basePRsDir) {
        const currentPath = pr.file_path;
        const targetDir = this.getPRDirectory(newStatus, basePRsDir);
        const fileName = path20.basename(currentPath);
        const newPath = path20.join(targetDir, fileName);
        if (currentPath === newPath) {
          return {
            moved: false,
            oldPath: currentPath,
            newPath: currentPath,
            reason: "File already in correct location"
          };
        }
        if (!fs21.existsSync(targetDir)) {
          fs21.mkdirSync(targetDir, { recursive: true });
        }
        if (fs21.existsSync(newPath)) {
          const uniquePath = this.generateUniqueFilename(newPath);
          fs21.renameSync(currentPath, uniquePath);
          return {
            moved: true,
            oldPath: currentPath,
            newPath: uniquePath,
            reason: "Moved to unique filename to avoid conflict"
          };
        }
        fs21.renameSync(currentPath, newPath);
        return {
          moved: true,
          oldPath: currentPath,
          newPath,
          reason: "Moved to status-appropriate directory"
        };
      }
      /**
       * Generate unique filename if conflict exists
       */
      generateUniqueFilename(filePath) {
        const dir = path20.dirname(filePath);
        const ext = path20.extname(filePath);
        const base = path20.basename(filePath, ext);
        let counter = 1;
        let uniquePath = filePath;
        while (fs21.existsSync(uniquePath)) {
          uniquePath = path20.join(dir, `${base}-${counter}${ext}`);
          counter++;
        }
        return uniquePath;
      }
      /**
       * Create PR review file
       */
      async createReviewFile(prId, reviewer, reviewType, content, basePRsDir) {
        const reviewsDir = path20.join(basePRsDir, "reviews");
        if (!fs21.existsSync(reviewsDir)) {
          fs21.mkdirSync(reviewsDir, { recursive: true });
        }
        const reviewId = `${prId}-${reviewType}-${reviewer}-${Date.now()}`;
        const reviewFileName = `${reviewId}.md`;
        const reviewFilePath = path20.join(reviewsDir, reviewFileName);
        fs21.writeFileSync(reviewFilePath, content, "utf8");
        return reviewFilePath;
      }
      /**
       * Archive old PR files
       */
      async archiveOldPRs(basePRsDir, olderThanDays = 90) {
        const archiveDir = path20.join(basePRsDir, "archive");
        if (!fs21.existsSync(archiveDir)) {
          fs21.mkdirSync(archiveDir, { recursive: true });
        }
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
        const archivedFiles = [];
        const errors = [];
        const dirsToCheck = [
          path20.join(basePRsDir, "merged"),
          path20.join(basePRsDir, "closed")
        ];
        for (const dir of dirsToCheck) {
          if (!fs21.existsSync(dir)) continue;
          const files = fs21.readdirSync(dir);
          for (const file of files) {
            const filePath = path20.join(dir, file);
            const stats = fs21.statSync(filePath);
            if (stats.mtime < cutoffDate) {
              try {
                const archivePath = path20.join(archiveDir, file);
                fs21.renameSync(filePath, archivePath);
                archivedFiles.push(file);
              } catch (error) {
                errors.push(`Failed to archive ${file}: ${error}`);
              }
            }
          }
        }
        return {
          archivedCount: archivedFiles.length,
          archivedFiles,
          errors
        };
      }
      /**
       * Get PR directory statistics
       */
      getPRDirectoryStats(basePRsDir) {
        const stats = {
          draft: 0,
          open: 0,
          review: 0,
          approved: 0,
          merged: 0,
          closed: 0,
          total: 0,
          reviewFiles: 0,
          diskUsage: 0
        };
        const directories = {
          draft: path20.join(basePRsDir, "draft"),
          open: path20.join(basePRsDir, "active", "open"),
          review: path20.join(basePRsDir, "active", "review"),
          approved: path20.join(basePRsDir, "active", "approved"),
          merged: path20.join(basePRsDir, "merged"),
          closed: path20.join(basePRsDir, "closed")
        };
        Object.entries(directories).forEach(([status, dir]) => {
          if (fs21.existsSync(dir)) {
            const files = fs21.readdirSync(dir);
            stats[status] = files.length;
            stats.total += files.length;
            files.forEach((file) => {
              const filePath = path20.join(dir, file);
              const fileStats = fs21.statSync(filePath);
              stats.diskUsage += fileStats.size;
            });
          }
        });
        const reviewsDir = path20.join(basePRsDir, "reviews");
        if (fs21.existsSync(reviewsDir)) {
          const reviewFiles = fs21.readdirSync(reviewsDir);
          stats.reviewFiles = reviewFiles.length;
        }
        return stats;
      }
      /**
       * Clean up empty directories
       */
      cleanupEmptyDirectories(basePRsDir) {
        const removedDirs = [];
        const errors = [];
        const checkAndRemoveEmpty = /* @__PURE__ */ __name((dir) => {
          try {
            if (fs21.existsSync(dir)) {
              const files = fs21.readdirSync(dir);
              if (files.length === 0) {
                fs21.rmdirSync(dir);
                removedDirs.push(dir);
              }
            }
          } catch (error) {
            errors.push(`Failed to remove ${dir}: ${error}`);
          }
        }, "checkAndRemoveEmpty");
        const subDirs = [
          path20.join(basePRsDir, "active", "open"),
          path20.join(basePRsDir, "active", "review"),
          path20.join(basePRsDir, "active", "approved")
        ];
        subDirs.forEach(checkAndRemoveEmpty);
        return {
          removedCount: removedDirs.length,
          removedDirs,
          errors
        };
      }
      /**
       * Validate PR directory structure
       */
      validatePRDirectoryStructure(basePRsDir) {
        const errors = [];
        const warnings = [];
        const requiredDirs = [
          "draft",
          "active",
          "merged",
          "closed",
          "reviews"
        ];
        requiredDirs.forEach((dir) => {
          const dirPath = path20.join(basePRsDir, dir);
          if (!fs21.existsSync(dirPath)) {
            errors.push(`Missing required directory: ${dir}`);
          }
        });
        const activeSubDirs = ["open", "review", "approved"];
        activeSubDirs.forEach((subdir) => {
          const subDirPath = path20.join(basePRsDir, "active", subdir);
          if (!fs21.existsSync(subDirPath)) {
            warnings.push(`Missing active subdirectory: ${subdir}`);
          }
        });
        const prFiles = this.findPRFiles(basePRsDir);
        prFiles.forEach((file) => {
          const relativePath = path20.relative(basePRsDir, file);
          const pathParts = relativePath.split(path20.sep);
          if (pathParts.length < 2) {
            warnings.push(`PR file in root directory: ${file}`);
          }
        });
        return {
          valid: errors.length === 0,
          errors,
          warnings
        };
      }
      /**
       * Find all PR files in the directory structure
       */
      findPRFiles(basePRsDir) {
        const prFiles = [];
        const searchDir = /* @__PURE__ */ __name((dir) => {
          if (!fs21.existsSync(dir)) return;
          const items = fs21.readdirSync(dir);
          items.forEach((item) => {
            const itemPath = path20.join(dir, item);
            const stats = fs21.statSync(itemPath);
            if (stats.isDirectory()) {
              searchDir(itemPath);
            } else if (item.endsWith(".md") && item.startsWith("PR-")) {
              prFiles.push(itemPath);
            }
          });
        }, "searchDir");
        searchDir(basePRsDir);
        return prFiles;
      }
    };
    __name(_PRFileManager, "PRFileManager");
    PRFileManager = _PRFileManager;
  }
});

// src/commands/pr/merge.ts
function createPRMergeCommand() {
  const cmd = new import_commander44.Command("merge");
  cmd.description("Merge a pull request with specified strategy").argument("<pr-id>", "Pull request ID to merge").option("-s, --strategy <strategy>", "Merge strategy (merge|squash|rebase)", "merge").option("-m, --message <message>", "Custom merge commit message").option("--close-tasks", "Close linked tasks after merge", false).option("--delete-branch", "Delete source branch after merge", false).option("--skip-approval", "Skip approval requirement check", false).option("--skip-checks", "Skip pre-merge validation checks", false).option("--no-archive", "Do not archive PR after merge", false).option("--update-milestone", "Update milestone progress", false).option("--dry-run", "Show what would be done without executing", false).action(async (prId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const fileManager = new PRFileManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    const formatter = new Formatter();
    const mergeOptions = {
      strategy: options.strategy,
      message: options.message,
      closeLinkedTasks: options.closeTasks,
      deleteSourceBranch: options.deleteBranch,
      requireApproval: !options.skipApproval,
      runPreMergeChecks: !options.skipChecks,
      autoArchive: !options.noArchive,
      updateMilestone: options.updateMilestone
    };
    try {
      const result = await mergePR(
        prId,
        mergeOptions,
        statusManager,
        fileManager,
        relationshipManager,
        configManager,
        options.dryRun
      );
      if (options.dryRun) {
        console.log(colors.yellow("\u{1F50D} Dry run - showing what would be done:"));
        console.log("");
      }
      if (result.success) {
        console.log(colors.green(`\u2705 Successfully merged PR ${prId}`));
        console.log(`\u{1F4CB} Strategy: ${result.strategy}`);
        if (result.mergeCommit) {
          console.log(`\u{1F517} Merge commit: ${result.mergeCommit}`);
        }
        if (result.updatedTasks.length > 0) {
          console.log(`\u{1F4DD} Updated tasks: ${result.updatedTasks.join(", ")}`);
        }
        if (result.updatedIssues.length > 0) {
          console.log(`\u{1F3AF} Updated issues: ${result.updatedIssues.join(", ")}`);
        }
        if (result.archivedFiles.length > 0) {
          console.log(`\u{1F4C1} Archived files: ${result.archivedFiles.length}`);
        }
        if (result.warnings.length > 0) {
          console.log(colors.yellow("\u26A0\uFE0F  Warnings:"));
          result.warnings.forEach((warning) => {
            console.log(colors.yellow(`  - ${warning}`));
          });
        }
      } else {
        console.error(colors.red(`\u274C Failed to merge PR ${prId}`));
        result.errors.forEach((error) => {
          console.error(colors.red(`  \u2022 ${error}`));
        });
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error merging PR: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function mergePR(prId, options, statusManager, fileManager, relationshipManager, configManager, dryRun = false) {
  const result = {
    success: false,
    prId,
    strategy: options.strategy,
    updatedTasks: [],
    updatedIssues: [],
    archivedFiles: [],
    errors: [],
    warnings: []
  };
  try {
    const prData = await statusManager.loadPRData(prId);
    if (!prData) {
      result.errors.push(`PR ${prId} not found`);
      return result;
    }
    if (!isValidMergeStrategy(options.strategy)) {
      result.errors.push(`Invalid merge strategy: ${options.strategy}`);
      return result;
    }
    const statusValidation = validatePRStatusForMerge(prData);
    if (!statusValidation.valid) {
      result.errors.push(...statusValidation.errors);
      return result;
    }
    if (options.runPreMergeChecks) {
      const checkResults = await runPreMergeChecks(prData, options);
      const failedChecks = checkResults.filter((check) => check.required && !check.passed);
      if (failedChecks.length > 0) {
        result.errors.push("Required pre-merge checks failed:");
        failedChecks.forEach((check) => {
          result.errors.push(`  - ${check.name}: ${check.message}`);
        });
        return result;
      }
      checkResults.filter((check) => !check.required && !check.passed).forEach((check) => {
        result.warnings.push(`${check.name}: ${check.message}`);
      });
    }
    if (!dryRun) {
      const mergeResult = await performMerge(prData, options);
      if (!mergeResult.success) {
        result.errors.push(...mergeResult.errors);
        return result;
      }
      result.mergeCommit = mergeResult.mergeCommit;
    }
    if (!dryRun) {
      await statusManager.updatePRStatus(prId, "merged");
      const basePRsDir = configManager.getPRsDirectory();
      const moveResult = await fileManager.movePRToStatusDirectory(prData, "merged", basePRsDir);
      if (moveResult.moved) {
        result.archivedFiles.push(moveResult.newPath);
      }
    }
    if (options.closeLinkedTasks) {
      const linkedTasks = await relationshipManager.getLinkedTasks(prId);
      const linkedIssues = await relationshipManager.getLinkedIssues(prId);
      if (!dryRun) {
        for (const taskId of linkedTasks) {
          await updateTaskForMerge(taskId, prId, configManager);
          result.updatedTasks.push(taskId);
        }
        for (const issueId of linkedIssues) {
          await updateIssueForMerge(issueId, prId, configManager);
          result.updatedIssues.push(issueId);
        }
      } else {
        result.updatedTasks = linkedTasks;
        result.updatedIssues = linkedIssues;
      }
    }
    if (options.updateMilestone && prData.milestone) {
      if (!dryRun) {
        await updateMilestoneProgress(prData.milestone, configManager);
      }
      result.warnings.push(`Would update milestone: ${prData.milestone}`);
    }
    if (!dryRun) {
      await createMergeActivityLog(prData, options, result);
    }
    result.success = true;
    return result;
  } catch (error) {
    result.errors.push(`Merge operation failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
function isValidMergeStrategy(strategy) {
  return ["merge", "squash", "rebase"].includes(strategy);
}
function validatePRStatusForMerge(prData) {
  const errors = [];
  if (!["approved", "open", "review"].includes(prData.pr_status)) {
    errors.push(`PR status '${prData.pr_status}' is not mergeable. Must be 'approved', 'open', or 'review'.`);
  }
  if (prData.pr_status === "merged") {
    errors.push("PR is already merged");
  }
  if (prData.pr_status === "closed") {
    errors.push("PR is closed and cannot be merged");
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
async function runPreMergeChecks(prData, options) {
  const checks = [];
  if (options.requireApproval) {
    const hasApproval = prData.approvals && prData.approvals.length > 0;
    checks.push({
      name: "Approval Check",
      description: "PR must have at least one approval",
      required: true,
      passed: hasApproval || false,
      message: hasApproval ? "PR has required approvals" : "PR lacks required approvals"
    });
  }
  const hasReviewers = prData.reviewers && prData.reviewers.length > 0;
  const allReviewersCompleted = hasReviewers && prData.reviewers.every(
    (reviewer) => {
      var _a;
      return ((_a = prData.approvals) == null ? void 0 : _a.includes(reviewer)) || false;
    }
  );
  checks.push({
    name: "Review Completion",
    description: "All assigned reviewers should have completed their reviews",
    required: false,
    passed: !hasReviewers || allReviewersCompleted,
    message: allReviewersCompleted ? "All reviews completed" : "Some reviewers have not completed their reviews"
  });
  checks.push({
    name: "Branch Validation",
    description: "Source and target branches should be valid",
    required: true,
    passed: Boolean(prData.source_branch && prData.target_branch),
    message: Boolean(prData.source_branch && prData.target_branch) ? "Branches are valid" : "Missing branch information"
  });
  checks.push({
    name: "Merge Conflict Check",
    description: "PR should not have merge conflicts",
    required: true,
    passed: true,
    // This would be implemented with actual Git integration
    message: "No merge conflicts detected"
  });
  if (options.closeLinkedTasks) {
    const linkedTasksCompleted = await checkLinkedTasksStatus(prData);
    checks.push({
      name: "Linked Tasks Status",
      description: "Linked tasks should be completed if auto-closing",
      required: false,
      passed: linkedTasksCompleted,
      message: linkedTasksCompleted ? "All linked tasks are completed" : "Some linked tasks are not completed"
    });
  }
  return checks;
}
async function checkLinkedTasksStatus(prData) {
  return true;
}
async function performMerge(prData, options) {
  const result = {
    success: false,
    mergeCommit: void 0,
    errors: []
  };
  try {
    const mergeCommit = generateMergeCommit(prData, options);
    switch (options.strategy) {
      case "merge":
        result.mergeCommit = mergeCommit;
        break;
      case "squash":
        result.mergeCommit = `squash-${mergeCommit}`;
        break;
      case "rebase":
        result.mergeCommit = `rebase-${mergeCommit}`;
        break;
    }
    result.success = true;
    return result;
  } catch (error) {
    result.errors.push(`Merge failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
function generateMergeCommit(prData, options) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  const strategy = options.strategy;
  if (options.message) {
    return `${strategy}-${timestamp}-custom`;
  }
  return `${strategy}-${timestamp}-${prData.pr_id}`;
}
async function updateTaskForMerge(taskId, prId, configManager) {
  try {
    const tasksDir = configManager.getTasksDirectory();
    const taskFiles = fs22.readdirSync(tasksDir).filter((file) => file.includes(taskId));
    if (taskFiles.length === 0) {
      console.warn(`Task ${taskId} not found in ${tasksDir}`);
      return;
    }
    const taskFile = taskFiles[0];
    const taskPath = path21.join(tasksDir, taskFile);
    const taskContent = fs22.readFileSync(taskPath, "utf8");
    const updatedContent = taskContent.replace(
      /status:\s*\w+/,
      "status: completed"
    ).replace(
      /updated_date:\s*[^\n]+/,
      `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    const mergeNote = `

## Completed via PR Merge

This task was automatically completed when PR ${prId} was merged.
`;
    const finalContent = updatedContent + mergeNote;
    fs22.writeFileSync(taskPath, finalContent, "utf8");
  } catch (error) {
    console.error(`Failed to update task ${taskId}: ${error}`);
  }
}
async function updateIssueForMerge(issueId, prId, configManager) {
  try {
    const issuesDir = configManager.getIssuesDirectory();
    const issueFiles = fs22.readdirSync(issuesDir).filter((file) => file.includes(issueId));
    if (issueFiles.length === 0) {
      console.warn(`Issue ${issueId} not found in ${issuesDir}`);
      return;
    }
    const issueFile = issueFiles[0];
    const issuePath = path21.join(issuesDir, issueFile);
    const issueContent = fs22.readFileSync(issuePath, "utf8");
    const updatedContent = issueContent.replace(
      /updated_date:\s*[^\n]+/,
      `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    const mergeNote = `

## PR Merged

PR ${prId} has been merged for this issue.
`;
    const finalContent = updatedContent + mergeNote;
    fs22.writeFileSync(issuePath, finalContent, "utf8");
  } catch (error) {
    console.error(`Failed to update issue ${issueId}: ${error}`);
  }
}
async function updateMilestoneProgress(milestone, configManager) {
  console.log(`Updating milestone progress for: ${milestone}`);
}
async function createMergeActivityLog(prData, options, result) {
  const logEntry = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    action: "merged",
    pr_id: prData.pr_id,
    strategy: options.strategy,
    merge_commit: result.mergeCommit,
    updated_tasks: result.updatedTasks,
    updated_issues: result.updatedIssues,
    archived_files: result.archivedFiles
  };
  console.log("Merge activity logged:", JSON.stringify(logEntry, null, 2));
}
var import_commander44, fs22, path21;
var init_merge = __esm({
  "src/commands/pr/merge.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander44 = require("commander");
    init_pr_status_manager();
    init_pr_file_manager();
    init_relationship_manager();
    init_config_manager();
    init_formatter();
    init_colors();
    fs22 = __toESM(require("fs"), 1);
    path21 = __toESM(require("path"), 1);
    __name(createPRMergeCommand, "createPRMergeCommand");
    __name(mergePR, "mergePR");
    __name(isValidMergeStrategy, "isValidMergeStrategy");
    __name(validatePRStatusForMerge, "validatePRStatusForMerge");
    __name(runPreMergeChecks, "runPreMergeChecks");
    __name(checkLinkedTasksStatus, "checkLinkedTasksStatus");
    __name(performMerge, "performMerge");
    __name(generateMergeCommit, "generateMergeCommit");
    __name(updateTaskForMerge, "updateTaskForMerge");
    __name(updateIssueForMerge, "updateIssueForMerge");
    __name(updateMilestoneProgress, "updateMilestoneProgress");
    __name(createMergeActivityLog, "createMergeActivityLog");
  }
});

// src/commands/pr/close.ts
function createPRCloseCommand() {
  const cmd = new import_commander45.Command("close");
  cmd.description("Close a pull request without merging").argument("<pr-id>", "Pull request ID to close").option("-r, --reason <reason>", "Reason for closing (cancelled|superseded|rejected|duplicate|stale|other)", "cancelled").option("-c, --comment <comment>", "Comment explaining the closure").option("--update-tasks", "Update linked tasks with closure info", false).option("--update-issues", "Update linked issues with closure info", false).option("--delete-branch", "Delete source branch after closing", false).option("--no-archive", "Do not archive PR after closing", false).option("--notify-reviewers", "Notify reviewers of the closure", false).option("--add-to-report", "Add to closure report", false).option("--force", "Force close even if PR is approved", false).option("--dry-run", "Show what would be done without executing", false).action(async (prId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const fileManager = new PRFileManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    const formatter = new Formatter();
    const closeOptions = {
      reason: options.reason,
      comment: options.comment,
      updateLinkedTasks: options.updateTasks,
      updateLinkedIssues: options.updateIssues,
      deleteSourceBranch: options.deleteBranch,
      archiveFiles: !options.noArchive,
      notifyReviewers: options.notifyReviewers,
      addToReport: options.addToReport
    };
    try {
      const result = await closePR(
        prId,
        closeOptions,
        statusManager,
        fileManager,
        relationshipManager,
        configManager,
        options.force,
        options.dryRun
      );
      if (options.dryRun) {
        console.log(colors.yellow("\u{1F50D} Dry run - showing what would be done:"));
        console.log("");
      }
      if (result.success) {
        console.log(colors.green(`\u2705 Successfully closed PR ${prId}`));
        console.log(`\u{1F4CB} Reason: ${result.reason}`);
        if (result.updatedTasks.length > 0) {
          console.log(`\u{1F4DD} Updated tasks: ${result.updatedTasks.join(", ")}`);
        }
        if (result.updatedIssues.length > 0) {
          console.log(`\u{1F3AF} Updated issues: ${result.updatedIssues.join(", ")}`);
        }
        if (result.archivedFiles.length > 0) {
          console.log(`\u{1F4C1} Archived files: ${result.archivedFiles.length}`);
        }
        if (result.notifications.length > 0) {
          console.log(`\u{1F4EC} Notifications sent: ${result.notifications.join(", ")}`);
        }
        if (result.warnings.length > 0) {
          console.log(colors.yellow("\u26A0\uFE0F  Warnings:"));
          result.warnings.forEach((warning) => {
            console.log(colors.yellow(`  - ${warning}`));
          });
        }
      } else {
        console.error(colors.red(`\u274C Failed to close PR ${prId}`));
        result.errors.forEach((error) => {
          console.error(colors.red(`  \u2022 ${error}`));
        });
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error closing PR: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function closePR(prId, options, statusManager, fileManager, relationshipManager, configManager, force = false, dryRun = false) {
  const result = {
    success: false,
    prId,
    reason: options.reason,
    updatedTasks: [],
    updatedIssues: [],
    archivedFiles: [],
    notifications: [],
    errors: [],
    warnings: []
  };
  try {
    const prData = await statusManager.loadPRData(prId);
    if (!prData) {
      result.errors.push(`PR ${prId} not found`);
      return result;
    }
    if (!isValidCloseReason(options.reason)) {
      result.errors.push(`Invalid close reason: ${options.reason}`);
      return result;
    }
    const statusValidation = validatePRStatusForClose(prData, force);
    if (!statusValidation.valid) {
      result.errors.push(...statusValidation.errors);
      return result;
    }
    if (statusValidation.warnings.length > 0) {
      result.warnings.push(...statusValidation.warnings);
    }
    if (!dryRun) {
      await statusManager.updatePRStatus(prId, "closed");
      const basePRsDir = configManager.getPRsDirectory();
      const moveResult = await fileManager.movePRToStatusDirectory(prData, "closed", basePRsDir);
      if (moveResult.moved) {
        result.archivedFiles.push(moveResult.newPath);
      }
    }
    if (options.updateLinkedTasks) {
      const linkedTasks = await relationshipManager.getLinkedTasks(prId);
      if (!dryRun) {
        for (const taskId of linkedTasks) {
          await updateTaskForClose(taskId, prId, options, configManager);
          result.updatedTasks.push(taskId);
        }
      } else {
        result.updatedTasks = linkedTasks;
      }
    }
    if (options.updateLinkedIssues) {
      const linkedIssues = await relationshipManager.getLinkedIssues(prId);
      if (!dryRun) {
        for (const issueId of linkedIssues) {
          await updateIssueForClose(issueId, prId, options, configManager);
          result.updatedIssues.push(issueId);
        }
      } else {
        result.updatedIssues = linkedIssues;
      }
    }
    if (options.notifyReviewers && prData.reviewers) {
      if (!dryRun) {
        for (const reviewer of prData.reviewers) {
          await notifyReviewer(reviewer, prId, options);
          result.notifications.push(reviewer);
        }
      } else {
        result.notifications = prData.reviewers;
      }
    }
    if (options.addToReport) {
      if (!dryRun) {
        await addToClosureReport(prData, options, configManager);
      }
      result.warnings.push("Added to closure report");
    }
    if (!dryRun) {
      await createClosureActivityLog(prData, options, result);
    }
    if (!dryRun) {
      await updatePRWithClosureInfo(prData, options, configManager);
    }
    result.success = true;
    return result;
  } catch (error) {
    result.errors.push(`Close operation failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
function isValidCloseReason(reason) {
  return ["cancelled", "superseded", "rejected", "duplicate", "stale", "other"].includes(reason);
}
function validatePRStatusForClose(prData, force) {
  const errors = [];
  const warnings = [];
  if (prData.pr_status === "closed") {
    errors.push("PR is already closed");
  }
  if (prData.pr_status === "merged") {
    errors.push("PR is already merged and cannot be closed");
  }
  if (prData.pr_status === "approved" && !force) {
    warnings.push("PR is approved - consider merging instead of closing");
  }
  if (prData.approvals && prData.approvals.length > 0 && !force) {
    warnings.push(`PR has ${prData.approvals.length} approval(s) - closing will discard them`);
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
async function updateTaskForClose(taskId, prId, options, configManager) {
  try {
    const tasksDir = configManager.getTasksDirectory();
    const taskFiles = fs23.readdirSync(tasksDir).filter((file) => file.includes(taskId));
    if (taskFiles.length === 0) {
      console.warn(`Task ${taskId} not found in ${tasksDir}`);
      return;
    }
    const taskFile = taskFiles[0];
    const taskPath = path22.join(tasksDir, taskFile);
    const taskContent = fs23.readFileSync(taskPath, "utf8");
    const updatedContent = taskContent.replace(
      /updated_date:\s*[^\n]+/,
      `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    const closureNote = `

## PR Closed

PR ${prId} was closed (${options.reason})${options.comment ? `: ${options.comment}` : ""}.

This task may need attention or reassignment.
`;
    const finalContent = updatedContent + closureNote;
    fs23.writeFileSync(taskPath, finalContent, "utf8");
  } catch (error) {
    console.error(`Failed to update task ${taskId}: ${error}`);
  }
}
async function updateIssueForClose(issueId, prId, options, configManager) {
  try {
    const issuesDir = configManager.getIssuesDirectory();
    const issueFiles = fs23.readdirSync(issuesDir).filter((file) => file.includes(issueId));
    if (issueFiles.length === 0) {
      console.warn(`Issue ${issueId} not found in ${issuesDir}`);
      return;
    }
    const issueFile = issueFiles[0];
    const issuePath = path22.join(issuesDir, issueFile);
    const issueContent = fs23.readFileSync(issuePath, "utf8");
    const updatedContent = issueContent.replace(
      /updated_date:\s*[^\n]+/,
      `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    const closureNote = `

## PR Closed

PR ${prId} was closed (${options.reason})${options.comment ? `: ${options.comment}` : ""}.

This issue may need a new PR or different approach.
`;
    const finalContent = updatedContent + closureNote;
    fs23.writeFileSync(issuePath, finalContent, "utf8");
  } catch (error) {
    console.error(`Failed to update issue ${issueId}: ${error}`);
  }
}
async function notifyReviewer(reviewer, prId, options) {
  console.log(`Notifying ${reviewer} about PR ${prId} closure (${options.reason})`);
}
async function addToClosureReport(prData, options, configManager) {
  const reportEntry = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    pr_id: prData.pr_id,
    title: prData.title,
    reason: options.reason,
    comment: options.comment,
    author: prData.assignee,
    reviewers: prData.reviewers,
    approvals: prData.approvals
  };
  const reportsDir = path22.join(configManager.getPRsDirectory(), "reports");
  if (!fs23.existsSync(reportsDir)) {
    fs23.mkdirSync(reportsDir, { recursive: true });
  }
  const reportPath = path22.join(reportsDir, "closure-report.json");
  let reports = [];
  if (fs23.existsSync(reportPath)) {
    const reportContent = fs23.readFileSync(reportPath, "utf8");
    reports = JSON.parse(reportContent);
  }
  reports.push(reportEntry);
  fs23.writeFileSync(reportPath, JSON.stringify(reports, null, 2), "utf8");
}
async function createClosureActivityLog(prData, options, result) {
  const logEntry = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    action: "closed",
    pr_id: prData.pr_id,
    reason: options.reason,
    comment: options.comment,
    updated_tasks: result.updatedTasks,
    updated_issues: result.updatedIssues,
    archived_files: result.archivedFiles,
    notifications: result.notifications
  };
  console.log("Closure activity logged:", JSON.stringify(logEntry, null, 2));
}
async function updatePRWithClosureInfo(prData, options, configManager) {
  try {
    const prContent = fs23.readFileSync(prData.file_path, "utf8");
    const updatedContent = prContent.replace(
      /pr_status:\s*\w+/,
      "pr_status: closed"
    ).replace(
      /updated_date:\s*[^\n]+/,
      `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    const closureSection = `

## PR Closed

**Reason**: ${options.reason}
${options.comment ? `**Comment**: ${options.comment}
` : ""}**Closed**: ${(/* @__PURE__ */ new Date()).toISOString()}
`;
    const finalContent = updatedContent + closureSection;
    fs23.writeFileSync(prData.file_path, finalContent, "utf8");
  } catch (error) {
    console.error(`Failed to update PR ${prData.pr_id} with closure info: ${error}`);
  }
}
var import_commander45, fs23, path22;
var init_close = __esm({
  "src/commands/pr/close.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander45 = require("commander");
    init_pr_status_manager();
    init_pr_file_manager();
    init_relationship_manager();
    init_config_manager();
    init_formatter();
    init_colors();
    fs23 = __toESM(require("fs"), 1);
    path22 = __toESM(require("path"), 1);
    __name(createPRCloseCommand, "createPRCloseCommand");
    __name(closePR, "closePR");
    __name(isValidCloseReason, "isValidCloseReason");
    __name(validatePRStatusForClose, "validatePRStatusForClose");
    __name(updateTaskForClose, "updateTaskForClose");
    __name(updateIssueForClose, "updateIssueForClose");
    __name(notifyReviewer, "notifyReviewer");
    __name(addToClosureReport, "addToClosureReport");
    __name(createClosureActivityLog, "createClosureActivityLog");
    __name(updatePRWithClosureInfo, "updatePRWithClosureInfo");
  }
});

// src/commands/pr/batch.ts
function createPRBatchCommand() {
  const cmd = new import_commander46.Command("batch");
  cmd.description("Perform batch operations on multiple PRs").option("-o, --operation <operation>", "Batch operation (merge|close|approve|update-status|archive|create-from-tasks)", "merge").option("--status <status>", "Filter by PR status (can be comma-separated)").option("--assignee <assignee>", "Filter by assignee").option("--reviewer <reviewer>", "Filter by reviewer").option("--labels <labels>", "Filter by labels (comma-separated)").option("--created-after <date>", "Filter PRs created after date").option("--created-before <date>", "Filter PRs created before date").option("--branch <branch>", "Filter by branch name").option("--author <author>", "Filter by author").option("--milestone <milestone>", "Filter by milestone").option("--max-concurrency <num>", "Maximum concurrent operations", "5").option("--continue-on-error", "Continue processing if one PR fails", false).option("--create-report", "Create detailed report of operations", false).option("--auto-approve", "Auto-approve operations when applicable", false).option("--dry-run", "Show what would be done without executing", false).action(async (options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const fileManager = new PRFileManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    const formatter = new Formatter();
    const batchOptions = {
      operation: options.operation,
      filter: {
        status: options.status ? options.status.split(",") : void 0,
        assignee: options.assignee,
        reviewer: options.reviewer,
        labels: options.labels ? options.labels.split(",") : void 0,
        createdAfter: options.createdAfter,
        createdBefore: options.createdBefore,
        branch: options.branch,
        author: options.author,
        milestone: options.milestone
      },
      dryRun: options.dryRun,
      maxConcurrency: parseInt(options.maxConcurrency),
      continueOnError: options.continueOnError,
      createReport: options.createReport,
      autoApprove: options.autoApprove
    };
    try {
      const result = await performBatchOperation(
        batchOptions,
        statusManager,
        fileManager,
        relationshipManager,
        configManager
      );
      if (options.dryRun) {
        console.log(colors.yellow("\u{1F50D} Batch dry run - showing what would be done:"));
        console.log("");
      }
      console.log(colors.cyan(`\u{1F4CA} Batch ${result.operation} operation completed`));
      console.log(`\u{1F3AF} Total PRs: ${result.totalPRs}`);
      console.log(`\u2705 Processed: ${result.processedPRs}`);
      console.log(`\u{1F7E2} Successful: ${result.successfulPRs}`);
      console.log(`\u{1F534} Failed: ${result.failedPRs}`);
      console.log(`\u23ED\uFE0F  Skipped: ${result.skippedPRs}`);
      console.log(`\u23F1\uFE0F  Time: ${result.executionTime}ms`);
      if (result.results.length > 0) {
        console.log("\n\u{1F4CB} Operation Results:");
        result.results.forEach((prResult) => {
          const icon = prResult.success ? "\u2705" : "\u274C";
          const color = prResult.success ? colors.green : colors.red;
          console.log(color(`${icon} ${prResult.prId}: ${prResult.message}`));
          if (prResult.warnings && prResult.warnings.length > 0) {
            prResult.warnings.forEach((warning) => {
              console.log(colors.yellow(`  \u26A0\uFE0F  ${warning}`));
            });
          }
        });
      }
      if (result.warnings.length > 0) {
        console.log(colors.yellow("\n\u26A0\uFE0F  Warnings:"));
        result.warnings.forEach((warning) => {
          console.log(colors.yellow(`  - ${warning}`));
        });
      }
      if (result.errors.length > 0) {
        console.log(colors.red("\n\u274C Errors:"));
        result.errors.forEach((error) => {
          console.log(colors.red(`  - ${error}`));
        });
      }
      if (result.report) {
        console.log(colors.blue(`
\u{1F4C4} Report saved to: ${result.report}`));
      }
      if (!result.success) {
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Batch operation failed: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function performBatchOperation(options, statusManager, fileManager, relationshipManager, configManager) {
  const startTime = Date.now();
  const result = {
    success: false,
    operation: options.operation,
    totalPRs: 0,
    processedPRs: 0,
    successfulPRs: 0,
    failedPRs: 0,
    skippedPRs: 0,
    results: [],
    errors: [],
    warnings: [],
    executionTime: 0
  };
  try {
    const allPRs = await statusManager.listPRs();
    const filteredPRs = filterPRs(allPRs, options.filter);
    result.totalPRs = filteredPRs.length;
    if (filteredPRs.length === 0) {
      result.warnings.push("No PRs match the specified filter criteria");
      result.success = true;
      result.executionTime = Date.now() - startTime;
      return result;
    }
    console.log(colors.blue(`\u{1F504} Processing ${filteredPRs.length} PRs with operation: ${options.operation}`));
    switch (options.operation) {
      case "merge":
        await performBatchMerge(filteredPRs, options, result, statusManager, fileManager, relationshipManager, configManager);
        break;
      case "close":
        await performBatchClose(filteredPRs, options, result, statusManager, fileManager, relationshipManager, configManager);
        break;
      case "approve":
        await performBatchApprove(filteredPRs, options, result, statusManager, configManager);
        break;
      case "update-status":
        await performBatchStatusUpdate(filteredPRs, options, result, statusManager, fileManager, configManager);
        break;
      case "archive":
        await performBatchArchive(filteredPRs, options, result, fileManager, configManager);
        break;
      case "create-from-tasks":
        await performBatchCreateFromTasks(options, result, statusManager, relationshipManager, configManager);
        break;
      default:
        result.errors.push(`Unknown batch operation: ${options.operation}`);
        result.executionTime = Date.now() - startTime;
        return result;
    }
    if (options.createReport) {
      result.report = await createBatchReport(result, options, configManager);
    }
    result.success = result.failedPRs === 0;
    result.executionTime = Date.now() - startTime;
    return result;
  } catch (error) {
    result.errors.push(`Batch operation failed: ${error instanceof Error ? error.message : String(error)}`);
    result.executionTime = Date.now() - startTime;
    return result;
  }
}
function filterPRs(prs, filter) {
  if (!filter) return prs;
  return prs.filter((pr) => {
    if (filter.status) {
      const statuses = Array.isArray(filter.status) ? filter.status : [filter.status];
      if (!statuses.includes(pr.pr_status)) return false;
    }
    if (filter.assignee && pr.assignee !== filter.assignee) return false;
    if (filter.reviewer && (!pr.reviewers || !pr.reviewers.includes(filter.reviewer))) return false;
    if (filter.labels) {
      const labels = Array.isArray(filter.labels) ? filter.labels : [filter.labels];
      if (!pr.tags || !labels.some((label) => pr.tags.includes(label))) return false;
    }
    if (filter.createdAfter && new Date(pr.created_date) < new Date(filter.createdAfter)) return false;
    if (filter.createdBefore && new Date(pr.created_date) > new Date(filter.createdBefore)) return false;
    if (filter.branch && pr.source_branch !== filter.branch) return false;
    if (filter.author && pr.assignee !== filter.author) return false;
    if (filter.milestone && pr.milestone !== filter.milestone) return false;
    return true;
  });
}
async function performBatchMerge(prs, options, result, statusManager, fileManager, relationshipManager, configManager) {
  const mergeOptions = {
    strategy: "merge",
    closeLinkedTasks: true,
    deleteSourceBranch: false,
    requireApproval: !options.autoApprove,
    runPreMergeChecks: true,
    autoArchive: true,
    updateMilestone: false
  };
  for (const pr of prs) {
    try {
      if (!["approved", "open", "review"].includes(pr.pr_status)) {
        result.skippedPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: false,
          action: "merge",
          message: `Skipped - PR status '${pr.pr_status}' is not mergeable`
        });
        continue;
      }
      const mergeResult = await mergePR(
        pr.pr_id,
        mergeOptions,
        statusManager,
        fileManager,
        relationshipManager,
        configManager,
        options.dryRun
      );
      result.processedPRs++;
      if (mergeResult.success) {
        result.successfulPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: true,
          action: "merge",
          message: `Merged successfully with strategy: ${mergeResult.strategy}`,
          details: mergeResult,
          warnings: mergeResult.warnings
        });
      } else {
        result.failedPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: false,
          action: "merge",
          message: `Merge failed: ${mergeResult.errors.join(", ")}`,
          error: mergeResult.errors.join(", ")
        });
        if (!options.continueOnError) {
          break;
        }
      }
    } catch (error) {
      result.failedPRs++;
      result.results.push({
        prId: pr.pr_id,
        success: false,
        action: "merge",
        message: `Merge failed with error`,
        error: error instanceof Error ? error.message : String(error)
      });
      if (!options.continueOnError) {
        break;
      }
    }
  }
}
async function performBatchClose(prs, options, result, statusManager, fileManager, relationshipManager, configManager) {
  const closeOptions = {
    reason: "stale",
    updateLinkedTasks: true,
    updateLinkedIssues: true,
    deleteSourceBranch: false,
    archiveFiles: true,
    notifyReviewers: false,
    addToReport: true
  };
  for (const pr of prs) {
    try {
      if (["closed", "merged"].includes(pr.pr_status)) {
        result.skippedPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: false,
          action: "close",
          message: `Skipped - PR is already ${pr.pr_status}`
        });
        continue;
      }
      const closeResult = await closePR(
        pr.pr_id,
        closeOptions,
        statusManager,
        fileManager,
        relationshipManager,
        configManager,
        false,
        options.dryRun
      );
      result.processedPRs++;
      if (closeResult.success) {
        result.successfulPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: true,
          action: "close",
          message: `Closed successfully with reason: ${closeResult.reason}`,
          details: closeResult,
          warnings: closeResult.warnings
        });
      } else {
        result.failedPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: false,
          action: "close",
          message: `Close failed: ${closeResult.errors.join(", ")}`,
          error: closeResult.errors.join(", ")
        });
        if (!options.continueOnError) {
          break;
        }
      }
    } catch (error) {
      result.failedPRs++;
      result.results.push({
        prId: pr.pr_id,
        success: false,
        action: "close",
        message: `Close failed with error`,
        error: error instanceof Error ? error.message : String(error)
      });
      if (!options.continueOnError) {
        break;
      }
    }
  }
}
async function performBatchApprove(prs, options, result, statusManager, configManager) {
  for (const pr of prs) {
    try {
      if (!["open", "review"].includes(pr.pr_status)) {
        result.skippedPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: false,
          action: "approve",
          message: `Skipped - PR status '${pr.pr_status}' is not reviewable`
        });
        continue;
      }
      if (!options.dryRun) {
        await statusManager.updatePRStatus(pr.pr_id, "approved");
      }
      result.processedPRs++;
      result.successfulPRs++;
      result.results.push({
        prId: pr.pr_id,
        success: true,
        action: "approve",
        message: "Approved successfully"
      });
    } catch (error) {
      result.failedPRs++;
      result.results.push({
        prId: pr.pr_id,
        success: false,
        action: "approve",
        message: `Approve failed with error`,
        error: error instanceof Error ? error.message : String(error)
      });
      if (!options.continueOnError) {
        break;
      }
    }
  }
}
async function performBatchStatusUpdate(prs, options, result, statusManager, fileManager, configManager) {
  for (const pr of prs) {
    result.skippedPRs++;
    result.results.push({
      prId: pr.pr_id,
      success: false,
      action: "update-status",
      message: "Status update operation not implemented"
    });
  }
}
async function performBatchArchive(prs, options, result, fileManager, configManager) {
  const basePRsDir = configManager.getPRsDirectory();
  for (const pr of prs) {
    try {
      if (!["merged", "closed"].includes(pr.pr_status)) {
        result.skippedPRs++;
        result.results.push({
          prId: pr.pr_id,
          success: false,
          action: "archive",
          message: `Skipped - PR status '${pr.pr_status}' is not archivable`
        });
        continue;
      }
      if (!options.dryRun) {
        const archiveResult = await fileManager.archiveOldPRs(basePRsDir, 0);
      }
      result.processedPRs++;
      result.successfulPRs++;
      result.results.push({
        prId: pr.pr_id,
        success: true,
        action: "archive",
        message: "Archived successfully"
      });
    } catch (error) {
      result.failedPRs++;
      result.results.push({
        prId: pr.pr_id,
        success: false,
        action: "archive",
        message: `Archive failed with error`,
        error: error instanceof Error ? error.message : String(error)
      });
      if (!options.continueOnError) {
        break;
      }
    }
  }
}
async function performBatchCreateFromTasks(options, result, statusManager, relationshipManager, configManager) {
  try {
    const completedTasks = await getCompletedTasksWithoutPRs(configManager);
    for (const task of completedTasks) {
      try {
        if (!options.dryRun) {
          const prData = await createPRFromTask(task, statusManager, configManager);
          await relationshipManager.linkPRToTask(prData.pr_id, task.task_id);
        }
        result.processedPRs++;
        result.successfulPRs++;
        result.results.push({
          prId: `PR-${task.task_id}`,
          success: true,
          action: "create-from-task",
          message: `Created PR from task: ${task.title}`
        });
      } catch (error) {
        result.failedPRs++;
        result.results.push({
          prId: `PR-${task.task_id}`,
          success: false,
          action: "create-from-task",
          message: `Failed to create PR from task: ${task.title}`,
          error: error instanceof Error ? error.message : String(error)
        });
        if (!options.continueOnError) {
          break;
        }
      }
    }
    result.totalPRs = completedTasks.length;
  } catch (error) {
    result.errors.push(`Failed to create PRs from tasks: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function getCompletedTasksWithoutPRs(configManager) {
  return [];
}
async function createPRFromTask(task, statusManager, configManager) {
  return {
    pr_id: `PR-${task.task_id}`,
    title: `PR for ${task.title}`,
    description: task.description,
    status: "active",
    priority: task.priority,
    assignee: task.assignee,
    created_date: (/* @__PURE__ */ new Date()).toISOString(),
    updated_date: (/* @__PURE__ */ new Date()).toISOString(),
    estimated_tokens: 0,
    actual_tokens: 0,
    ai_context: [],
    sync_status: "local",
    issue_id: task.issue_id,
    epic_id: task.epic_id,
    pr_status: "draft",
    content: "",
    file_path: ""
  };
}
async function createBatchReport(result, options, configManager) {
  const reportData = {
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    operation: result.operation,
    summary: {
      totalPRs: result.totalPRs,
      processedPRs: result.processedPRs,
      successfulPRs: result.successfulPRs,
      failedPRs: result.failedPRs,
      skippedPRs: result.skippedPRs,
      executionTime: result.executionTime
    },
    filter: options.filter,
    results: result.results,
    errors: result.errors,
    warnings: result.warnings
  };
  const reportsDir = path23.join(configManager.getPRsDirectory(), "reports");
  if (!fs24.existsSync(reportsDir)) {
    fs24.mkdirSync(reportsDir, { recursive: true });
  }
  const reportFileName = `batch-${result.operation}-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
  const reportPath = path23.join(reportsDir, reportFileName);
  fs24.writeFileSync(reportPath, JSON.stringify(reportData, null, 2), "utf8");
  return reportPath;
}
var import_commander46, fs24, path23;
var init_batch = __esm({
  "src/commands/pr/batch.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander46 = require("commander");
    init_pr_status_manager();
    init_pr_file_manager();
    init_relationship_manager();
    init_config_manager();
    init_formatter();
    init_colors();
    init_merge();
    init_close();
    fs24 = __toESM(require("fs"), 1);
    path23 = __toESM(require("path"), 1);
    __name(createPRBatchCommand, "createPRBatchCommand");
    __name(performBatchOperation, "performBatchOperation");
    __name(filterPRs, "filterPRs");
    __name(performBatchMerge, "performBatchMerge");
    __name(performBatchClose, "performBatchClose");
    __name(performBatchApprove, "performBatchApprove");
    __name(performBatchStatusUpdate, "performBatchStatusUpdate");
    __name(performBatchArchive, "performBatchArchive");
    __name(performBatchCreateFromTasks, "performBatchCreateFromTasks");
    __name(getCompletedTasksWithoutPRs, "getCompletedTasksWithoutPRs");
    __name(createPRFromTask, "createPRFromTask");
    __name(createBatchReport, "createBatchReport");
  }
});

// src/commands/pr/dependencies.ts
function createPRDependenciesCommand() {
  const cmd = new import_commander47.Command("deps");
  cmd.description("Manage PR dependencies and blocking relationships");
  cmd.command("add").description("Add a dependency relationship between PRs").argument("<pr-id>", "PR ID that has the dependency").argument("<dependent-pr-id>", "PR ID that this PR depends on").option("-t, --type <type>", "Dependency type (blocks|blocked_by|depends_on|required_by)", "depends_on").option("-r, --reason <reason>", "Reason for the dependency").action(async (prId, dependentPrId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    try {
      const result = await addDependency(
        prId,
        dependentPrId,
        options.type,
        options.reason,
        statusManager,
        relationshipManager,
        configManager
      );
      if (result.success) {
        console.log(colors.green(`\u2705 Added dependency: ${prId} ${options.type} ${dependentPrId}`));
        if (options.reason) {
          console.log(`\u{1F4DD} Reason: ${options.reason}`);
        }
        if (result.warnings.length > 0) {
          console.log(colors.yellow("\u26A0\uFE0F  Warnings:"));
          result.warnings.forEach((warning) => console.log(colors.yellow(`  - ${warning}`)));
        }
      } else {
        console.error(colors.red(`\u274C Failed to add dependency`));
        result.errors.forEach((error) => console.error(colors.red(`  \u2022 ${error}`)));
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error adding dependency: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("remove").description("Remove a dependency relationship between PRs").argument("<pr-id>", "PR ID").argument("<dependent-pr-id>", "Dependent PR ID").option("-t, --type <type>", "Dependency type to remove (blocks|blocked_by|depends_on|required_by)").action(async (prId, dependentPrId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    try {
      const result = await removeDependency(
        prId,
        dependentPrId,
        options.type,
        statusManager,
        relationshipManager,
        configManager
      );
      if (result.success) {
        console.log(colors.green(`\u2705 Removed dependency: ${prId} ${options.type || "all"} ${dependentPrId}`));
      } else {
        console.error(colors.red(`\u274C Failed to remove dependency`));
        result.errors.forEach((error) => console.error(colors.red(`  \u2022 ${error}`)));
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error removing dependency: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("list").description("List PR dependencies").argument("<pr-id>", "PR ID to show dependencies for").option("-a, --all", "Show all dependencies in the project", false).option("-f, --format <format>", "Output format (table|json|graph)", "table").action(async (prId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    const formatter = new Formatter();
    try {
      if (options.all) {
        const allDependencies = await getAllDependencies(statusManager, relationshipManager, configManager);
        displayDependencies(allDependencies, options.format, formatter);
      } else {
        const dependencies = await getPRDependencies(prId, statusManager, relationshipManager, configManager);
        displayPRDependencies(dependencies, options.format, formatter);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error listing dependencies: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("validate").description("Validate PR dependencies for circular references and conflicts").option("-f, --fix", "Attempt to fix validation issues", false).action(async (options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    try {
      const result = await validateDependencies(statusManager, relationshipManager, configManager);
      if (result.valid) {
        console.log(colors.green("\u2705 All PR dependencies are valid"));
      } else {
        console.log(colors.red("\u274C PR dependency validation failed"));
        if (result.errors.length > 0) {
          console.log(colors.red("\nErrors:"));
          result.errors.forEach((error) => console.log(colors.red(`  \u2022 ${error}`)));
        }
        if (result.circularDependencies.length > 0) {
          console.log(colors.red("\nCircular Dependencies:"));
          result.circularDependencies.forEach((cycle) => {
            console.log(colors.red(`  \u2022 ${cycle.join(" \u2192 ")}`));
          });
        }
        if (result.unresolvedDependencies.length > 0) {
          console.log(colors.yellow("\nUnresolved Dependencies:"));
          result.unresolvedDependencies.forEach((dep) => {
            console.log(colors.yellow(`  \u2022 ${dep}`));
          });
        }
        if (result.warnings.length > 0) {
          console.log(colors.yellow("\nWarnings:"));
          result.warnings.forEach((warning) => console.log(colors.yellow(`  \u2022 ${warning}`)));
        }
        if (options.fix) {
          console.log(colors.blue("\n\u{1F527} Attempting to fix issues..."));
          const fixResult = await fixDependencyIssues(result, statusManager, relationshipManager, configManager);
          if (fixResult.success) {
            console.log(colors.green("\u2705 Issues fixed successfully"));
          } else {
            console.log(colors.red("\u274C Failed to fix some issues"));
            fixResult.errors.forEach((error) => console.log(colors.red(`  \u2022 ${error}`)));
          }
        }
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error validating dependencies: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("check-merge").description("Check if a PR can be merged based on dependencies").argument("<pr-id>", "PR ID to check").action(async (prId) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    try {
      const result = await checkMergeability(prId, statusManager, relationshipManager, configManager);
      if (result.canMerge) {
        console.log(colors.green(`\u2705 PR ${prId} can be merged`));
      } else {
        console.log(colors.red(`\u274C PR ${prId} cannot be merged`));
        console.log(colors.red("Blocking reasons:"));
        result.blockingReasons.forEach((reason) => {
          console.log(colors.red(`  \u2022 ${reason}`));
        });
      }
      if (result.blocks.length > 0) {
        console.log(colors.blue(`
\u{1F512} This PR blocks: ${result.blocks.join(", ")}`));
      }
      if (result.blockedBy.length > 0) {
        console.log(colors.yellow(`
\u23F3 This PR is blocked by: ${result.blockedBy.join(", ")}`));
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error checking merge status: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function addDependency(prId, dependentPrId, type, reason, statusManager, relationshipManager, configManager) {
  const result = {
    success: false,
    errors: [],
    warnings: []
  };
  try {
    const pr1 = await statusManager.loadPRData(prId);
    const pr2 = await statusManager.loadPRData(dependentPrId);
    if (!pr1) {
      result.errors.push(`PR ${prId} not found`);
      return result;
    }
    if (!pr2) {
      result.errors.push(`PR ${dependentPrId} not found`);
      return result;
    }
    const wouldCreateCircle = await wouldCreateCircularDependency(
      prId,
      dependentPrId,
      type,
      statusManager,
      relationshipManager,
      configManager
    );
    if (wouldCreateCircle) {
      result.errors.push(`Adding this dependency would create a circular dependency`);
      return result;
    }
    const dependency = {
      prId,
      dependentPrId,
      type,
      reason,
      created: (/* @__PURE__ */ new Date()).toISOString(),
      createdBy: "system"
      // This would be the current user
    };
    await saveDependency(dependency, configManager);
    await updatePRWithDependency(pr1, dependency, "outgoing", configManager);
    await updatePRWithDependency(pr2, dependency, "incoming", configManager);
    result.success = true;
    if (pr1.pr_status === "merged" || pr2.pr_status === "merged") {
      result.warnings.push("One or both PRs are already merged - this dependency may be obsolete");
    }
    return result;
  } catch (error) {
    result.errors.push(`Failed to add dependency: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
async function removeDependency(prId, dependentPrId, type, statusManager, relationshipManager, configManager) {
  const result = {
    success: false,
    errors: []
  };
  try {
    const dependencies = await loadDependencies(configManager);
    const toRemove = dependencies.filter(
      (dep) => dep.prId === prId && dep.dependentPrId === dependentPrId && (!type || dep.type === type)
    );
    if (toRemove.length === 0) {
      result.errors.push("No matching dependency found");
      return result;
    }
    const remaining = dependencies.filter((dep) => !toRemove.includes(dep));
    await saveDependencies(remaining, configManager);
    result.success = true;
    return result;
  } catch (error) {
    result.errors.push(`Failed to remove dependency: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
async function getPRDependencies(prId, statusManager, relationshipManager, configManager) {
  const dependencies = await loadDependencies(configManager);
  const graph = {
    prId,
    blocks: [],
    blockedBy: [],
    dependsOn: [],
    requiredBy: [],
    canMerge: true,
    blockingReasons: []
  };
  dependencies.forEach((dep) => {
    if (dep.prId === prId) {
      switch (dep.type) {
        case "blocks":
          graph.blocks.push(dep.dependentPrId);
          break;
        case "depends_on":
          graph.dependsOn.push(dep.dependentPrId);
          break;
        case "required_by":
          graph.requiredBy.push(dep.dependentPrId);
          break;
      }
    }
    if (dep.dependentPrId === prId) {
      switch (dep.type) {
        case "blocked_by":
          graph.blockedBy.push(dep.prId);
          break;
        case "depends_on":
          graph.blockedBy.push(dep.prId);
          break;
        case "required_by":
          graph.blocks.push(dep.prId);
          break;
      }
    }
  });
  if (graph.blockedBy.length > 0) {
    graph.canMerge = false;
    graph.blockingReasons.push(`Blocked by PRs: ${graph.blockedBy.join(", ")}`);
  }
  return graph;
}
async function getAllDependencies(statusManager, relationshipManager, configManager) {
  return await loadDependencies(configManager);
}
async function validateDependencies(statusManager, relationshipManager, configManager) {
  const result = {
    valid: true,
    errors: [],
    warnings: [],
    circularDependencies: [],
    unresolvedDependencies: []
  };
  try {
    const dependencies = await loadDependencies(configManager);
    const cycles = findCircularDependencies(dependencies);
    if (cycles.length > 0) {
      result.valid = false;
      result.circularDependencies = cycles;
      result.errors.push(`Found ${cycles.length} circular dependencies`);
    }
    const allPRs = await statusManager.listPRs();
    const prIds = new Set(allPRs.map((pr) => pr.pr_id));
    dependencies.forEach((dep) => {
      if (!prIds.has(dep.prId)) {
        result.unresolvedDependencies.push(`${dep.prId} (referenced in dependency)`);
      }
      if (!prIds.has(dep.dependentPrId)) {
        result.unresolvedDependencies.push(`${dep.dependentPrId} (referenced in dependency)`);
      }
    });
    if (result.unresolvedDependencies.length > 0) {
      result.valid = false;
      result.errors.push(`Found ${result.unresolvedDependencies.length} unresolved dependencies`);
    }
    return result;
  } catch (error) {
    result.valid = false;
    result.errors.push(`Validation failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
async function checkMergeability(prId, statusManager, relationshipManager, configManager) {
  return await getPRDependencies(prId, statusManager, relationshipManager, configManager);
}
async function wouldCreateCircularDependency(prId, dependentPrId, type, statusManager, relationshipManager, configManager) {
  const dependencies = await loadDependencies(configManager);
  const proposedDep = {
    prId,
    dependentPrId,
    type,
    created: (/* @__PURE__ */ new Date()).toISOString(),
    createdBy: "system"
  };
  const allDeps = [...dependencies, proposedDep];
  const cycles = findCircularDependencies(allDeps);
  return cycles.length > 0;
}
function findCircularDependencies(dependencies) {
  const graph = /* @__PURE__ */ new Map();
  dependencies.forEach((dep) => {
    if (!graph.has(dep.prId)) {
      graph.set(dep.prId, /* @__PURE__ */ new Set());
    }
    graph.get(dep.prId).add(dep.dependentPrId);
  });
  const cycles = [];
  const visited = /* @__PURE__ */ new Set();
  const recursionStack = /* @__PURE__ */ new Set();
  function dfs(node, path31) {
    if (recursionStack.has(node)) {
      const cycleStart = path31.indexOf(node);
      if (cycleStart !== -1) {
        cycles.push([...path31.slice(cycleStart), node]);
      }
      return;
    }
    if (visited.has(node)) {
      return;
    }
    visited.add(node);
    recursionStack.add(node);
    path31.push(node);
    const neighbors = graph.get(node);
    if (neighbors) {
      for (const neighbor of neighbors) {
        dfs(neighbor, path31);
      }
    }
    path31.pop();
    recursionStack.delete(node);
  }
  __name(dfs, "dfs");
  for (const node of graph.keys()) {
    if (!visited.has(node)) {
      dfs(node, []);
    }
  }
  return cycles;
}
async function loadDependencies(configManager) {
  const depsPath = path24.join(configManager.getPRsDirectory(), "dependencies.json");
  if (!fs25.existsSync(depsPath)) {
    return [];
  }
  const content = fs25.readFileSync(depsPath, "utf8");
  return JSON.parse(content);
}
async function saveDependencies(dependencies, configManager) {
  const depsPath = path24.join(configManager.getPRsDirectory(), "dependencies.json");
  fs25.writeFileSync(depsPath, JSON.stringify(dependencies, null, 2), "utf8");
}
async function saveDependency(dependency, configManager) {
  const dependencies = await loadDependencies(configManager);
  dependencies.push(dependency);
  await saveDependencies(dependencies, configManager);
}
async function updatePRWithDependency(pr, dependency, direction, configManager) {
  try {
    const prContent = fs25.readFileSync(pr.file_path, "utf8");
    const dependencyNote = direction === "outgoing" ? `${dependency.type} ${dependency.dependentPrId}` : `${dependency.type} ${dependency.prId}`;
    const updatedContent = prContent.replace(
      /updated_date:\s*[^\n]+/,
      `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`
    );
    const dependencySection = `

## Dependencies

- ${dependencyNote}${dependency.reason ? ` (${dependency.reason})` : ""}
`;
    const finalContent = updatedContent + dependencySection;
    fs25.writeFileSync(pr.file_path, finalContent, "utf8");
  } catch (error) {
    console.error(`Failed to update PR ${pr.pr_id} with dependency info: ${error}`);
  }
}
async function fixDependencyIssues(validationResult, statusManager, relationshipManager, configManager) {
  const result = {
    success: false,
    errors: []
  };
  try {
    const dependencies = await loadDependencies(configManager);
    let fixedDependencies = [...dependencies];
    if (validationResult.unresolvedDependencies.length > 0) {
      const allPRs = await statusManager.listPRs();
      const prIds = new Set(allPRs.map((pr) => pr.pr_id));
      fixedDependencies = fixedDependencies.filter(
        (dep) => prIds.has(dep.prId) && prIds.has(dep.dependentPrId)
      );
    }
    if (validationResult.circularDependencies.length > 0) {
      for (const cycle of validationResult.circularDependencies) {
        if (cycle.length > 1) {
          const lastPr = cycle[cycle.length - 1];
          const firstPr = cycle[0];
          fixedDependencies = fixedDependencies.filter(
            (dep) => !(dep.prId === lastPr && dep.dependentPrId === firstPr)
          );
        }
      }
    }
    await saveDependencies(fixedDependencies, configManager);
    result.success = true;
    return result;
  } catch (error) {
    result.errors.push(`Failed to fix dependency issues: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
function displayDependencies(dependencies, format, formatter) {
  if (format === "json") {
    console.log(JSON.stringify(dependencies, null, 2));
  } else if (format === "table") {
    console.table(dependencies.map((dep) => ({
      "PR ID": dep.prId,
      "Dependent PR": dep.dependentPrId,
      "Type": dep.type,
      "Reason": dep.reason || "N/A",
      "Created": dep.created.split("T")[0]
    })));
  } else {
    console.log(colors.blue("PR Dependency Graph:"));
    dependencies.forEach((dep) => {
      console.log(`${dep.prId} --${dep.type}--> ${dep.dependentPrId}`);
    });
  }
}
function displayPRDependencies(dependencies, format, formatter) {
  if (format === "json") {
    console.log(JSON.stringify(dependencies, null, 2));
  } else {
    console.log(colors.blue(`Dependencies for PR ${dependencies.prId}:`));
    if (dependencies.blocks.length > 0) {
      console.log(colors.red(`\u{1F512} Blocks: ${dependencies.blocks.join(", ")}`));
    }
    if (dependencies.blockedBy.length > 0) {
      console.log(colors.yellow(`\u23F3 Blocked by: ${dependencies.blockedBy.join(", ")}`));
    }
    if (dependencies.dependsOn.length > 0) {
      console.log(colors.cyan(`\u{1F4CE} Depends on: ${dependencies.dependsOn.join(", ")}`));
    }
    if (dependencies.requiredBy.length > 0) {
      console.log(colors.green(`\u{1F517} Required by: ${dependencies.requiredBy.join(", ")}`));
    }
    const canMergeColor = dependencies.canMerge ? colors.green : colors.red;
    const canMergeIcon = dependencies.canMerge ? "\u2705" : "\u274C";
    console.log(canMergeColor(`${canMergeIcon} Can merge: ${dependencies.canMerge}`));
    if (dependencies.blockingReasons.length > 0) {
      console.log(colors.red("Blocking reasons:"));
      dependencies.blockingReasons.forEach((reason) => {
        console.log(colors.red(`  \u2022 ${reason}`));
      });
    }
  }
}
var import_commander47, fs25, path24;
var init_dependencies = __esm({
  "src/commands/pr/dependencies.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander47 = require("commander");
    init_pr_status_manager();
    init_relationship_manager();
    init_config_manager();
    init_formatter();
    init_colors();
    fs25 = __toESM(require("fs"), 1);
    path24 = __toESM(require("path"), 1);
    __name(createPRDependenciesCommand, "createPRDependenciesCommand");
    __name(addDependency, "addDependency");
    __name(removeDependency, "removeDependency");
    __name(getPRDependencies, "getPRDependencies");
    __name(getAllDependencies, "getAllDependencies");
    __name(validateDependencies, "validateDependencies");
    __name(checkMergeability, "checkMergeability");
    __name(wouldCreateCircularDependency, "wouldCreateCircularDependency");
    __name(findCircularDependencies, "findCircularDependencies");
    __name(loadDependencies, "loadDependencies");
    __name(saveDependencies, "saveDependencies");
    __name(saveDependency, "saveDependency");
    __name(updatePRWithDependency, "updatePRWithDependency");
    __name(fixDependencyIssues, "fixDependencyIssues");
    __name(displayDependencies, "displayDependencies");
    __name(displayPRDependencies, "displayPRDependencies");
  }
});

// src/commands/pr/sync.ts
function createPRSyncCommand() {
  const cmd = new import_commander48.Command("sync");
  cmd.description("Synchronize PR and task statuses");
  cmd.option("-d, --direction <direction>", "Sync direction (pr-to-task|task-to-pr|bidirectional)", "bidirectional").option("--auto-create", "Automatically create missing PRs or tasks", false).option("--auto-complete", "Automatically complete tasks when PRs are merged", false).option("--update-descriptions", "Update descriptions during sync", false).option("--sync-timestamps", "Sync timestamps between PRs and tasks", false).option("--sync-assignees", "Sync assignees between PRs and tasks", false).option("--force", "Force sync even when conflicts exist", false).option("--dry-run", "Show what would be synced without executing", false).action(async (options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    const formatter = new Formatter();
    const syncOptions = {
      direction: options.direction,
      autoCreate: options.autoCreate,
      autoComplete: options.autoComplete,
      updateDescriptions: options.updateDescriptions,
      syncTimestamps: options.syncTimestamps,
      syncAssignees: options.syncAssignees,
      dryRun: options.dryRun,
      force: options.force
    };
    try {
      const result = await performSync(
        syncOptions,
        statusManager,
        relationshipManager,
        configManager
      );
      if (options.dryRun) {
        console.log(colors.yellow("\u{1F50D} Sync dry run - showing what would be done:"));
        console.log("");
      }
      displaySyncResult(result);
      if (!result.success) {
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Sync failed: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("status").description("Show current sync status between PRs and tasks").option("-f, --format <format>", "Output format (table|json)", "table").option("--conflicts-only", "Show only conflicts", false).action(async (options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    const formatter = new Formatter();
    try {
      const mappings = await getSyncMappings(statusManager, relationshipManager, configManager);
      if (options.conflictsOnly) {
        const conflicts = mappings.filter((m) => m.syncDirection === "conflict");
        displaySyncMappings(conflicts, options.format, formatter);
      } else {
        displaySyncMappings(mappings, options.format, formatter);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error getting sync status: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("force").description("Force synchronization of a specific PR-task pair").argument("<pr-id>", "PR ID").argument("<task-id>", "Task ID").option("-d, --direction <direction>", "Sync direction (pr-to-task|task-to-pr)", "pr-to-task").action(async (prId, taskId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const relationshipManager = new RelationshipManager(configManager);
    try {
      const result = await forceSyncPRTask(
        prId,
        taskId,
        options.direction,
        statusManager,
        relationshipManager,
        configManager
      );
      if (result.success) {
        console.log(colors.green(`\u2705 Successfully synced ${prId} \u2194 ${taskId}`));
        console.log(`\u{1F4CB} Direction: ${options.direction}`);
        if (result.changes && result.changes.length > 0) {
          console.log("\u{1F4DD} Changes:");
          result.changes.forEach((change) => console.log(`  - ${change}`));
        }
      } else {
        console.error(colors.red(`\u274C Failed to sync ${prId} \u2194 ${taskId}`));
        if (result.error) {
          console.error(colors.red(`  Error: ${result.error}`));
        }
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error during force sync: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function performSync(options, statusManager, relationshipManager, configManager) {
  const result = {
    success: false,
    direction: options.direction,
    totalPRs: 0,
    totalTasks: 0,
    syncedPRs: 0,
    syncedTasks: 0,
    createdPRs: 0,
    createdTasks: 0,
    updatedPRs: 0,
    updatedTasks: 0,
    completedTasks: 0,
    errors: [],
    warnings: [],
    details: []
  };
  try {
    const mappings = await getSyncMappings(statusManager, relationshipManager, configManager);
    result.totalPRs = new Set(mappings.map((m) => m.prId)).size;
    result.totalTasks = new Set(mappings.map((m) => m.taskId)).size;
    console.log(colors.blue(`\u{1F504} Starting sync operation: ${options.direction}`));
    console.log(`\u{1F4CA} Found ${mappings.length} PR-task relationships`);
    const needsSync = mappings.filter((m) => m.syncRequired || options.force);
    if (needsSync.length === 0) {
      console.log(colors.green("\u2705 All PRs and tasks are already synchronized"));
      result.success = true;
      return result;
    }
    console.log(colors.yellow(`\u26A0\uFE0F  ${needsSync.length} relationships need synchronization`));
    for (const mapping of needsSync) {
      const detail = await syncPRTask(mapping, options, statusManager, relationshipManager, configManager);
      result.details.push(detail);
      if (detail.success) {
        if (detail.action.includes("updated PR")) result.updatedPRs++;
        if (detail.action.includes("updated task")) result.updatedTasks++;
        if (detail.action.includes("completed task")) result.completedTasks++;
        if (detail.action.includes("created PR")) result.createdPRs++;
        if (detail.action.includes("created task")) result.createdTasks++;
      } else {
        result.errors.push(`${mapping.prId} \u2194 ${mapping.taskId}: ${detail.error}`);
      }
    }
    result.syncedPRs = result.updatedPRs + result.createdPRs;
    result.syncedTasks = result.updatedTasks + result.createdTasks;
    result.success = result.errors.length === 0;
    return result;
  } catch (error) {
    result.errors.push(`Sync operation failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
async function getSyncMappings(statusManager, relationshipManager, configManager) {
  const mappings = [];
  const allPRs = await statusManager.listPRs();
  for (const pr of allPRs) {
    const linkedTasks = await relationshipManager.getLinkedTasks(pr.pr_id);
    for (const taskId of linkedTasks) {
      const task = await loadTaskData(taskId, configManager);
      if (task) {
        const mapping = createSyncMapping(pr, task);
        mappings.push(mapping);
      }
    }
  }
  return mappings;
}
function createSyncMapping(pr, task) {
  const mapping = {
    prId: pr.pr_id,
    taskId: task.task_id,
    issueId: task.issue_id,
    prStatus: pr.pr_status,
    taskStatus: task.status,
    prAssignee: pr.assignee,
    taskAssignee: task.assignee,
    prUpdated: pr.updated_date,
    taskUpdated: task.updated_date,
    syncRequired: false,
    syncDirection: "pr-to-task",
    conflictReasons: []
  };
  const prNewer = new Date(pr.updated_date) > new Date(task.updated_date);
  const taskNewer = new Date(task.updated_date) > new Date(pr.updated_date);
  const statusMismatch = !isStatusSynced(pr.pr_status, task.status);
  const assigneeMismatch = pr.assignee !== task.assignee;
  if (statusMismatch || assigneeMismatch) {
    mapping.syncRequired = true;
    if (prNewer) {
      mapping.syncDirection = "pr-to-task";
    } else if (taskNewer) {
      mapping.syncDirection = "task-to-pr";
    } else {
      mapping.syncDirection = "conflict";
      mapping.conflictReasons.push("Same timestamp but different status/assignee");
    }
  }
  if (statusMismatch && !canSyncStatus(pr.pr_status, task.status)) {
    mapping.syncDirection = "conflict";
    mapping.conflictReasons.push(`Cannot sync status: ${pr.pr_status} \u2194 ${task.status}`);
  }
  return mapping;
}
function isStatusSynced(prStatus, taskStatus) {
  const syncMap = {
    "draft": "planning",
    "open": "active",
    "review": "active",
    "approved": "active",
    "merged": "completed",
    "closed": "archived"
  };
  return syncMap[prStatus] === taskStatus;
}
function canSyncStatus(prStatus, taskStatus) {
  var _a;
  const allowedTransitions = {
    "draft": ["planning", "active"],
    "open": ["active"],
    "review": ["active"],
    "approved": ["active", "completed"],
    "merged": ["completed"],
    "closed": ["archived"]
  };
  return ((_a = allowedTransitions[prStatus]) == null ? void 0 : _a.includes(taskStatus)) || false;
}
async function syncPRTask(mapping, options, statusManager, relationshipManager, configManager) {
  const detail = {
    prId: mapping.prId,
    taskId: mapping.taskId,
    action: "sync",
    success: false,
    message: "",
    changes: []
  };
  try {
    if (mapping.syncDirection === "conflict" && !options.force) {
      detail.message = `Conflict detected: ${mapping.conflictReasons.join(", ")}`;
      detail.error = "Use --force to override conflicts";
      return detail;
    }
    const pr = await statusManager.loadPRData(mapping.prId);
    const task = await loadTaskData(mapping.taskId, configManager);
    if (!pr || !task) {
      detail.error = `Could not load PR ${mapping.prId} or task ${mapping.taskId}`;
      return detail;
    }
    let syncDirection = mapping.syncDirection;
    if (options.direction !== "bidirectional") {
      syncDirection = options.direction;
    }
    const changes = [];
    if (syncDirection === "pr-to-task" || syncDirection === "conflict") {
      if (pr.pr_status !== mapping.prStatus || options.force) {
        const newTaskStatus = getTaskStatusFromPR(pr.pr_status);
        if (!options.dryRun) {
          await updateTaskStatus(task, newTaskStatus, configManager);
        }
        changes.push(`Updated task status: ${task.status} \u2192 ${newTaskStatus}`);
        if (options.autoComplete && pr.pr_status === "merged") {
          if (!options.dryRun) {
            await updateTaskStatus(task, "completed", configManager);
          }
          changes.push("Auto-completed task (PR merged)");
        }
      }
      if (options.syncAssignees && pr.assignee !== task.assignee) {
        if (!options.dryRun) {
          await updateTaskAssignee(task, pr.assignee, configManager);
        }
        changes.push(`Updated task assignee: ${task.assignee} \u2192 ${pr.assignee}`);
      }
    }
    if (syncDirection === "task-to-pr" || syncDirection === "conflict") {
      if (task.status !== mapping.taskStatus || options.force) {
        const newPRStatus = getPRStatusFromTask(task.status);
        if (!options.dryRun) {
          await statusManager.updatePRStatus(pr.pr_id, newPRStatus);
        }
        changes.push(`Updated PR status: ${pr.pr_status} \u2192 ${newPRStatus}`);
      }
      if (options.syncAssignees && task.assignee !== pr.assignee) {
        if (!options.dryRun) {
          await updatePRAssignee(pr, task.assignee, configManager);
        }
        changes.push(`Updated PR assignee: ${pr.assignee} \u2192 ${task.assignee}`);
      }
    }
    if (options.syncTimestamps) {
      const latestDate = new Date(Math.max(
        new Date(pr.updated_date).getTime(),
        new Date(task.updated_date).getTime()
      )).toISOString();
      if (!options.dryRun) {
        await updateTimestamps(pr, task, latestDate, configManager);
      }
      changes.push(`Synced timestamps to: ${latestDate}`);
    }
    detail.success = true;
    detail.changes = changes;
    detail.message = changes.length > 0 ? `Synced successfully (${changes.length} changes)` : "Already in sync";
    detail.action = `synced ${syncDirection}`;
    return detail;
  } catch (error) {
    detail.error = error instanceof Error ? error.message : String(error);
    detail.message = "Sync failed";
    return detail;
  }
}
function getTaskStatusFromPR(prStatus) {
  const statusMap = {
    "draft": "planning",
    "open": "active",
    "review": "active",
    "approved": "active",
    "merged": "completed",
    "closed": "archived"
  };
  return statusMap[prStatus] || "active";
}
function getPRStatusFromTask(taskStatus) {
  const statusMap = {
    "planning": "draft",
    "active": "open",
    "completed": "merged",
    "archived": "closed"
  };
  return statusMap[taskStatus] || "open";
}
async function loadTaskData(taskId, configManager) {
  try {
    const tasksDir = configManager.getTasksDirectory();
    const taskFiles = fs26.readdirSync(tasksDir).filter((file) => file.includes(taskId));
    if (taskFiles.length === 0) {
      return null;
    }
    const taskFile = taskFiles[0];
    const taskPath = path25.join(tasksDir, taskFile);
    const content = fs26.readFileSync(taskPath, "utf8");
    return {
      task_id: taskId,
      issue_id: "ISSUE-001",
      epic_id: "EPIC-001",
      title: "Task Title",
      description: "Task Description",
      status: "active",
      priority: "medium",
      assignee: "system",
      created_date: (/* @__PURE__ */ new Date()).toISOString(),
      updated_date: (/* @__PURE__ */ new Date()).toISOString(),
      estimated_tokens: 0,
      actual_tokens: 0,
      ai_context: [],
      sync_status: "local",
      content,
      file_path: taskPath
    };
  } catch (error) {
    console.error(`Error loading task ${taskId}:`, error);
    return null;
  }
}
async function updateTaskStatus(task, newStatus, configManager) {
  try {
    const content = fs26.readFileSync(task.file_path, "utf8");
    const updatedContent = content.replace(/status:\s*\w+/, `status: ${newStatus}`).replace(/updated_date:\s*[^\n]+/, `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`);
    fs26.writeFileSync(task.file_path, updatedContent, "utf8");
  } catch (error) {
    console.error(`Error updating task ${task.task_id}:`, error);
  }
}
async function updateTaskAssignee(task, newAssignee, configManager) {
  try {
    const content = fs26.readFileSync(task.file_path, "utf8");
    const updatedContent = content.replace(/assignee:\s*[^\n]+/, `assignee: ${newAssignee}`).replace(/updated_date:\s*[^\n]+/, `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`);
    fs26.writeFileSync(task.file_path, updatedContent, "utf8");
  } catch (error) {
    console.error(`Error updating task assignee ${task.task_id}:`, error);
  }
}
async function updatePRAssignee(pr, newAssignee, configManager) {
  try {
    const content = fs26.readFileSync(pr.file_path, "utf8");
    const updatedContent = content.replace(/assignee:\s*[^\n]+/, `assignee: ${newAssignee}`).replace(/updated_date:\s*[^\n]+/, `updated_date: ${(/* @__PURE__ */ new Date()).toISOString()}`);
    fs26.writeFileSync(pr.file_path, updatedContent, "utf8");
  } catch (error) {
    console.error(`Error updating PR assignee ${pr.pr_id}:`, error);
  }
}
async function updateTimestamps(pr, task, timestamp, configManager) {
  try {
    const prContent = fs26.readFileSync(pr.file_path, "utf8");
    const updatedPRContent = prContent.replace(/updated_date:\s*[^\n]+/, `updated_date: ${timestamp}`);
    fs26.writeFileSync(pr.file_path, updatedPRContent, "utf8");
    const taskContent = fs26.readFileSync(task.file_path, "utf8");
    const updatedTaskContent = taskContent.replace(/updated_date:\s*[^\n]+/, `updated_date: ${timestamp}`);
    fs26.writeFileSync(task.file_path, updatedTaskContent, "utf8");
  } catch (error) {
    console.error(`Error updating timestamps for ${pr.pr_id} \u2194 ${task.task_id}:`, error);
  }
}
async function forceSyncPRTask(prId, taskId, direction, statusManager, relationshipManager, configManager) {
  const pr = await statusManager.loadPRData(prId);
  const task = await loadTaskData(taskId, configManager);
  if (!pr || !task) {
    return {
      prId,
      taskId,
      action: "force-sync",
      success: false,
      message: "PR or task not found",
      error: `Could not load PR ${prId} or task ${taskId}`
    };
  }
  const mapping = createSyncMapping(pr, task);
  const syncOptions = {
    direction,
    autoCreate: false,
    autoComplete: true,
    updateDescriptions: false,
    syncTimestamps: true,
    syncAssignees: true,
    dryRun: false,
    force: true
  };
  return await syncPRTask(mapping, syncOptions, statusManager, relationshipManager, configManager);
}
function displaySyncResult(result) {
  console.log(colors.cyan(`
\u{1F4CA} Sync operation completed`));
  console.log(`\u{1F3AF} Direction: ${result.direction}`);
  console.log(`\u{1F4CB} Total PRs: ${result.totalPRs}`);
  console.log(`\u{1F4DD} Total Tasks: ${result.totalTasks}`);
  console.log(`\u{1F504} Synced PRs: ${result.syncedPRs}`);
  console.log(`\u{1F504} Synced Tasks: ${result.syncedTasks}`);
  if (result.createdPRs > 0) {
    console.log(`\u2795 Created PRs: ${result.createdPRs}`);
  }
  if (result.createdTasks > 0) {
    console.log(`\u2795 Created Tasks: ${result.createdTasks}`);
  }
  if (result.completedTasks > 0) {
    console.log(`\u2705 Completed Tasks: ${result.completedTasks}`);
  }
  if (result.details.length > 0) {
    console.log("\n\u{1F4CB} Sync Details:");
    result.details.forEach((detail) => {
      const icon = detail.success ? "\u2705" : "\u274C";
      const color = detail.success ? colors.green : colors.red;
      console.log(color(`${icon} ${detail.prId} \u2194 ${detail.taskId}: ${detail.message}`));
      if (detail.changes && detail.changes.length > 0) {
        detail.changes.forEach((change) => {
          console.log(colors.blue(`    - ${change}`));
        });
      }
    });
  }
  if (result.warnings.length > 0) {
    console.log(colors.yellow("\n\u26A0\uFE0F  Warnings:"));
    result.warnings.forEach((warning) => {
      console.log(colors.yellow(`  - ${warning}`));
    });
  }
  if (result.errors.length > 0) {
    console.log(colors.red("\n\u274C Errors:"));
    result.errors.forEach((error) => {
      console.log(colors.red(`  - ${error}`));
    });
  }
  const successColor = result.success ? colors.green : colors.red;
  const successIcon = result.success ? "\u2705" : "\u274C";
  console.log(successColor(`
${successIcon} Sync ${result.success ? "completed successfully" : "failed"}`));
}
function displaySyncMappings(mappings, format, formatter) {
  if (format === "json") {
    console.log(JSON.stringify(mappings, null, 2));
  } else {
    console.log(colors.blue(`
\u{1F4CA} PR-Task Sync Status (${mappings.length} relationships)`));
    console.table(mappings.map((mapping) => ({
      "PR ID": mapping.prId,
      "Task ID": mapping.taskId,
      "PR Status": mapping.prStatus,
      "Task Status": mapping.taskStatus,
      "Sync Required": mapping.syncRequired ? "Yes" : "No",
      "Direction": mapping.syncDirection,
      "Conflicts": mapping.conflictReasons.length > 0 ? mapping.conflictReasons.join(", ") : "None"
    })));
    const needsSync = mappings.filter((m) => m.syncRequired).length;
    const conflicts = mappings.filter((m) => m.syncDirection === "conflict").length;
    console.log(colors.cyan(`
\u{1F4C8} Summary:`));
    console.log(`\u{1F504} Needs Sync: ${needsSync}`);
    console.log(`\u26A0\uFE0F  Conflicts: ${conflicts}`);
    console.log(`\u2705 In Sync: ${mappings.length - needsSync}`);
  }
}
var import_commander48, fs26, path25;
var init_sync2 = __esm({
  "src/commands/pr/sync.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander48 = require("commander");
    init_pr_status_manager();
    init_relationship_manager();
    init_config_manager();
    init_formatter();
    init_colors();
    fs26 = __toESM(require("fs"), 1);
    path25 = __toESM(require("path"), 1);
    __name(createPRSyncCommand, "createPRSyncCommand");
    __name(performSync, "performSync");
    __name(getSyncMappings, "getSyncMappings");
    __name(createSyncMapping, "createSyncMapping");
    __name(isStatusSynced, "isStatusSynced");
    __name(canSyncStatus, "canSyncStatus");
    __name(syncPRTask, "syncPRTask");
    __name(getTaskStatusFromPR, "getTaskStatusFromPR");
    __name(getPRStatusFromTask, "getPRStatusFromTask");
    __name(loadTaskData, "loadTaskData");
    __name(updateTaskStatus, "updateTaskStatus");
    __name(updateTaskAssignee, "updateTaskAssignee");
    __name(updatePRAssignee, "updatePRAssignee");
    __name(updateTimestamps, "updateTimestamps");
    __name(forceSyncPRTask, "forceSyncPRTask");
    __name(displaySyncResult, "displaySyncResult");
    __name(displaySyncMappings, "displaySyncMappings");
  }
});

// src/commands/pr/archive.ts
function createPRArchiveCommand() {
  const cmd = new import_commander49.Command("archive");
  cmd.description("Archive old or closed PRs for long-term storage");
  cmd.option("-d, --days <days>", "Archive PRs older than specified days", "90").option("-s, --status <status>", "Archive PRs with specific status (comma-separated)", "merged,closed").option("--include-reviews", "Include review files in archive", false).option("--compress", "Compress archived files", false).option("--create-index", "Create searchable index of archived PRs", false).option("--preserve-structure", "Preserve directory structure in archive", false).option("--force", "Force archive even if files are recent", false).option("--dry-run", "Show what would be archived without executing", false).action(async (options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const fileManager = new PRFileManager(configManager);
    const formatter = new Formatter();
    const archiveOptions = {
      olderThanDays: parseInt(options.days),
      status: options.status.split(","),
      includeReviews: options.includeReviews,
      compress: options.compress,
      createIndex: options.createIndex,
      preserveStructure: options.preserveStructure,
      dryRun: options.dryRun,
      force: options.force
    };
    try {
      const result = await performArchive(archiveOptions, statusManager, fileManager, configManager);
      if (options.dryRun) {
        console.log(colors.yellow("\u{1F50D} Archive dry run - showing what would be archived:"));
        console.log("");
      }
      displayArchiveResult(result);
      if (!result.success) {
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Archive failed: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("list").description("List archived PRs").option("-f, --format <format>", "Output format (table|json)", "table").option("--search <query>", "Search archived PRs").action(async (options) => {
    const configManager = new ConfigManager2();
    const formatter = new Formatter();
    try {
      const archived = await listArchivedPRs(configManager, options.search);
      displayArchivedPRs(archived, options.format, formatter);
    } catch (error) {
      console.error(colors.red(`\u274C Error listing archived PRs: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("restore").description("Restore an archived PR").argument("<pr-id>", "PR ID to restore").option("--to-status <status>", "Restore to specific status", "closed").action(async (prId, options) => {
    const configManager = new ConfigManager2();
    const statusManager = new PRStatusManager(configManager);
    const fileManager = new PRFileManager(configManager);
    try {
      const result = await restorePR(prId, options.toStatus, statusManager, fileManager, configManager);
      if (result.success) {
        console.log(colors.green(`\u2705 Successfully restored PR ${prId}`));
        console.log(`\u{1F4C1} Restored to: ${result.restoredPath}`);
        console.log(`\u{1F4CB} Status: ${options.toStatus}`);
      } else {
        console.error(colors.red(`\u274C Failed to restore PR ${prId}`));
        result.errors.forEach((error) => console.error(colors.red(`  \u2022 ${error}`)));
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error restoring PR: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  cmd.command("cleanup").description("Clean up archive by removing very old files").option("-d, --days <days>", "Remove archives older than specified days", "365").option("--force", "Force cleanup without confirmation", false).action(async (options) => {
    const configManager = new ConfigManager2();
    try {
      const result = await cleanupArchive(parseInt(options.days), options.force, configManager);
      if (result.success) {
        console.log(colors.green(`\u2705 Archive cleanup completed`));
        console.log(`\u{1F5D1}\uFE0F  Removed ${result.removedCount} old archives`);
        console.log(`\u{1F4BE} Freed ${formatBytes(result.freedSpace)} of space`);
      } else {
        console.error(colors.red(`\u274C Archive cleanup failed`));
        result.errors.forEach((error) => console.error(colors.red(`  \u2022 ${error}`)));
        process.exit(1);
      }
    } catch (error) {
      console.error(colors.red(`\u274C Error during cleanup: ${error instanceof Error ? error.message : String(error)}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function performArchive(options, statusManager, fileManager, configManager) {
  const result = {
    success: false,
    archivedPRs: 0,
    archivedReviews: 0,
    totalSizeBefore: 0,
    totalSizeAfter: 0,
    compressionRatio: 0,
    archivePath: "",
    errors: [],
    warnings: [],
    details: []
  };
  try {
    const basePRsDir = configManager.getPRsDirectory();
    const archiveDir = path26.join(basePRsDir, "archive");
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const archivePath = path26.join(archiveDir, `archive-${timestamp}`);
    if (!options.dryRun) {
      if (!fs27.existsSync(archiveDir)) {
        fs27.mkdirSync(archiveDir, { recursive: true });
      }
      if (!fs27.existsSync(archivePath)) {
        fs27.mkdirSync(archivePath, { recursive: true });
      }
    }
    result.archivePath = archivePath;
    const candidatePRs = await findArchiveCandidates(options, statusManager, configManager);
    console.log(colors.blue(`\u{1F504} Found ${candidatePRs.length} PRs matching archive criteria`));
    if (candidatePRs.length === 0) {
      console.log(colors.green("\u2705 No PRs need archiving"));
      result.success = true;
      return result;
    }
    for (const pr of candidatePRs) {
      const stats = fs27.statSync(pr.file_path);
      result.totalSizeBefore += stats.size;
    }
    for (const pr of candidatePRs) {
      const detail = await archivePR(pr, archivePath, options, configManager);
      result.details.push(detail);
      if (detail.archived) {
        result.archivedPRs++;
        result.totalSizeAfter += detail.sizeBytes;
      } else {
        result.warnings.push(`Failed to archive ${pr.pr_id}: ${detail.reason}`);
      }
    }
    if (options.includeReviews) {
      const reviewCount = await archiveReviewFiles(archivePath, options, configManager);
      result.archivedReviews = reviewCount;
    }
    if (result.totalSizeBefore > 0) {
      result.compressionRatio = (result.totalSizeBefore - result.totalSizeAfter) / result.totalSizeBefore;
    }
    if (options.createIndex && !options.dryRun) {
      const indexPath = await createArchiveIndex(candidatePRs, archivePath, result, configManager);
      result.indexPath = indexPath;
    }
    if (options.compress && !options.dryRun) {
      await compressArchive(archivePath, configManager);
    }
    result.success = result.errors.length === 0;
    return result;
  } catch (error) {
    result.errors.push(`Archive operation failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
async function findArchiveCandidates(options, statusManager, configManager) {
  const allPRs = await statusManager.listPRs();
  const cutoffDate = /* @__PURE__ */ new Date();
  cutoffDate.setDate(cutoffDate.getDate() - options.olderThanDays);
  return allPRs.filter((pr) => {
    if (!options.status.includes(pr.pr_status)) {
      return false;
    }
    if (!options.force) {
      const prDate = new Date(pr.updated_date);
      if (prDate > cutoffDate) {
        return false;
      }
    }
    return true;
  });
}
async function archivePR(pr, archivePath, options, configManager) {
  const detail = {
    prId: pr.pr_id,
    originalPath: pr.file_path,
    archivePath: "",
    sizeBytes: 0,
    archived: false
  };
  try {
    const stats = fs27.statSync(pr.file_path);
    detail.sizeBytes = stats.size;
    const fileName = path26.basename(pr.file_path);
    let targetPath;
    if (options.preserveStructure) {
      const relativePath = path26.relative(configManager.getPRsDirectory(), pr.file_path);
      targetPath = path26.join(archivePath, relativePath);
      const targetDir = path26.dirname(targetPath);
      if (!fs27.existsSync(targetDir)) {
        fs27.mkdirSync(targetDir, { recursive: true });
      }
    } else {
      targetPath = path26.join(archivePath, fileName);
    }
    detail.archivePath = targetPath;
    if (!options.dryRun) {
      fs27.copyFileSync(pr.file_path, targetPath);
      fs27.unlinkSync(pr.file_path);
    }
    detail.archived = true;
    return detail;
  } catch (error) {
    detail.reason = error instanceof Error ? error.message : String(error);
    return detail;
  }
}
async function archiveReviewFiles(archivePath, options, configManager) {
  try {
    const reviewsDir = path26.join(configManager.getPRsDirectory(), "reviews");
    if (!fs27.existsSync(reviewsDir)) {
      return 0;
    }
    const reviewFiles = fs27.readdirSync(reviewsDir);
    const archiveReviewsDir = path26.join(archivePath, "reviews");
    if (!options.dryRun && reviewFiles.length > 0) {
      if (!fs27.existsSync(archiveReviewsDir)) {
        fs27.mkdirSync(archiveReviewsDir, { recursive: true });
      }
    }
    let archivedCount = 0;
    for (const file of reviewFiles) {
      const sourcePath = path26.join(reviewsDir, file);
      const targetPath = path26.join(archiveReviewsDir, file);
      try {
        if (!options.dryRun) {
          fs27.copyFileSync(sourcePath, targetPath);
          fs27.unlinkSync(sourcePath);
        }
        archivedCount++;
      } catch (error) {
        console.warn(`Failed to archive review file ${file}: ${error}`);
      }
    }
    return archivedCount;
  } catch (error) {
    console.error(`Error archiving review files: ${error}`);
    return 0;
  }
}
async function createArchiveIndex(prs, archivePath, result, configManager) {
  var _a, _b;
  const index = {
    created: (/* @__PURE__ */ new Date()).toISOString(),
    totalPRs: result.archivedPRs,
    totalReviews: result.archivedReviews,
    totalSize: result.totalSizeAfter,
    compressionRatio: result.compressionRatio,
    prs: []
  };
  for (const pr of prs) {
    const entry = {
      prId: pr.pr_id,
      title: pr.title,
      status: pr.pr_status,
      assignee: pr.assignee,
      created: pr.created_date,
      archivePath: path26.relative(archivePath, ((_a = result.details.find((d) => d.prId === pr.pr_id)) == null ? void 0 : _a.archivePath) || ""),
      sizeBytes: ((_b = result.details.find((d) => d.prId === pr.pr_id)) == null ? void 0 : _b.sizeBytes) || 0,
      linkedTasks: [],
      // This would be populated from relationship manager
      linkedIssues: []
    };
    if (pr.pr_status === "merged") {
      entry.merged = pr.updated_date;
    } else if (pr.pr_status === "closed") {
      entry.closed = pr.updated_date;
    }
    index.prs.push(entry);
  }
  const indexPath = path26.join(archivePath, "index.json");
  fs27.writeFileSync(indexPath, JSON.stringify(index, null, 2), "utf8");
  return indexPath;
}
async function compressArchive(archivePath, configManager) {
  console.log(`Compressing archive at ${archivePath}...`);
}
async function listArchivedPRs(configManager, searchQuery) {
  const archiveDir = path26.join(configManager.getPRsDirectory(), "archive");
  if (!fs27.existsSync(archiveDir)) {
    return [];
  }
  const archiveDirs = fs27.readdirSync(archiveDir).filter((dir) => {
    const dirPath = path26.join(archiveDir, dir);
    return fs27.statSync(dirPath).isDirectory();
  });
  const allPRs = [];
  for (const dir of archiveDirs) {
    const indexPath = path26.join(archiveDir, dir, "index.json");
    if (fs27.existsSync(indexPath)) {
      try {
        const indexContent = fs27.readFileSync(indexPath, "utf8");
        const index = JSON.parse(indexContent);
        allPRs.push(...index.prs);
      } catch (error) {
        console.warn(`Failed to read index for archive ${dir}: ${error}`);
      }
    }
  }
  if (searchQuery) {
    const query = searchQuery.toLowerCase();
    return allPRs.filter(
      (pr) => pr.prId.toLowerCase().includes(query) || pr.title.toLowerCase().includes(query) || pr.assignee.toLowerCase().includes(query)
    );
  }
  return allPRs;
}
async function restorePR(prId, targetStatus, statusManager, fileManager, configManager) {
  const result = {
    success: false,
    restoredPath: void 0,
    errors: []
  };
  try {
    const archivedPRs = await listArchivedPRs(configManager);
    const archivedPR = archivedPRs.find((pr) => pr.prId === prId);
    if (!archivedPR) {
      result.errors.push(`Archived PR ${prId} not found`);
      return result;
    }
    const basePRsDir = configManager.getPRsDirectory();
    const targetDir = fileManager.getPRDirectory(targetStatus, basePRsDir);
    const fileName = path26.basename(archivedPR.archivePath);
    const restorePath = path26.join(targetDir, fileName);
    const archiveDir = path26.join(basePRsDir, "archive");
    const archiveDirs = fs27.readdirSync(archiveDir).filter((dir) => {
      const dirPath = path26.join(archiveDir, dir);
      return fs27.statSync(dirPath).isDirectory();
    });
    let sourcePath;
    for (const dir of archiveDirs) {
      const candidatePath = path26.join(archiveDir, dir, archivedPR.archivePath);
      if (fs27.existsSync(candidatePath)) {
        sourcePath = candidatePath;
        break;
      }
    }
    if (!sourcePath) {
      result.errors.push(`Archive file for PR ${prId} not found`);
      return result;
    }
    if (!fs27.existsSync(targetDir)) {
      fs27.mkdirSync(targetDir, { recursive: true });
    }
    fs27.copyFileSync(sourcePath, restorePath);
    result.success = true;
    result.restoredPath = restorePath;
    return result;
  } catch (error) {
    result.errors.push(`Restore failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
async function cleanupArchive(olderThanDays, force, configManager) {
  const result = {
    success: false,
    removedCount: 0,
    freedSpace: 0,
    errors: []
  };
  try {
    const archiveDir = path26.join(configManager.getPRsDirectory(), "archive");
    if (!fs27.existsSync(archiveDir)) {
      result.success = true;
      return result;
    }
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - olderThanDays);
    const archiveDirs = fs27.readdirSync(archiveDir).filter((dir) => {
      const dirPath = path26.join(archiveDir, dir);
      return fs27.statSync(dirPath).isDirectory();
    });
    for (const dir of archiveDirs) {
      const dirPath = path26.join(archiveDir, dir);
      const stats = fs27.statSync(dirPath);
      if (stats.mtime < cutoffDate) {
        try {
          const size = calculateDirectorySize(dirPath);
          if (force || await confirmCleanup(dir)) {
            fs27.rmSync(dirPath, { recursive: true, force: true });
            result.removedCount++;
            result.freedSpace += size;
          }
        } catch (error) {
          result.errors.push(`Failed to remove ${dir}: ${error}`);
        }
      }
    }
    result.success = result.errors.length === 0;
    return result;
  } catch (error) {
    result.errors.push(`Cleanup failed: ${error instanceof Error ? error.message : String(error)}`);
    return result;
  }
}
function calculateDirectorySize(dirPath) {
  let totalSize = 0;
  const items = fs27.readdirSync(dirPath);
  for (const item of items) {
    const itemPath = path26.join(dirPath, item);
    const stats = fs27.statSync(itemPath);
    if (stats.isDirectory()) {
      totalSize += calculateDirectorySize(itemPath);
    } else {
      totalSize += stats.size;
    }
  }
  return totalSize;
}
async function confirmCleanup(archiveName) {
  return false;
}
function formatBytes(bytes) {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}
function displayArchiveResult(result) {
  console.log(colors.cyan(`
\u{1F4E6} Archive operation completed`));
  console.log(`\u{1F4C1} Archive path: ${result.archivePath}`);
  console.log(`\u{1F4CB} Archived PRs: ${result.archivedPRs}`);
  console.log(`\u{1F4DD} Archived reviews: ${result.archivedReviews}`);
  console.log(`\u{1F4BE} Size before: ${formatBytes(result.totalSizeBefore)}`);
  console.log(`\u{1F4BE} Size after: ${formatBytes(result.totalSizeAfter)}`);
  if (result.compressionRatio > 0) {
    console.log(`\u{1F4C9} Compression: ${(result.compressionRatio * 100).toFixed(1)}%`);
  }
  if (result.indexPath) {
    console.log(`\u{1F4C4} Index created: ${result.indexPath}`);
  }
  if (result.details.length > 0) {
    console.log("\n\u{1F4CB} Archive Details:");
    result.details.forEach((detail) => {
      const icon = detail.archived ? "\u2705" : "\u274C";
      const color = detail.archived ? colors.green : colors.red;
      const size = formatBytes(detail.sizeBytes);
      console.log(color(`${icon} ${detail.prId} (${size})`));
    });
  }
  if (result.warnings.length > 0) {
    console.log(colors.yellow("\n\u26A0\uFE0F  Warnings:"));
    result.warnings.forEach((warning) => {
      console.log(colors.yellow(`  - ${warning}`));
    });
  }
  if (result.errors.length > 0) {
    console.log(colors.red("\n\u274C Errors:"));
    result.errors.forEach((error) => {
      console.log(colors.red(`  - ${error}`));
    });
  }
  const successColor = result.success ? colors.green : colors.red;
  const successIcon = result.success ? "\u2705" : "\u274C";
  console.log(successColor(`
${successIcon} Archive ${result.success ? "completed successfully" : "failed"}`));
}
function displayArchivedPRs(prs, format, formatter) {
  if (format === "json") {
    console.log(JSON.stringify(prs, null, 2));
  } else {
    console.log(colors.blue(`
\u{1F4E6} Archived PRs (${prs.length} found)`));
    if (prs.length === 0) {
      console.log(colors.yellow("No archived PRs found"));
      return;
    }
    console.table(prs.map((pr) => ({
      "PR ID": pr.prId,
      "Title": pr.title.substring(0, 40) + (pr.title.length > 40 ? "..." : ""),
      "Status": pr.status,
      "Assignee": pr.assignee,
      "Created": pr.created.split("T")[0],
      "Size": formatBytes(pr.sizeBytes)
    })));
  }
}
var import_commander49, fs27, path26;
var init_archive = __esm({
  "src/commands/pr/archive.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander49 = require("commander");
    init_pr_status_manager();
    init_pr_file_manager();
    init_config_manager();
    init_formatter();
    init_colors();
    fs27 = __toESM(require("fs"), 1);
    path26 = __toESM(require("path"), 1);
    __name(createPRArchiveCommand, "createPRArchiveCommand");
    __name(performArchive, "performArchive");
    __name(findArchiveCandidates, "findArchiveCandidates");
    __name(archivePR, "archivePR");
    __name(archiveReviewFiles, "archiveReviewFiles");
    __name(createArchiveIndex, "createArchiveIndex");
    __name(compressArchive, "compressArchive");
    __name(listArchivedPRs, "listArchivedPRs");
    __name(restorePR, "restorePR");
    __name(cleanupArchive, "cleanupArchive");
    __name(calculateDirectorySize, "calculateDirectorySize");
    __name(confirmCleanup, "confirmCleanup");
    __name(formatBytes, "formatBytes");
    __name(displayArchiveResult, "displayArchiveResult");
    __name(displayArchivedPRs, "displayArchivedPRs");
  }
});

// src/commands/pr.ts
function createPRCommand() {
  const cmd = new import_commander50.Command("pr");
  cmd.description("Manage PRs (pull request tracking within issues)").alias("prs").addCommand(createPRCreateCommand()).addCommand(createPRListCommand()).addCommand(createPRShowCommand()).addCommand(createPRReviewCommand()).addCommand(createPRApproveCommand()).addCommand(createPRUpdateCommand()).addCommand(createPRMergeCommand()).addCommand(createPRCloseCommand()).addCommand(createPRBatchCommand()).addCommand(createPRDependenciesCommand()).addCommand(createPRSyncCommand()).addCommand(createPRArchiveCommand());
  return cmd;
}
var import_commander50;
var init_pr = __esm({
  "src/commands/pr.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander50 = require("commander");
    init_create4();
    init_list4();
    init_show5();
    init_review();
    init_approve();
    init_update4();
    init_merge();
    init_close();
    init_batch();
    init_dependencies();
    init_sync2();
    init_archive();
    __name(createPRCommand, "createPRCommand");
  }
});

// src/commands/ai/generate-llms-txt.ts
function createAiGenerateLlmsCommand() {
  const cmd = new import_commander51.Command("generate-llms-txt");
  cmd.description("Generate llms.txt file from project structure").option("-o, --output <path>", "output file path", "llms.txt").option("--include-content", "include full content in output").option("--include-completed", "include completed items").option("-f, --format <type>", "output format (standard|detailed|summary)", "standard").option("--dry-run", "show what would be generated without creating file").action(async (options) => {
    try {
      await generateLlmsTxt(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to generate llms.txt: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function generateLlmsTxt(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const overview = relationshipManager.getProjectOverview();
  const searchResult = relationshipManager.search({});
  const allItems = searchResult.items;
  let filteredItems = allItems;
  if (!options.includeCompleted) {
    filteredItems = allItems.filter((item) => item.status !== "completed");
  }
  const epics = filteredItems.filter((item) => "epic_id" in item && !("issue_id" in item));
  const issues = filteredItems.filter((item) => "issue_id" in item && !("task_id" in item));
  const tasks = filteredItems.filter((item) => "task_id" in item);
  let content = "";
  switch (options.format) {
    case "summary":
      content = generateSummaryFormat(config, overview, epics, issues, tasks);
      break;
    case "detailed":
      content = generateDetailedFormat(config, overview, epics, issues, tasks, options.includeContent);
      break;
    default:
      content = generateStandardFormat(config, overview, epics, issues, tasks);
  }
  if (options.dryRun) {
    console.log(Formatter.info("Dry run - Generated llms.txt content:"));
    console.log("");
    console.log(content);
    console.log("");
    console.log(Formatter.info(`Content length: ${content.length} characters`));
    return;
  }
  const outputPath = path27.resolve(options.output || "llms.txt");
  fs28.writeFileSync(outputPath, content, "utf8");
  console.log(Formatter.success(`llms.txt generated successfully!`));
  console.log(Formatter.info(`Output: ${outputPath}`));
  console.log(Formatter.info(`Format: ${options.format || "standard"}`));
  console.log(Formatter.info(`Content length: ${content.length} characters`));
  console.log(Formatter.info(`Items included: ${filteredItems.length} total`));
  console.log(`  \u2022 Epics: ${epics.length}`);
  console.log(`  \u2022 Issues: ${issues.length}`);
  console.log(`  \u2022 Tasks: ${tasks.length}`);
}
function generateSummaryFormat(config, overview, epics, issues, tasks) {
  return `# ${config.name} - Project Summary

## Overview
- **Total Items**: ${overview.totals.epics + overview.totals.issues + overview.totals.tasks}
- **Completion Rate**: ${overview.completion_metrics.overall_completion}%
- **Generated**: ${(/* @__PURE__ */ new Date()).toISOString()}

## Status Breakdown
${Object.entries(overview.status_breakdown).map(
    ([status, count]) => `- **${status.charAt(0).toUpperCase() + status.slice(1)}**: ${count}`
  ).join("\n")}

## Priority Breakdown
${Object.entries(overview.priority_breakdown).map(
    ([priority, count]) => `- **${priority.charAt(0).toUpperCase() + priority.slice(1)}**: ${count}`
  ).join("\n")}

## Active Items

### Epics (${epics.length})
${epics.map((epic) => `- ${epic.epic_id}: ${epic.title} [${epic.status}]`).join("\n")}

### Issues (${issues.length})
${issues.map((issue) => `- ${issue.issue_id}: ${issue.title} [${issue.status}]`).join("\n")}

### Tasks (${tasks.length})
${tasks.map((task) => `- ${task.task_id}: ${task.title} [${task.status}]`).join("\n")}
`;
}
function generateStandardFormat(config, overview, epics, issues, tasks) {
  let content = `# ${config.name} - AI Project Context

> Generated on ${(/* @__PURE__ */ new Date()).toISOString()}
> AI-Trackdown project management system

## Project Statistics
- **Epics**: ${epics.length} active
- **Issues**: ${issues.length} active  
- **Tasks**: ${tasks.length} active
- **Overall Completion**: ${overview.completion_metrics.overall_completion}%

## Project Structure

`;
  const issuesByEpic = issues.reduce((acc, issue) => {
    if (!acc[issue.epic_id]) acc[issue.epic_id] = [];
    acc[issue.epic_id].push(issue);
    return acc;
  }, {});
  const tasksByIssue = tasks.reduce((acc, task) => {
    if (!acc[task.issue_id]) acc[task.issue_id] = [];
    acc[task.issue_id].push(task);
    return acc;
  }, {});
  for (const epic of epics) {
    content += `### ${epic.epic_id}: ${epic.title}
`;
    content += `**Status**: ${epic.status} | **Priority**: ${epic.priority} | **Assignee**: ${epic.assignee}
`;
    if (epic.description) {
      content += `**Description**: ${epic.description}
`;
    }
    content += "\n";
    const epicIssues = issuesByEpic[epic.epic_id] || [];
    for (const issue of epicIssues) {
      content += `#### ${issue.issue_id}: ${issue.title}
`;
      content += `**Status**: ${issue.status} | **Priority**: ${issue.priority} | **Assignee**: ${issue.assignee}
`;
      if (issue.description) {
        content += `**Description**: ${issue.description}
`;
      }
      content += "\n";
      const issueTasks = tasksByIssue[issue.issue_id] || [];
      if (issueTasks.length > 0) {
        content += `**Tasks**:
`;
        for (const task of issueTasks) {
          content += `- ${task.task_id}: ${task.title} [${task.status}]
`;
        }
        content += "\n";
      }
    }
  }
  return content;
}
function generateDetailedFormat(config, overview, epics, issues, tasks, includeContent = false) {
  let content = generateStandardFormat(config, overview, epics, issues, tasks);
  if (includeContent) {
    content += "\n## Detailed Content\n\n";
    for (const epic of epics) {
      content += `### ${epic.epic_id} Content
`;
      content += "```markdown\n";
      content += epic.content || "(No content)";
      content += "\n```\n\n";
    }
    for (const issue of issues) {
      content += `### ${issue.issue_id} Content
`;
      content += "```markdown\n";
      content += issue.content || "(No content)";
      content += "\n```\n\n";
    }
    for (const task of tasks) {
      content += `### ${task.task_id} Content
`;
      content += "```markdown\n";
      content += task.content || "(No content)";
      content += "\n```\n\n";
    }
  }
  content += "\n## AI Context Templates\n\n";
  if (config.ai_context_templates && config.ai_context_templates.length > 0) {
    for (const template of config.ai_context_templates) {
      content += `- ${template}
`;
    }
  } else {
    content += "No AI context templates configured.\n";
  }
  content += "\n## Token Usage Summary\n\n";
  const totalEstimated = [...epics, ...issues, ...tasks].reduce((sum, item) => sum + (item.estimated_tokens || 0), 0);
  const totalActual = [...epics, ...issues, ...tasks].reduce((sum, item) => sum + (item.actual_tokens || 0), 0);
  content += `- **Total Estimated Tokens**: ${totalEstimated}
`;
  content += `- **Total Actual Tokens**: ${totalActual}
`;
  if (totalEstimated > 0) {
    content += `- **Token Efficiency**: ${(totalActual / totalEstimated * 100).toFixed(1)}%
`;
  }
  return content;
}
var import_commander51, fs28, path27;
var init_generate_llms_txt = __esm({
  "src/commands/ai/generate-llms-txt.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander51 = require("commander");
    fs28 = __toESM(require("fs"), 1);
    path27 = __toESM(require("path"), 1);
    init_config_manager();
    init_relationship_manager();
    init_formatter();
    __name(createAiGenerateLlmsCommand, "createAiGenerateLlmsCommand");
    __name(generateLlmsTxt, "generateLlmsTxt");
    __name(generateSummaryFormat, "generateSummaryFormat");
    __name(generateStandardFormat, "generateStandardFormat");
    __name(generateDetailedFormat, "generateDetailedFormat");
  }
});

// src/commands/ai/track-tokens.ts
function createAiTrackTokensCommand() {
  const cmd = new import_commander52.Command("track-tokens");
  cmd.description("Track and update token usage across items").option("-i, --item-id <id>", "specific item ID to update").option("-t, --type <type>", "item type filter (epic|issue|task)").option("-e, --estimated <number>", "set estimated tokens").option("-a, --actual <number>", "set actual tokens").option("-o, --operation <op>", "operation (add|set)", "set").option("-r, --report", "show token usage report").option("-f, --format <type>", "output format (table|json|summary)", "table").action(async (options) => {
    try {
      await trackTokens(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to track tokens: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function trackTokens(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  if (options.report || !options.itemId && !options.estimated && !options.actual) {
    await showTokenReport(relationshipManager, options.format || "table", options.type);
    return;
  }
  if (options.itemId) {
    await updateItemTokens(relationshipManager, parser, options);
    return;
  }
  throw new Error("Must specify either --item-id for updates or --report for viewing usage");
}
async function updateItemTokens(relationshipManager, parser, options) {
  const searchResult = relationshipManager.search({ content_search: options.itemId });
  const item = searchResult.items.find((item2) => {
    if (options.itemId.startsWith("EP-") && "epic_id" in item2) return item2.epic_id === options.itemId;
    if (options.itemId.startsWith("ISS-") && "issue_id" in item2) return item2.issue_id === options.itemId;
    if (options.itemId.startsWith("TSK-") && "task_id" in item2) return item2.task_id === options.itemId;
    return false;
  });
  if (!item) {
    throw new Error(`Item not found: ${options.itemId}`);
  }
  const updates = {
    updated_date: (/* @__PURE__ */ new Date()).toISOString()
  };
  if (options.estimated !== void 0) {
    if (options.operation === "add") {
      updates.estimated_tokens = (item.estimated_tokens || 0) + options.estimated;
    } else {
      updates.estimated_tokens = options.estimated;
    }
  }
  if (options.actual !== void 0) {
    if (options.operation === "add") {
      updates.actual_tokens = (item.actual_tokens || 0) + options.actual;
    } else {
      updates.actual_tokens = options.actual;
    }
  }
  const updatedItem = parser.updateFile(item.file_path, updates);
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`Token usage updated successfully!`));
  console.log(Formatter.info(`Item: ${options.itemId} - ${item.title}`));
  console.log(Formatter.info(`Estimated Tokens: ${item.estimated_tokens || 0} \u2192 ${updatedItem.estimated_tokens || 0}`));
  console.log(Formatter.info(`Actual Tokens: ${item.actual_tokens || 0} \u2192 ${updatedItem.actual_tokens || 0}`));
  if (updatedItem.estimated_tokens > 0) {
    const efficiency = (updatedItem.actual_tokens || 0) / updatedItem.estimated_tokens;
    const efficiencyDisplay = efficiency <= 1 ? Formatter.success(`${(efficiency * 100).toFixed(1)}%`) : Formatter.warning(`${(efficiency * 100).toFixed(1)}%`);
    console.log(Formatter.info(`Token Efficiency: ${efficiencyDisplay}`));
  }
}
async function showTokenReport(relationshipManager, format, typeFilter) {
  const searchResult = relationshipManager.search({});
  let items = searchResult.items;
  if (typeFilter) {
    items = items.filter((item) => {
      switch (typeFilter) {
        case "epic":
          return "epic_id" in item && !("issue_id" in item);
        case "issue":
          return "issue_id" in item && !("task_id" in item);
        case "task":
          return "task_id" in item;
        default:
          return true;
      }
    });
  }
  const totalEstimated = items.reduce((sum, item) => sum + (item.estimated_tokens || 0), 0);
  const totalActual = items.reduce((sum, item) => sum + (item.actual_tokens || 0), 0);
  const overallEfficiency = totalEstimated > 0 ? totalActual / totalEstimated * 100 : 0;
  switch (format) {
    case "json":
      const jsonReport = {
        summary: {
          total_items: items.length,
          total_estimated: totalEstimated,
          total_actual: totalActual,
          efficiency_percentage: overallEfficiency
        },
        items: items.map((item) => ({
          id: getItemId3(item),
          title: item.title,
          type: getItemType3(item),
          status: item.status,
          estimated_tokens: item.estimated_tokens || 0,
          actual_tokens: item.actual_tokens || 0,
          efficiency: item.estimated_tokens > 0 ? (item.actual_tokens || 0) / item.estimated_tokens * 100 : 0
        }))
      };
      console.log(JSON.stringify(jsonReport, null, 2));
      break;
    case "summary":
      console.log(Formatter.success("Token Usage Summary"));
      console.log("");
      console.log(`Total Items: ${items.length}`);
      console.log(`Total Estimated Tokens: ${totalEstimated}`);
      console.log(`Total Actual Tokens: ${totalActual}`);
      console.log(`Overall Efficiency: ${overallEfficiency.toFixed(1)}%`);
      console.log("");
      const byType = items.reduce((acc, item) => {
        const type = getItemType3(item);
        if (!acc[type]) acc[type] = [];
        acc[type].push(item);
        return acc;
      }, {});
      for (const [type, typeItems] of Object.entries(byType)) {
        const typeEstimated = typeItems.reduce((sum, item) => sum + (item.estimated_tokens || 0), 0);
        const typeActual = typeItems.reduce((sum, item) => sum + (item.actual_tokens || 0), 0);
        const typeEfficiency = typeEstimated > 0 ? typeActual / typeEstimated * 100 : 0;
        console.log(`${type.charAt(0).toUpperCase() + type.slice(1)}s:`);
        console.log(`  Count: ${typeItems.length}`);
        console.log(`  Estimated: ${typeEstimated}`);
        console.log(`  Actual: ${typeActual}`);
        console.log(`  Efficiency: ${typeEfficiency.toFixed(1)}%`);
        console.log("");
      }
      break;
    default:
      console.log(Formatter.success("Token Usage Report"));
      console.log("");
      if (items.length === 0) {
        console.log(Formatter.info("No items found."));
        return;
      }
      const headers = ["ID", "Title", "Type", "Status", "Estimated", "Actual", "Efficiency"];
      const colWidths = [12, 40, 8, 10, 10, 10, 10];
      printTableRow3(headers, colWidths, true);
      printSeparator3(colWidths);
      for (const item of items) {
        const efficiency = item.estimated_tokens > 0 ? ((item.actual_tokens || 0) / item.estimated_tokens * 100).toFixed(1) + "%" : "N/A";
        const row = [
          getItemId3(item),
          truncateText3(item.title, 38),
          getItemType3(item).toUpperCase(),
          item.status.toUpperCase(),
          (item.estimated_tokens || 0).toString(),
          (item.actual_tokens || 0).toString(),
          efficiency
        ];
        printTableRow3(row, colWidths, false);
      }
      console.log("");
      console.log(Formatter.success("Summary:"));
      console.log(`Total Items: ${items.length}`);
      console.log(`Total Estimated: ${totalEstimated}`);
      console.log(`Total Actual: ${totalActual}`);
      console.log(`Overall Efficiency: ${overallEfficiency.toFixed(1)}%`);
  }
}
function getItemId3(item) {
  if (item.epic_id && !item.issue_id && !item.task_id) return item.epic_id;
  if (item.issue_id && !item.task_id) return item.issue_id;
  if (item.task_id) return item.task_id;
  return "UNKNOWN";
}
function getItemType3(item) {
  if (item.epic_id && !item.issue_id && !item.task_id) return "epic";
  if (item.issue_id && !item.task_id) return "issue";
  if (item.task_id) return "task";
  return "unknown";
}
function printTableRow3(row, widths, isHeader) {
  const paddedRow = row.map((cell, i) => cell.padEnd(widths[i]));
  const rowText = paddedRow.join(" | ");
  if (isHeader) {
    console.log(Formatter.info(rowText));
  } else {
    console.log(rowText);
  }
}
function printSeparator3(widths) {
  const separator = widths.map((width) => "-".repeat(width)).join("-+-");
  console.log(separator);
}
function truncateText3(text, maxLength) {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength - 3) + "...";
}
var import_commander52;
var init_track_tokens = __esm({
  "src/commands/ai/track-tokens.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander52 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createAiTrackTokensCommand, "createAiTrackTokensCommand");
    __name(trackTokens, "trackTokens");
    __name(updateItemTokens, "updateItemTokens");
    __name(showTokenReport, "showTokenReport");
    __name(getItemId3, "getItemId");
    __name(getItemType3, "getItemType");
    __name(printTableRow3, "printTableRow");
    __name(printSeparator3, "printSeparator");
    __name(truncateText3, "truncateText");
  }
});

// src/commands/ai/context.ts
function createAiContextCommand() {
  const cmd = new import_commander53.Command("context");
  cmd.description("Manage AI context for items").option("-i, --item-id <id>", "specific item ID to manage").option("--add <context>", "add context entry (comma-separated for multiple)").option("--remove <context>", "remove context entry (comma-separated for multiple)").option("-l, --list", "list context for item or all items").option("--clear", "clear all context for item").option("-t, --template", "show available context templates").option("-f, --format <type>", "output format (table|json|list)", "table").action(async (options) => {
    try {
      await manageContext(options);
    } catch (error) {
      console.error(Formatter.error(`Failed to manage context: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function manageContext(options) {
  const configManager = new ConfigManager2();
  const config = configManager.getConfig();
  const cliTasksDir = process.env.CLI_TASKS_DIR;
  const paths = configManager.getAbsolutePaths(cliTasksDir);
  const relationshipManager = new RelationshipManager(config, paths.projectRoot, cliTasksDir);
  const parser = new FrontmatterParser();
  if (options.template) {
    await showContextTemplates(config);
    return;
  }
  if (options.list || !options.itemId && !options.add && !options.remove && !options.clear) {
    await listContext(relationshipManager, options.itemId, options.format || "table");
    return;
  }
  if (!options.itemId) {
    throw new Error("Item ID is required for context management operations");
  }
  await updateItemContext(relationshipManager, parser, options);
}
async function showContextTemplates(config) {
  console.log(Formatter.success("AI Context Templates"));
  console.log("");
  if (config.ai_context_templates && config.ai_context_templates.length > 0) {
    console.log(Formatter.info("Available templates:"));
    for (const template of config.ai_context_templates) {
      console.log(`  \u2022 ${template}`);
    }
  } else {
    console.log(Formatter.warning("No AI context templates configured."));
    console.log("");
    console.log(Formatter.info("Common AI context patterns:"));
    console.log("  \u2022 context/requirements");
    console.log("  \u2022 context/constraints");
    console.log("  \u2022 context/assumptions");
    console.log("  \u2022 context/dependencies");
    console.log("  \u2022 context/user-story");
    console.log("  \u2022 context/technical-specs");
    console.log("  \u2022 context/acceptance-criteria");
  }
}
async function listContext(relationshipManager, itemId, format = "table") {
  if (itemId) {
    const searchResult = relationshipManager.search({ content_search: itemId });
    const item = searchResult.items.find((item2) => {
      if (itemId.startsWith("EP-") && "epic_id" in item2) return item2.epic_id === itemId;
      if (itemId.startsWith("ISS-") && "issue_id" in item2) return item2.issue_id === itemId;
      if (itemId.startsWith("TSK-") && "task_id" in item2) return item2.task_id === itemId;
      return false;
    });
    if (!item) {
      throw new Error(`Item not found: ${itemId}`);
    }
    console.log(Formatter.success(`AI Context for ${itemId}: ${item.title}`));
    console.log("");
    if (item.ai_context && item.ai_context.length > 0) {
      switch (format) {
        case "json":
          console.log(JSON.stringify(item.ai_context, null, 2));
          break;
        case "list":
          for (const context of item.ai_context) {
            console.log(context);
          }
          break;
        default:
          for (let i = 0; i < item.ai_context.length; i++) {
            console.log(`${i + 1}. ${item.ai_context[i]}`);
          }
      }
    } else {
      console.log(Formatter.info("No AI context configured for this item."));
    }
  } else {
    const searchResult = relationshipManager.search({});
    const itemsWithContext = searchResult.items.filter(
      (item) => item.ai_context && item.ai_context.length > 0
    );
    console.log(Formatter.success(`AI Context Overview`));
    console.log("");
    if (itemsWithContext.length === 0) {
      console.log(Formatter.info("No items have AI context configured."));
      return;
    }
    switch (format) {
      case "json":
        const jsonData = itemsWithContext.map((item) => ({
          id: getItemId4(item),
          title: item.title,
          type: getItemType4(item),
          ai_context: item.ai_context
        }));
        console.log(JSON.stringify(jsonData, null, 2));
        break;
      default:
        for (const item of itemsWithContext) {
          console.log(Formatter.info(`${getItemId4(item)}: ${item.title}`));
          for (const context of item.ai_context) {
            console.log(`  \u2022 ${context}`);
          }
          console.log("");
        }
    }
    console.log(Formatter.success(`Total items with context: ${itemsWithContext.length}`));
  }
}
async function updateItemContext(relationshipManager, parser, options) {
  const searchResult = relationshipManager.search({ content_search: options.itemId });
  const item = searchResult.items.find((item2) => {
    if (options.itemId.startsWith("EP-") && "epic_id" in item2) return item2.epic_id === options.itemId;
    if (options.itemId.startsWith("ISS-") && "issue_id" in item2) return item2.issue_id === options.itemId;
    if (options.itemId.startsWith("TSK-") && "task_id" in item2) return item2.task_id === options.itemId;
    return false;
  });
  if (!item) {
    throw new Error(`Item not found: ${options.itemId}`);
  }
  let currentContext = [...item.ai_context || []];
  let hasChanges = false;
  if (options.clear) {
    currentContext = [];
    hasChanges = true;
  }
  if (options.add) {
    const toAdd = options.add.split(",").map((ctx) => ctx.trim());
    for (const ctx of toAdd) {
      if (!currentContext.includes(ctx)) {
        currentContext.push(ctx);
        hasChanges = true;
      }
    }
  }
  if (options.remove) {
    const toRemove = options.remove.split(",").map((ctx) => ctx.trim());
    const originalLength = currentContext.length;
    currentContext = currentContext.filter((ctx) => !toRemove.includes(ctx));
    hasChanges = originalLength !== currentContext.length;
  }
  if (!hasChanges) {
    console.log(Formatter.warning("No changes to make."));
    return;
  }
  const updates = {
    ai_context: currentContext.length > 0 ? currentContext : [],
    updated_date: (/* @__PURE__ */ new Date()).toISOString()
  };
  const updatedItem = parser.updateFile(item.file_path, updates);
  relationshipManager.rebuildCache();
  console.log(Formatter.success(`AI context updated successfully!`));
  console.log(Formatter.info(`Item: ${options.itemId} - ${item.title}`));
  console.log("");
  console.log(Formatter.success("Current AI context:"));
  if (updatedItem.ai_context && updatedItem.ai_context.length > 0) {
    for (let i = 0; i < updatedItem.ai_context.length; i++) {
      console.log(`${i + 1}. ${updatedItem.ai_context[i]}`);
    }
  } else {
    console.log(Formatter.info("(No AI context configured)"));
  }
}
function getItemId4(item) {
  if (item.epic_id && !item.issue_id && !item.task_id) return item.epic_id;
  if (item.issue_id && !item.task_id) return item.issue_id;
  if (item.task_id) return item.task_id;
  return "UNKNOWN";
}
function getItemType4(item) {
  if (item.epic_id && !item.issue_id && !item.task_id) return "epic";
  if (item.issue_id && !item.task_id) return "issue";
  if (item.task_id) return "task";
  return "unknown";
}
var import_commander53;
var init_context = __esm({
  "src/commands/ai/context.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander53 = require("commander");
    init_config_manager();
    init_relationship_manager();
    init_frontmatter_parser();
    init_formatter();
    __name(createAiContextCommand, "createAiContextCommand");
    __name(manageContext, "manageContext");
    __name(showContextTemplates, "showContextTemplates");
    __name(listContext, "listContext");
    __name(updateItemContext, "updateItemContext");
    __name(getItemId4, "getItemId");
    __name(getItemType4, "getItemType");
  }
});

// src/commands/ai.ts
function createAiCommand() {
  const cmd = new import_commander54.Command("ai");
  cmd.description("AI-specific functionality for token tracking and context management").addCommand(createAiGenerateLlmsCommand()).addCommand(createAiTrackTokensCommand()).addCommand(createAiContextCommand());
  return cmd;
}
var import_commander54;
var init_ai = __esm({
  "src/commands/ai.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander54 = require("commander");
    init_generate_llms_txt();
    init_track_tokens();
    init_context();
    __name(createAiCommand, "createAiCommand");
  }
});

// node_modules/@octokit/request-error/dist-src/index.js
var _RequestError, RequestError;
var init_dist_src = __esm({
  "node_modules/@octokit/request-error/dist-src/index.js"() {
    "use strict";
    init_cjs_shims();
    _RequestError = class _RequestError extends Error {
      name;
      /**
       * http status code
       */
      status;
      /**
       * Request options that lead to the error.
       */
      request;
      /**
       * Response object if a response was received
       */
      response;
      constructor(message, statusCode, options) {
        super(message);
        this.name = "HttpError";
        this.status = Number.parseInt(statusCode);
        if (Number.isNaN(this.status)) {
          this.status = 0;
        }
        if ("response" in options) {
          this.response = options.response;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(
              /(?<! ) .*$/,
              " [REDACTED]"
            )
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
      }
    };
    __name(_RequestError, "RequestError");
    RequestError = _RequestError;
  }
});

// src/utils/github-client.ts
var github_client_exports = {};
__export(github_client_exports, {
  GitHubClient: () => GitHubClient
});
var import_rest, _GitHubClient, GitHubClient;
var init_github_client = __esm({
  "src/utils/github-client.ts"() {
    "use strict";
    init_cjs_shims();
    import_rest = require("@octokit/rest");
    init_dist_src();
    _GitHubClient = class _GitHubClient {
      octokit;
      owner;
      repo;
      config;
      constructor(config) {
        this.config = config;
        const [owner, repo] = config.repository.split("/");
        if (!owner || !repo) {
          throw new Error(`Invalid repository format: ${config.repository}. Expected format: owner/repo`);
        }
        this.owner = owner;
        this.repo = repo;
        this.octokit = new import_rest.Octokit({
          auth: config.token,
          request: {
            timeout: 3e4
            // 30 second timeout
          }
        });
      }
      /**
       * Test GitHub connection and permissions
       */
      async testConnection() {
        var _a, _b;
        try {
          const { data: repoData } = await this.octokit.rest.repos.get({
            owner: this.owner,
            repo: this.repo
          });
          if (!((_a = repoData.permissions) == null ? void 0 : _a.push) && !((_b = repoData.permissions) == null ? void 0 : _b.admin)) {
            return {
              success: false,
              message: "Token does not have write permissions to the repository"
            };
          }
          return {
            success: true,
            message: `Connected to ${this.owner}/${this.repo} successfully`
          };
        } catch (error) {
          if (error instanceof RequestError) {
            switch (error.status) {
              case 401:
                return {
                  success: false,
                  message: "Authentication failed. Please check your GitHub token."
                };
              case 403:
                return {
                  success: false,
                  message: "Access forbidden. Token may not have required permissions."
                };
              case 404:
                return {
                  success: false,
                  message: `Repository ${this.owner}/${this.repo} not found or not accessible.`
                };
              default:
                return {
                  success: false,
                  message: `GitHub API error: ${error.message}`
                };
            }
          }
          return {
            success: false,
            message: `Connection failed: ${error instanceof Error ? error.message : "Unknown error"}`
          };
        }
      }
      /**
       * Get all issues from GitHub repository with pagination
       */
      async getAllIssues(options = {}) {
        const issues = [];
        let page = 1;
        const per_page = Math.min(this.config.batch_size || 100, 100);
        try {
          while (true) {
            if (page > 1) {
              await this.delay(this.config.rate_limit_delay || 100);
            }
            const response = await this.octokit.rest.issues.listForRepo({
              owner: this.owner,
              repo: this.repo,
              state: options.state || "all",
              sort: options.sort || "updated",
              direction: options.direction || "desc",
              since: options.since,
              per_page,
              page
            });
            if (response.data.length === 0) {
              break;
            }
            const convertedIssues = response.data.map(this.convertGitHubIssue);
            issues.push(...convertedIssues);
            if (response.data.length < per_page) {
              break;
            }
            page++;
          }
          return issues;
        } catch (error) {
          throw new Error(`Failed to fetch issues: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Get a specific issue by number
       */
      async getIssue(issueNumber) {
        try {
          const response = await this.octokit.rest.issues.get({
            owner: this.owner,
            repo: this.repo,
            issue_number: issueNumber
          });
          return this.convertGitHubIssue(response.data);
        } catch (error) {
          if (error instanceof RequestError && error.status === 404) {
            return null;
          }
          throw new Error(`Failed to fetch issue #${issueNumber}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Create a new issue in GitHub
       */
      async createIssue(data) {
        try {
          await this.delay(this.config.rate_limit_delay || 100);
          const response = await this.octokit.rest.issues.create({
            owner: this.owner,
            repo: this.repo,
            title: data.title,
            body: data.body,
            assignee: data.assignee,
            milestone: data.milestone,
            labels: data.labels
          });
          return this.convertGitHubIssue(response.data);
        } catch (error) {
          throw new Error(`Failed to create issue: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Update an existing issue in GitHub
       */
      async updateIssue(issueNumber, data) {
        try {
          await this.delay(this.config.rate_limit_delay || 100);
          const response = await this.octokit.rest.issues.update({
            owner: this.owner,
            repo: this.repo,
            issue_number: issueNumber,
            title: data.title,
            body: data.body,
            state: data.state,
            assignee: data.assignee,
            milestone: data.milestone,
            labels: data.labels
          });
          return this.convertGitHubIssue(response.data);
        } catch (error) {
          throw new Error(`Failed to update issue #${issueNumber}: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Close an issue in GitHub
       */
      async closeIssue(issueNumber) {
        return this.updateIssue(issueNumber, { state: "closed" });
      }
      /**
       * Reopen an issue in GitHub
       */
      async reopenIssue(issueNumber) {
        return this.updateIssue(issueNumber, { state: "open" });
      }
      /**
       * Get repository labels
       */
      async getLabels() {
        try {
          const response = await this.octokit.rest.issues.listLabelsForRepo({
            owner: this.owner,
            repo: this.repo
          });
          return response.data.map((label) => ({
            name: label.name,
            color: label.color,
            description: label.description || void 0
          }));
        } catch (error) {
          throw new Error(`Failed to fetch labels: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Get repository milestones
       */
      async getMilestones() {
        try {
          const response = await this.octokit.rest.issues.listMilestones({
            owner: this.owner,
            repo: this.repo
          });
          return response.data.map((milestone) => ({
            title: milestone.title,
            number: milestone.number,
            state: milestone.state
          }));
        } catch (error) {
          throw new Error(`Failed to fetch milestones: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Get repository collaborators
       */
      async getCollaborators() {
        try {
          const response = await this.octokit.rest.repos.listCollaborators({
            owner: this.owner,
            repo: this.repo
          });
          return response.data.map((collaborator) => ({
            login: collaborator.login,
            id: collaborator.id
          }));
        } catch (error) {
          throw new Error(`Failed to fetch collaborators: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Get rate limit information
       */
      async getRateLimit() {
        try {
          const response = await this.octokit.rest.rateLimit.get();
          const core = response.data.rate;
          return {
            limit: core.limit,
            remaining: core.remaining,
            reset: new Date(core.reset * 1e3),
            used: core.used
          };
        } catch (error) {
          throw new Error(`Failed to fetch rate limit: ${error instanceof Error ? error.message : "Unknown error"}`);
        }
      }
      /**
       * Convert GitHub API issue to our GitHubIssue format
       */
      convertGitHubIssue(issue) {
        return {
          id: issue.id,
          number: issue.number,
          title: issue.title,
          body: issue.body || "",
          state: issue.state,
          created_at: issue.created_at,
          updated_at: issue.updated_at,
          assignee: issue.assignee ? {
            login: issue.assignee.login,
            id: issue.assignee.id
          } : void 0,
          labels: issue.labels.map((label) => ({
            name: label.name,
            color: label.color
          })),
          milestone: issue.milestone ? {
            title: issue.milestone.title,
            number: issue.milestone.number
          } : void 0,
          html_url: issue.html_url
        };
      }
      /**
       * Helper method to add delay for rate limiting
       */
      delay(ms) {
        return new Promise((resolve5) => setTimeout(resolve5, ms));
      }
    };
    __name(_GitHubClient, "GitHubClient");
    GitHubClient = _GitHubClient;
  }
});

// src/commands/sync/setup.ts
function createSyncSetupCommand() {
  const command = new import_commander55.Command("setup");
  command.description("Configure GitHub sync for the project").option("--repository <repo>", "GitHub repository (owner/repo format)").option("--token <token>", "GitHub personal access token").option("--auto-sync", "Enable automatic sync").option("--no-auto-sync", "Disable automatic sync").option("--conflict-resolution <strategy>", "Conflict resolution strategy (most_recent|local_wins|remote_wins)", "most_recent").option("--sync-labels", "Enable label synchronization").option("--no-sync-labels", "Disable label synchronization").option("--sync-milestones", "Enable milestone synchronization").option("--no-sync-milestones", "Disable milestone synchronization").option("--sync-assignees", "Enable assignee synchronization").option("--no-sync-assignees", "Disable assignee synchronization").option("--batch-size <size>", "Batch size for sync operations", "50").option("--rate-limit-delay <ms>", "Delay between API calls in milliseconds", "100").option("--dry-run", "Show what would be configured without making changes").option("--force", "Force setup even if already configured").action(async (options) => {
    var _a;
    try {
      const configManager = new ConfigManager2();
      const config = configManager.getConfig();
      if (((_a = config.github_sync) == null ? void 0 : _a.enabled) && !options.force) {
        console.log(Formatter.warning("GitHub sync is already configured. Use --force to reconfigure."));
        console.log(Formatter.info(`Current repository: ${config.github_sync.repository}`));
        console.log(Formatter.info(`Auto sync: ${config.github_sync.auto_sync ? "enabled" : "disabled"}`));
        console.log(Formatter.info(`Conflict resolution: ${config.github_sync.conflict_resolution}`));
        return;
      }
      console.log(Formatter.header("\u{1F527} GitHub Sync Setup"));
      console.log(Formatter.info("Configure bidirectional sync between local issues and GitHub Issues"));
      console.log("");
      let syncConfig;
      if (options.repository && options.token) {
        syncConfig = {
          enabled: true,
          repository: options.repository,
          token: options.token,
          auto_sync: options.autoSync ?? false,
          conflict_resolution: options.conflictResolution || "most_recent",
          sync_labels: options.syncLabels ?? true,
          sync_milestones: options.syncMilestones ?? true,
          sync_assignees: options.syncAssignees ?? true,
          batch_size: parseInt(options.batchSize) || 50,
          rate_limit_delay: parseInt(options.rateLimitDelay) || 100
        };
      } else {
        const answers = await import_inquirer5.default.prompt([
          {
            type: "input",
            name: "repository",
            message: "GitHub repository (owner/repo format):",
            validate: /* @__PURE__ */ __name((input) => {
              if (!input.includes("/")) {
                return "Repository must be in owner/repo format";
              }
              return true;
            }, "validate"),
            default: options.repository
          },
          {
            type: "password",
            name: "token",
            message: "GitHub personal access token:",
            validate: /* @__PURE__ */ __name((input) => {
              if (input.length < 10) {
                return "Token appears to be too short";
              }
              return true;
            }, "validate"),
            default: options.token
          },
          {
            type: "confirm",
            name: "auto_sync",
            message: "Enable automatic sync?",
            default: options.autoSync ?? false
          },
          {
            type: "list",
            name: "conflict_resolution",
            message: "Conflict resolution strategy:",
            choices: [
              { name: "Most recent wins (recommended)", value: "most_recent" },
              { name: "Local always wins", value: "local_wins" },
              { name: "Remote always wins", value: "remote_wins" }
            ],
            default: options.conflictResolution || "most_recent"
          },
          {
            type: "confirm",
            name: "sync_labels",
            message: "Sync labels between local tags and GitHub labels?",
            default: options.syncLabels ?? true
          },
          {
            type: "confirm",
            name: "sync_milestones",
            message: "Sync milestones between local and GitHub?",
            default: options.syncMilestones ?? true
          },
          {
            type: "confirm",
            name: "sync_assignees",
            message: "Sync assignees between local and GitHub?",
            default: options.syncAssignees ?? true
          },
          {
            type: "number",
            name: "batch_size",
            message: "Batch size for sync operations:",
            default: parseInt(options.batchSize) || 50,
            validate: /* @__PURE__ */ __name((input) => input > 0 && input <= 100, "validate")
          },
          {
            type: "number",
            name: "rate_limit_delay",
            message: "Rate limit delay (ms) between API calls:",
            default: parseInt(options.rateLimitDelay) || 100,
            validate: /* @__PURE__ */ __name((input) => input >= 0, "validate")
          }
        ]);
        syncConfig = {
          enabled: true,
          ...answers
        };
      }
      if (options.dryRun) {
        console.log(Formatter.info("Dry run - configuration that would be applied:"));
        console.log(JSON.stringify(syncConfig, null, 2));
        return;
      }
      console.log(Formatter.info("Testing GitHub connection..."));
      const testClient = new GitHubClient(syncConfig);
      const testResult = await testClient.testConnection();
      if (!testResult.success) {
        console.log(Formatter.error("GitHub connection test failed:"));
        console.log(Formatter.error(testResult.message));
        return;
      }
      console.log(Formatter.success("GitHub connection test passed!"));
      const updatedConfig = {
        ...config,
        github_sync: syncConfig
      };
      configManager.saveConfig(updatedConfig);
      console.log(Formatter.success("GitHub sync configuration saved successfully!"));
      console.log("");
      console.log(Formatter.info("Configuration summary:"));
      console.log(`  Repository: ${syncConfig.repository}`);
      console.log(`  Auto sync: ${syncConfig.auto_sync ? "enabled" : "disabled"}`);
      console.log(`  Conflict resolution: ${syncConfig.conflict_resolution}`);
      console.log(`  Sync labels: ${syncConfig.sync_labels ? "enabled" : "disabled"}`);
      console.log(`  Sync milestones: ${syncConfig.sync_milestones ? "enabled" : "disabled"}`);
      console.log(`  Sync assignees: ${syncConfig.sync_assignees ? "enabled" : "disabled"}`);
      console.log(`  Batch size: ${syncConfig.batch_size}`);
      console.log(`  Rate limit delay: ${syncConfig.rate_limit_delay}ms`);
      console.log("");
      console.log(Formatter.info("Next steps:"));
      console.log('  \u2022 Run "aitrackdown sync status" to check sync status');
      console.log('  \u2022 Run "aitrackdown sync pull" to pull existing GitHub issues');
      console.log('  \u2022 Run "aitrackdown sync push" to push local issues to GitHub');
      console.log('  \u2022 Run "aitrackdown sync auto" to enable automatic sync');
    } catch (error) {
      console.error(Formatter.error("Setup failed:"));
      console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });
  return command;
}
var import_commander55, import_inquirer5;
var init_setup = __esm({
  "src/commands/sync/setup.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander55 = require("commander");
    import_inquirer5 = __toESM(require("inquirer"), 1);
    init_formatter();
    init_config_manager();
    init_github_client();
    __name(createSyncSetupCommand, "createSyncSetupCommand");
  }
});

// src/integrations/github-sync.ts
var fs29, path28, _GitHubSyncEngine, GitHubSyncEngine;
var init_github_sync = __esm({
  "src/integrations/github-sync.ts"() {
    "use strict";
    init_cjs_shims();
    fs29 = __toESM(require("fs"), 1);
    path28 = __toESM(require("path"), 1);
    init_github_client();
    init_frontmatter_parser();
    _GitHubSyncEngine = class _GitHubSyncEngine {
      client;
      configManager;
      config;
      syncConfig;
      frontmatterParser;
      constructor(configManager) {
        var _a;
        this.configManager = configManager;
        this.config = configManager.getConfig();
        this.frontmatterParser = new FrontmatterParser();
        if (!((_a = this.config.github_sync) == null ? void 0 : _a.enabled)) {
          throw new Error("GitHub sync is not enabled in project configuration");
        }
        this.syncConfig = this.config.github_sync;
        this.client = new GitHubClient(this.syncConfig);
      }
      /**
       * Test GitHub connection
       */
      async testConnection() {
        return await this.client.testConnection();
      }
      /**
       * Get sync status
       */
      async getSyncStatus() {
        try {
          const rateLimit = await this.client.getRateLimit();
          const localIssues = await this.getLocalIssues();
          const syncMetaFile = this.getSyncMetaPath();
          let lastSync = "";
          let conflicts = 0;
          if (fs29.existsSync(syncMetaFile)) {
            const syncMeta = JSON.parse(fs29.readFileSync(syncMetaFile, "utf8"));
            lastSync = syncMeta.last_sync || "";
            conflicts = syncMeta.conflicts || 0;
          }
          return {
            enabled: this.syncConfig.enabled,
            repository: this.syncConfig.repository,
            last_sync: lastSync,
            auto_sync: this.syncConfig.auto_sync,
            pending_operations: localIssues.filter(
              (issue) => issue.sync_status === "local" || issue.sync_status === "conflict"
            ).length,
            conflicts,
            sync_health: rateLimit.remaining > 100 ? "healthy" : "degraded"
          };
        } catch (error) {
          return {
            enabled: this.syncConfig.enabled,
            repository: this.syncConfig.repository,
            last_sync: "",
            auto_sync: this.syncConfig.auto_sync,
            pending_operations: 0,
            conflicts: 0,
            sync_health: "failed"
          };
        }
      }
      /**
       * Push local changes to GitHub
       */
      async pushToGitHub() {
        const result = {
          success: false,
          operations: [],
          errors: [],
          conflicts: [],
          pushed_count: 0,
          pulled_count: 0,
          skipped_count: 0,
          conflict_count: 0
        };
        try {
          const localIssues = await this.getLocalIssues();
          const githubIssues = await this.client.getAllIssues();
          const githubIssuesMap = new Map(githubIssues.map((issue) => [issue.number, issue]));
          for (const localIssue of localIssues) {
            const operation = await this.processPushOperation(localIssue, githubIssuesMap);
            result.operations.push(operation);
            if (operation.type === "push") {
              result.pushed_count++;
            } else if (operation.type === "conflict") {
              result.conflicts.push(operation);
              result.conflict_count++;
            } else {
              result.skipped_count++;
            }
          }
          await this.updateSyncMetadata(result);
          result.success = result.errors.length === 0;
          return result;
        } catch (error) {
          result.errors.push(error instanceof Error ? error.message : "Unknown error during push");
          return result;
        }
      }
      /**
       * Pull changes from GitHub
       */
      async pullFromGitHub() {
        const result = {
          success: false,
          operations: [],
          errors: [],
          conflicts: [],
          pushed_count: 0,
          pulled_count: 0,
          skipped_count: 0,
          conflict_count: 0
        };
        try {
          const githubIssues = await this.client.getAllIssues();
          const localIssues = await this.getLocalIssues();
          const localIssuesMap = new Map(
            localIssues.filter((issue) => issue.github_number).map((issue) => [issue.github_number, issue])
          );
          for (const githubIssue of githubIssues) {
            const operation = await this.processPullOperation(githubIssue, localIssuesMap);
            result.operations.push(operation);
            if (operation.type === "pull") {
              result.pulled_count++;
            } else if (operation.type === "conflict") {
              result.conflicts.push(operation);
              result.conflict_count++;
            } else {
              result.skipped_count++;
            }
          }
          await this.updateSyncMetadata(result);
          result.success = result.errors.length === 0;
          return result;
        } catch (error) {
          result.errors.push(error instanceof Error ? error.message : "Unknown error during pull");
          return result;
        }
      }
      /**
       * Bidirectional sync with conflict resolution
       */
      async bidirectionalSync() {
        const result = {
          success: false,
          operations: [],
          errors: [],
          conflicts: [],
          pushed_count: 0,
          pulled_count: 0,
          skipped_count: 0,
          conflict_count: 0
        };
        try {
          const localIssues = await this.getLocalIssues();
          const githubIssues = await this.client.getAllIssues();
          const githubIssuesMap = new Map(githubIssues.map((issue) => [issue.number, issue]));
          const localIssuesMap = new Map(
            localIssues.filter((issue) => issue.github_number).map((issue) => [issue.github_number, issue])
          );
          for (const localIssue of localIssues) {
            const operation = await this.processBidirectionalOperation(localIssue, githubIssuesMap, "push");
            result.operations.push(operation);
            this.updateResultCounters(result, operation);
          }
          for (const githubIssue of githubIssues) {
            if (!localIssuesMap.has(githubIssue.number)) {
              const operation = await this.processBidirectionalOperation(null, githubIssuesMap, "pull", githubIssue);
              result.operations.push(operation);
              this.updateResultCounters(result, operation);
            }
          }
          await this.updateSyncMetadata(result);
          result.success = result.errors.length === 0;
          return result;
        } catch (error) {
          result.errors.push(error instanceof Error ? error.message : "Unknown error during bidirectional sync");
          return result;
        }
      }
      /**
       * Process push operation for a local issue
       */
      async processPushOperation(localIssue, githubIssuesMap) {
        const operation = {
          type: "push",
          local_issue: localIssue,
          action: "skip",
          reason: "No changes needed"
        };
        try {
          if (localIssue.github_number) {
            const githubIssue = githubIssuesMap.get(localIssue.github_number);
            if (githubIssue) {
              operation.github_issue = githubIssue;
              if (await this.hasConflict(localIssue, githubIssue)) {
                operation.type = "conflict";
                operation.reason = "Conflict detected - both local and GitHub have changes";
                return operation;
              }
              const updatedGitHubIssue = await this.client.updateIssue(localIssue.github_number, {
                title: localIssue.title,
                body: this.createGitHubIssueBody(localIssue),
                state: this.mapStatusToGitHubState(localIssue.status),
                assignee: this.syncConfig.sync_assignees ? localIssue.assignee : void 0,
                labels: this.syncConfig.sync_labels ? localIssue.tags : void 0
              });
              operation.action = "update";
              operation.github_issue = updatedGitHubIssue;
              await this.updateLocalIssueWithGitHubMetadata(localIssue, updatedGitHubIssue);
            }
          } else {
            const newGitHubIssue = await this.client.createIssue({
              title: localIssue.title,
              body: this.createGitHubIssueBody(localIssue),
              assignee: this.syncConfig.sync_assignees ? localIssue.assignee : void 0,
              labels: this.syncConfig.sync_labels ? localIssue.tags : void 0
            });
            operation.action = "create";
            operation.github_issue = newGitHubIssue;
            await this.updateLocalIssueWithGitHubMetadata(localIssue, newGitHubIssue);
          }
        } catch (error) {
          operation.reason = `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
        }
        return operation;
      }
      /**
       * Process pull operation for a GitHub issue
       */
      async processPullOperation(githubIssue, localIssuesMap) {
        const operation = {
          type: "pull",
          local_issue: {},
          github_issue: githubIssue,
          action: "skip",
          reason: "No changes needed"
        };
        try {
          const localIssue = localIssuesMap.get(githubIssue.number);
          if (localIssue) {
            operation.local_issue = localIssue;
            if (await this.hasConflict(localIssue, githubIssue)) {
              operation.type = "conflict";
              operation.reason = "Conflict detected - both local and GitHub have changes";
              return operation;
            }
            await this.updateLocalIssueFromGitHub(localIssue, githubIssue);
            operation.action = "update";
          } else {
            const newLocalIssue = await this.createLocalIssueFromGitHub(githubIssue);
            operation.local_issue = newLocalIssue;
            operation.action = "create";
          }
        } catch (error) {
          operation.reason = `Error: ${error instanceof Error ? error.message : "Unknown error"}`;
        }
        return operation;
      }
      /**
       * Process bidirectional operation
       */
      async processBidirectionalOperation(localIssue, githubIssuesMap, direction, githubIssue) {
        if (direction === "push" && localIssue) {
          return this.processPushOperation(localIssue, githubIssuesMap);
        } else if (direction === "pull" && githubIssue) {
          const localIssuesMap = /* @__PURE__ */ new Map();
          return this.processPullOperation(githubIssue, localIssuesMap);
        }
        return {
          type: direction,
          local_issue: localIssue || {},
          github_issue: githubIssue,
          action: "skip",
          reason: "Invalid operation parameters"
        };
      }
      /**
       * Check if there's a conflict between local and GitHub issues
       */
      async hasConflict(localIssue, githubIssue) {
        if (this.syncConfig.conflict_resolution === "local_wins" || this.syncConfig.conflict_resolution === "remote_wins") {
          return false;
        }
        const localUpdated = new Date(localIssue.updated_date);
        const githubUpdated = new Date(githubIssue.updated_at);
        const lastSync = await this.getLastSyncTime();
        return localUpdated > lastSync && githubUpdated > lastSync;
      }
      /**
       * Get local issues from the file system
       */
      async getLocalIssues() {
        const paths = this.configManager.getAbsolutePaths();
        const issuesDir = paths.issuesDir;
        if (!fs29.existsSync(issuesDir)) {
          return [];
        }
        const issues = [];
        const files = fs29.readdirSync(issuesDir).filter((file) => file.endsWith(".md"));
        for (const file of files) {
          try {
            const filePath = path28.join(issuesDir, file);
            const content = fs29.readFileSync(filePath, "utf8");
            const parsed = this.frontmatterParser.parse(content);
            const issueData = {
              ...parsed.frontmatter,
              content: parsed.content,
              file_path: filePath
            };
            issues.push(issueData);
          } catch (error) {
            console.warn(`Failed to parse issue file ${file}: ${error instanceof Error ? error.message : "Unknown error"}`);
          }
        }
        return issues;
      }
      /**
       * Create GitHub issue body from local issue
       */
      createGitHubIssueBody(localIssue) {
        const aiMetadata = {
          ai_context: localIssue.ai_context,
          estimated_tokens: localIssue.estimated_tokens,
          actual_tokens: localIssue.actual_tokens,
          epic_id: localIssue.epic_id,
          issue_id: localIssue.issue_id,
          local_created_date: localIssue.created_date,
          local_updated_date: localIssue.updated_date
        };
        return `${localIssue.content}

<!-- AI-Trackdown Metadata -->
\`\`\`json
${JSON.stringify(aiMetadata, null, 2)}
\`\`\``;
      }
      /**
       * Map local status to GitHub state
       */
      mapStatusToGitHubState(status) {
        switch (status) {
          case "completed":
          case "archived":
            return "closed";
          default:
            return "open";
        }
      }
      /**
       * Map GitHub state to local status
       */
      mapGitHubStateToStatus(state) {
        return state === "closed" ? "completed" : "active";
      }
      /**
       * Update local issue with GitHub metadata
       */
      async updateLocalIssueWithGitHubMetadata(localIssue, githubIssue) {
        const updatedFrontmatter = {
          ...localIssue,
          github_id: githubIssue.id,
          github_number: githubIssue.number,
          github_url: githubIssue.html_url,
          github_updated_at: githubIssue.updated_at,
          sync_status: "synced",
          updated_date: (/* @__PURE__ */ new Date()).toISOString()
        };
        if (this.syncConfig.sync_labels && githubIssue.labels.length > 0) {
          updatedFrontmatter.github_labels = githubIssue.labels.map((label) => label.name);
        }
        if (this.syncConfig.sync_assignees && githubIssue.assignee) {
          updatedFrontmatter.github_assignee = githubIssue.assignee.login;
        }
        if (this.syncConfig.sync_milestones && githubIssue.milestone) {
          updatedFrontmatter.github_milestone = githubIssue.milestone.title;
        }
        const updatedContent = this.frontmatterParser.stringify(updatedFrontmatter, localIssue.content);
        fs29.writeFileSync(localIssue.file_path, updatedContent, "utf8");
      }
      /**
       * Update local issue from GitHub
       */
      async updateLocalIssueFromGitHub(localIssue, githubIssue) {
        const updatedFrontmatter = {
          ...localIssue,
          title: githubIssue.title,
          status: this.mapGitHubStateToStatus(githubIssue.state),
          github_id: githubIssue.id,
          github_number: githubIssue.number,
          github_url: githubIssue.html_url,
          github_updated_at: githubIssue.updated_at,
          sync_status: "synced",
          updated_date: (/* @__PURE__ */ new Date()).toISOString()
        };
        if (this.syncConfig.sync_labels && githubIssue.labels.length > 0) {
          updatedFrontmatter.tags = githubIssue.labels.map((label) => label.name);
          updatedFrontmatter.github_labels = githubIssue.labels.map((label) => label.name);
        }
        if (this.syncConfig.sync_assignees && githubIssue.assignee) {
          updatedFrontmatter.assignee = githubIssue.assignee.login;
          updatedFrontmatter.github_assignee = githubIssue.assignee.login;
        }
        if (this.syncConfig.sync_milestones && githubIssue.milestone) {
          updatedFrontmatter.milestone = githubIssue.milestone.title;
          updatedFrontmatter.github_milestone = githubIssue.milestone.title;
        }
        const content = this.extractContentFromGitHubBody(githubIssue.body);
        const updatedContent = this.frontmatterParser.stringify(updatedFrontmatter, content);
        fs29.writeFileSync(localIssue.file_path, updatedContent, "utf8");
      }
      /**
       * Create local issue from GitHub
       */
      async createLocalIssueFromGitHub(githubIssue) {
        var _a, _b, _c, _d;
        const paths = this.configManager.getAbsolutePaths();
        const issuesDir = paths.issuesDir;
        const issueId = `${this.config.naming_conventions.issue_prefix}-${String(githubIssue.number).padStart(4, "0")}`;
        const filename = `${issueId}.md`;
        const filePath = path28.join(issuesDir, filename);
        const newIssue = {
          issue_id: issueId,
          epic_id: "",
          // Will need to be assigned manually
          title: githubIssue.title,
          description: githubIssue.body,
          status: this.mapGitHubStateToStatus(githubIssue.state),
          priority: "medium",
          assignee: ((_a = githubIssue.assignee) == null ? void 0 : _a.login) || this.config.default_assignee || "unassigned",
          created_date: githubIssue.created_at,
          updated_date: (/* @__PURE__ */ new Date()).toISOString(),
          estimated_tokens: 0,
          actual_tokens: 0,
          ai_context: [],
          sync_status: "synced",
          related_tasks: [],
          github_id: githubIssue.id,
          github_number: githubIssue.number,
          github_url: githubIssue.html_url,
          github_updated_at: githubIssue.updated_at,
          tags: this.syncConfig.sync_labels ? githubIssue.labels.map((label) => label.name) : [],
          github_labels: githubIssue.labels.map((label) => label.name),
          github_assignee: (_b = githubIssue.assignee) == null ? void 0 : _b.login,
          github_milestone: (_c = githubIssue.milestone) == null ? void 0 : _c.title,
          milestone: this.syncConfig.sync_milestones ? (_d = githubIssue.milestone) == null ? void 0 : _d.title : void 0
        };
        const content = this.extractContentFromGitHubBody(githubIssue.body);
        const issueContent = this.frontmatterParser.stringify(newIssue, content);
        fs29.writeFileSync(filePath, issueContent, "utf8");
        return {
          ...newIssue,
          content,
          file_path: filePath
        };
      }
      /**
       * Extract content from GitHub issue body, removing AI metadata
       */
      extractContentFromGitHubBody(body) {
        const metadataRegex = /<!-- AI-Trackdown Metadata -->\s*```json[\s\S]*?```/;
        return body.replace(metadataRegex, "").trim();
      }
      /**
       * Get last sync time
       */
      async getLastSyncTime() {
        const syncMetaFile = this.getSyncMetaPath();
        if (fs29.existsSync(syncMetaFile)) {
          const syncMeta = JSON.parse(fs29.readFileSync(syncMetaFile, "utf8"));
          return new Date(syncMeta.last_sync || 0);
        }
        return /* @__PURE__ */ new Date(0);
      }
      /**
       * Update sync metadata
       */
      async updateSyncMetadata(result) {
        const syncMetaFile = this.getSyncMetaPath();
        const syncMeta = {
          last_sync: (/* @__PURE__ */ new Date()).toISOString(),
          last_result: result,
          conflicts: result.conflict_count
        };
        fs29.writeFileSync(syncMetaFile, JSON.stringify(syncMeta, null, 2), "utf8");
      }
      /**
       * Get sync metadata file path
       */
      getSyncMetaPath() {
        const paths = this.configManager.getAbsolutePaths();
        return path28.join(paths.configDir, "sync-metadata.json");
      }
      /**
       * Update result counters
       */
      updateResultCounters(result, operation) {
        if (operation.type === "push") {
          result.pushed_count++;
        } else if (operation.type === "pull") {
          result.pulled_count++;
        } else if (operation.type === "conflict") {
          result.conflicts.push(operation);
          result.conflict_count++;
        } else {
          result.skipped_count++;
        }
      }
    };
    __name(_GitHubSyncEngine, "GitHubSyncEngine");
    GitHubSyncEngine = _GitHubSyncEngine;
  }
});

// src/commands/sync/push.ts
function createSyncPushCommand() {
  const command = new import_commander56.Command("push");
  command.description("Push local changes to GitHub").option("--dry-run", "Show what would be pushed without making changes").option("--force", "Force push even with conflicts").option("--verbose", "Show detailed progress information").action(async (options) => {
    var _a;
    try {
      const configManager = new ConfigManager2();
      const config = configManager.getConfig();
      if (!((_a = config.github_sync) == null ? void 0 : _a.enabled)) {
        console.log(Formatter.error('GitHub sync is not configured. Run "aitrackdown sync setup" first.'));
        process.exit(1);
      }
      console.log(Formatter.header("\u{1F4E4} Pushing Local Changes to GitHub"));
      console.log(Formatter.info(`Repository: ${config.github_sync.repository}`));
      console.log("");
      const syncEngine = new GitHubSyncEngine(configManager);
      const spinner = (0, import_ora5.default)("Testing GitHub connection...").start();
      const testResult = await syncEngine.testConnection();
      if (!testResult.success) {
        spinner.fail("GitHub connection failed");
        console.log(Formatter.error(testResult.message));
        process.exit(1);
      }
      spinner.succeed("GitHub connection verified");
      const pushSpinner = (0, import_ora5.default)("Pushing local changes to GitHub...").start();
      try {
        const result = await syncEngine.pushToGitHub();
        if (options.dryRun) {
          pushSpinner.succeed("Dry run completed");
          console.log(Formatter.info("Operations that would be performed:"));
        } else {
          pushSpinner.succeed("Push completed");
        }
        console.log("");
        console.log(Formatter.info("Push Summary:"));
        console.log(`  Pushed: ${result.pushed_count} issues`);
        console.log(`  Skipped: ${result.skipped_count} issues`);
        console.log(`  Conflicts: ${result.conflict_count} issues`);
        console.log(`  Errors: ${result.errors.length}`);
        if (result.errors.length > 0) {
          console.log("");
          console.log(Formatter.error("Errors encountered:"));
          result.errors.forEach((error) => {
            console.log(`  \u2022 ${error}`);
          });
        }
        if (result.conflicts.length > 0) {
          console.log("");
          console.log(Formatter.warning("Conflicts detected:"));
          result.conflicts.forEach((conflict) => {
            console.log(`  \u2022 ${conflict.local_issue.title} (${conflict.local_issue.issue_id})`);
            console.log(`    Reason: ${conflict.reason}`);
          });
          if (!options.force) {
            console.log("");
            console.log(Formatter.info("To resolve conflicts:"));
            console.log('  \u2022 Use "aitrackdown sync status" to see detailed conflict information');
            console.log('  \u2022 Use "aitrackdown sync push --force" to force push local changes');
            console.log('  \u2022 Use "aitrackdown sync pull" to pull remote changes');
          }
        }
        if (options.verbose) {
          console.log("");
          console.log(Formatter.info("Detailed Operations:"));
          result.operations.forEach((op, index) => {
            console.log(`  ${index + 1}. ${op.local_issue.title} (${op.local_issue.issue_id})`);
            console.log(`     Type: ${op.type}`);
            console.log(`     Action: ${op.action}`);
            if (op.reason) {
              console.log(`     Reason: ${op.reason}`);
            }
            if (op.github_issue) {
              console.log(`     GitHub: #${op.github_issue.number} - ${op.github_issue.html_url}`);
            }
          });
        }
        if (result.success) {
          console.log("");
          console.log(Formatter.success("Push operation completed successfully!"));
        } else {
          console.log("");
          console.log(Formatter.warning("Push operation completed with issues. Review the errors above."));
        }
      } catch (error) {
        pushSpinner.fail("Push failed");
        throw error;
      }
    } catch (error) {
      console.error(Formatter.error("Push failed:"));
      console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });
  return command;
}
var import_commander56, import_ora5;
var init_push = __esm({
  "src/commands/sync/push.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander56 = require("commander");
    import_ora5 = __toESM(require("ora"), 1);
    init_formatter();
    init_config_manager();
    init_github_sync();
    __name(createSyncPushCommand, "createSyncPushCommand");
  }
});

// src/commands/sync/pull.ts
function createSyncPullCommand() {
  const command = new import_commander57.Command("pull");
  command.description("Pull changes from GitHub to local").option("--dry-run", "Show what would be pulled without making changes").option("--force", "Force pull even with conflicts").option("--verbose", "Show detailed progress information").action(async (options) => {
    var _a;
    try {
      const configManager = new ConfigManager2();
      const config = configManager.getConfig();
      if (!((_a = config.github_sync) == null ? void 0 : _a.enabled)) {
        console.log(Formatter.error('GitHub sync is not configured. Run "aitrackdown sync setup" first.'));
        process.exit(1);
      }
      console.log(Formatter.header("\u{1F4E5} Pulling Changes from GitHub"));
      console.log(Formatter.info(`Repository: ${config.github_sync.repository}`));
      console.log("");
      const syncEngine = new GitHubSyncEngine(configManager);
      const spinner = (0, import_ora6.default)("Testing GitHub connection...").start();
      const testResult = await syncEngine.testConnection();
      if (!testResult.success) {
        spinner.fail("GitHub connection failed");
        console.log(Formatter.error(testResult.message));
        process.exit(1);
      }
      spinner.succeed("GitHub connection verified");
      const pullSpinner = (0, import_ora6.default)("Pulling changes from GitHub...").start();
      try {
        const result = await syncEngine.pullFromGitHub();
        if (options.dryRun) {
          pullSpinner.succeed("Dry run completed");
          console.log(Formatter.info("Operations that would be performed:"));
        } else {
          pullSpinner.succeed("Pull completed");
        }
        console.log("");
        console.log(Formatter.info("Pull Summary:"));
        console.log(`  Pulled: ${result.pulled_count} issues`);
        console.log(`  Skipped: ${result.skipped_count} issues`);
        console.log(`  Conflicts: ${result.conflict_count} issues`);
        console.log(`  Errors: ${result.errors.length}`);
        if (result.errors.length > 0) {
          console.log("");
          console.log(Formatter.error("Errors encountered:"));
          result.errors.forEach((error) => {
            console.log(`  \u2022 ${error}`);
          });
        }
        if (result.conflicts.length > 0) {
          console.log("");
          console.log(Formatter.warning("Conflicts detected:"));
          result.conflicts.forEach((conflict) => {
            console.log(`  \u2022 ${conflict.local_issue.title} (${conflict.local_issue.issue_id})`);
            console.log(`    Reason: ${conflict.reason}`);
            if (conflict.github_issue) {
              console.log(`    GitHub: #${conflict.github_issue.number} - ${conflict.github_issue.html_url}`);
            }
          });
          if (!options.force) {
            console.log("");
            console.log(Formatter.info("To resolve conflicts:"));
            console.log('  \u2022 Use "aitrackdown sync status" to see detailed conflict information');
            console.log('  \u2022 Use "aitrackdown sync pull --force" to force pull remote changes');
            console.log('  \u2022 Use "aitrackdown sync push" to push local changes');
          }
        }
        if (options.verbose) {
          console.log("");
          console.log(Formatter.info("Detailed Operations:"));
          result.operations.forEach((op, index) => {
            var _a2, _b;
            console.log(`  ${index + 1}. ${((_a2 = op.github_issue) == null ? void 0 : _a2.title) || "Unknown"} (#${(_b = op.github_issue) == null ? void 0 : _b.number})`);
            console.log(`     Type: ${op.type}`);
            console.log(`     Action: ${op.action}`);
            if (op.reason) {
              console.log(`     Reason: ${op.reason}`);
            }
            if (op.github_issue) {
              console.log(`     GitHub: ${op.github_issue.html_url}`);
            }
            if (op.local_issue.issue_id) {
              console.log(`     Local: ${op.local_issue.issue_id}`);
            }
          });
        }
        if (result.success) {
          console.log("");
          console.log(Formatter.success("Pull operation completed successfully!"));
          if (result.pulled_count > 0) {
            console.log("");
            console.log(Formatter.info("Next steps:"));
            console.log("  \u2022 Review the pulled issues in your local files");
            console.log("  \u2022 Assign issues to appropriate epics if needed");
            console.log("  \u2022 Update AI context and token estimates as needed");
          }
        } else {
          console.log("");
          console.log(Formatter.warning("Pull operation completed with issues. Review the errors above."));
        }
      } catch (error) {
        pullSpinner.fail("Pull failed");
        throw error;
      }
    } catch (error) {
      console.error(Formatter.error("Pull failed:"));
      console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });
  return command;
}
var import_commander57, import_ora6;
var init_pull = __esm({
  "src/commands/sync/pull.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander57 = require("commander");
    import_ora6 = __toESM(require("ora"), 1);
    init_formatter();
    init_config_manager();
    init_github_sync();
    __name(createSyncPullCommand, "createSyncPullCommand");
  }
});

// src/commands/sync/status.ts
function createSyncStatusCommand() {
  const command = new import_commander58.Command("status");
  command.description("Show sync status and conflicts").option("--verbose", "Show detailed status information").option("--conflicts-only", "Show only conflicts").action(async (options) => {
    var _a;
    try {
      const configManager = new ConfigManager2();
      const config = configManager.getConfig();
      if (!((_a = config.github_sync) == null ? void 0 : _a.enabled)) {
        console.log(Formatter.error('GitHub sync is not configured. Run "aitrackdown sync setup" first.'));
        process.exit(1);
      }
      console.log(Formatter.header("\u{1F504} GitHub Sync Status"));
      console.log(Formatter.info(`Repository: ${config.github_sync.repository}`));
      console.log("");
      const syncEngine = new GitHubSyncEngine(configManager);
      const spinner = (0, import_ora7.default)("Checking GitHub connection...").start();
      const testResult = await syncEngine.testConnection();
      if (!testResult.success) {
        spinner.fail("GitHub connection failed");
        console.log(Formatter.error(testResult.message));
        process.exit(1);
      }
      spinner.succeed("GitHub connection verified");
      const statusSpinner = (0, import_ora7.default)("Fetching sync status...").start();
      try {
        const status = await syncEngine.getSyncStatus();
        statusSpinner.succeed("Sync status retrieved");
        if (!options.conflictsOnly) {
          console.log("");
          console.log(Formatter.info("Sync Configuration:"));
          console.log(`  Repository: ${status.repository}`);
          console.log(`  Auto sync: ${status.auto_sync ? "enabled" : "disabled"}`);
          console.log(`  Conflict resolution: ${config.github_sync.conflict_resolution}`);
          console.log(`  Sync labels: ${config.github_sync.sync_labels ? "enabled" : "disabled"}`);
          console.log(`  Sync milestones: ${config.github_sync.sync_milestones ? "enabled" : "disabled"}`);
          console.log(`  Sync assignees: ${config.github_sync.sync_assignees ? "enabled" : "disabled"}`);
          console.log("");
          console.log(Formatter.info("Sync Status:"));
          console.log(`  Last sync: ${status.last_sync || "Never"}`);
          console.log(`  Pending operations: ${status.pending_operations}`);
          console.log(`  Conflicts: ${status.conflicts}`);
          console.log(`  Health: ${status.sync_health}`);
          const healthIcon = status.sync_health === "healthy" ? "\u2705" : status.sync_health === "degraded" ? "\u26A0\uFE0F" : "\u274C";
          console.log(`  Status: ${healthIcon} ${status.sync_health}`);
        }
        if (status.conflicts > 0) {
          console.log("");
          console.log(Formatter.warning(`\u26A0\uFE0F ${status.conflicts} conflicts detected`));
          if (options.verbose) {
            const conflictSpinner = (0, import_ora7.default)("Analyzing conflicts...").start();
            try {
              const dryRunResult = await syncEngine.bidirectionalSync();
              conflictSpinner.succeed("Conflict analysis completed");
              if (dryRunResult.conflicts.length > 0) {
                console.log("");
                console.log(Formatter.warning("Conflict Details:"));
                dryRunResult.conflicts.forEach((conflict, index) => {
                  console.log(`  ${index + 1}. ${conflict.local_issue.title} (${conflict.local_issue.issue_id})`);
                  console.log(`     Reason: ${conflict.reason}`);
                  if (conflict.github_issue) {
                    console.log(`     GitHub: #${conflict.github_issue.number} - ${conflict.github_issue.html_url}`);
                    console.log(`     Local updated: ${conflict.local_issue.updated_date}`);
                    console.log(`     GitHub updated: ${conflict.github_issue.updated_at}`);
                  }
                  console.log("");
                });
              }
            } catch (error) {
              conflictSpinner.fail("Failed to analyze conflicts");
              console.log(Formatter.error(`Error: ${error instanceof Error ? error.message : "Unknown error"}`));
            }
          }
          console.log(Formatter.info("Conflict Resolution Options:"));
          console.log('  \u2022 Use "aitrackdown sync push --force" to push local changes');
          console.log('  \u2022 Use "aitrackdown sync pull --force" to pull remote changes');
          console.log("  \u2022 Manually resolve conflicts and sync again");
        }
        if (options.verbose && !options.conflictsOnly) {
          const rateLimitSpinner = (0, import_ora7.default)("Checking rate limit...").start();
          try {
            const client = new (await Promise.resolve().then(() => (init_github_client(), github_client_exports))).GitHubClient(config.github_sync);
            const rateLimit = await client.getRateLimit();
            rateLimitSpinner.succeed("Rate limit information retrieved");
            console.log("");
            console.log(Formatter.info("GitHub API Rate Limit:"));
            console.log(`  Limit: ${rateLimit.limit} requests/hour`);
            console.log(`  Remaining: ${rateLimit.remaining} requests`);
            console.log(`  Used: ${rateLimit.used} requests`);
            console.log(`  Reset: ${rateLimit.reset.toLocaleString()}`);
            const rateLimitPercentage = rateLimit.remaining / rateLimit.limit * 100;
            const rateLimitIcon = rateLimitPercentage > 50 ? "\u2705" : rateLimitPercentage > 20 ? "\u26A0\uFE0F" : "\u274C";
            console.log(`  Health: ${rateLimitIcon} ${rateLimitPercentage.toFixed(1)}% remaining`);
          } catch (error) {
            rateLimitSpinner.fail("Failed to check rate limit");
            console.log(Formatter.error(`Error: ${error instanceof Error ? error.message : "Unknown error"}`));
          }
        }
        if (!options.conflictsOnly) {
          console.log("");
          console.log(Formatter.info("Recommendations:"));
          if (status.pending_operations > 0) {
            console.log('  \u2022 Run "aitrackdown sync push" to push local changes');
            console.log('  \u2022 Run "aitrackdown sync pull" to pull remote changes');
          }
          if (status.conflicts > 0) {
            console.log("  \u2022 Review conflicts and resolve them manually");
            console.log("  \u2022 Use --force flags to override conflicts");
          }
          if (!status.auto_sync) {
            console.log('  \u2022 Consider enabling auto-sync with "aitrackdown sync auto --enable"');
          }
          if (status.sync_health === "degraded") {
            console.log("  \u2022 Check rate limit usage and consider increasing delays");
          }
          if (status.sync_health === "failed") {
            console.log("  \u2022 Check GitHub connection and permissions");
            console.log("  \u2022 Verify token is valid and has correct permissions");
          }
        }
      } catch (error) {
        statusSpinner.fail("Failed to retrieve sync status");
        throw error;
      }
    } catch (error) {
      console.error(Formatter.error("Status check failed:"));
      console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });
  return command;
}
var import_commander58, import_ora7;
var init_status2 = __esm({
  "src/commands/sync/status.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander58 = require("commander");
    import_ora7 = __toESM(require("ora"), 1);
    init_formatter();
    init_config_manager();
    init_github_sync();
    __name(createSyncStatusCommand, "createSyncStatusCommand");
  }
});

// src/commands/sync/auto.ts
function createSyncAutoCommand() {
  const command = new import_commander59.Command("auto");
  command.description("Enable/disable automatic sync").option("--enable", "Enable automatic sync").option("--disable", "Disable automatic sync").option("--interval <minutes>", "Set auto-sync interval in minutes (default: 30)").option("--status", "Show auto-sync status").action(async (options) => {
    var _a;
    try {
      const configManager = new ConfigManager2();
      const config = configManager.getConfig();
      if (!((_a = config.github_sync) == null ? void 0 : _a.enabled)) {
        console.log(Formatter.error('GitHub sync is not configured. Run "aitrackdown sync setup" first.'));
        process.exit(1);
      }
      console.log(Formatter.header("\u{1F504} GitHub Auto-Sync Configuration"));
      console.log(Formatter.info(`Repository: ${config.github_sync.repository}`));
      console.log("");
      if (options.status) {
        console.log(Formatter.info("Current Auto-Sync Status:"));
        console.log(`  Enabled: ${config.github_sync.auto_sync ? "Yes" : "No"}`);
        console.log(`  Conflict resolution: ${config.github_sync.conflict_resolution}`);
        console.log(`  Batch size: ${config.github_sync.batch_size}`);
        console.log(`  Rate limit delay: ${config.github_sync.rate_limit_delay}ms`);
        if (config.github_sync.auto_sync) {
          console.log("");
          console.log(Formatter.info("Auto-sync is currently enabled."));
          console.log(Formatter.warning("Note: Auto-sync implementation requires a scheduler (cron, systemd timer, etc.)"));
          console.log("");
          console.log(Formatter.info("Suggested cron job (every 30 minutes):"));
          console.log("  0,30 * * * * cd /path/to/project && aitrackdown sync bidirectional");
          console.log("");
          console.log(Formatter.info("Suggested systemd timer:"));
          console.log("  # Create /etc/systemd/system/aitrackdown-sync.service");
          console.log("  # Create /etc/systemd/system/aitrackdown-sync.timer");
          console.log("  # Enable with: systemctl enable --now aitrackdown-sync.timer");
        } else {
          console.log("");
          console.log(Formatter.info("Auto-sync is currently disabled."));
          console.log('Use "aitrackdown sync auto --enable" to enable it.');
        }
        return;
      }
      if (options.enable) {
        const updatedConfig = {
          ...config,
          github_sync: {
            ...config.github_sync,
            auto_sync: true
          }
        };
        configManager.saveConfig(updatedConfig);
        console.log(Formatter.success("Auto-sync enabled successfully!"));
        console.log("");
        console.log(Formatter.info("Auto-sync configuration:"));
        console.log(`  Repository: ${updatedConfig.github_sync.repository}`);
        console.log(`  Conflict resolution: ${updatedConfig.github_sync.conflict_resolution}`);
        console.log(`  Batch size: ${updatedConfig.github_sync.batch_size}`);
        console.log(`  Rate limit delay: ${updatedConfig.github_sync.rate_limit_delay}ms`);
        console.log("");
        console.log(Formatter.warning("Important: Auto-sync requires external scheduling!"));
        console.log("");
        console.log(Formatter.info("Setup options:"));
        console.log("");
        console.log(Formatter.info("1. Cron job (recommended):"));
        console.log("   Edit crontab: crontab -e");
        console.log("   Add line: 0,30 * * * * cd /path/to/your/project && aitrackdown sync bidirectional");
        console.log("");
        console.log(Formatter.info("2. Systemd timer:"));
        console.log("   Create service file: /etc/systemd/system/aitrackdown-sync.service");
        console.log("   Create timer file: /etc/systemd/system/aitrackdown-sync.timer");
        console.log("   Enable: systemctl enable --now aitrackdown-sync.timer");
        console.log("");
        console.log(Formatter.info("3. Manual periodic execution:"));
        console.log("   Run: aitrackdown sync bidirectional");
        console.log("   Schedule as needed for your workflow");
      } else if (options.disable) {
        const updatedConfig = {
          ...config,
          github_sync: {
            ...config.github_sync,
            auto_sync: false
          }
        };
        configManager.saveConfig(updatedConfig);
        console.log(Formatter.success("Auto-sync disabled successfully!"));
        console.log("");
        console.log(Formatter.info("Manual sync commands are still available:"));
        console.log("  \u2022 aitrackdown sync push - Push local changes to GitHub");
        console.log("  \u2022 aitrackdown sync pull - Pull GitHub changes to local");
        console.log("  \u2022 aitrackdown sync bidirectional - Full bidirectional sync");
        console.log("  \u2022 aitrackdown sync status - Check sync status");
      } else {
        console.log(Formatter.info("Auto-sync management options:"));
        console.log("  --enable     Enable automatic sync");
        console.log("  --disable    Disable automatic sync");
        console.log("  --status     Show current auto-sync status");
        console.log("");
        console.log(Formatter.info("Examples:"));
        console.log("  aitrackdown sync auto --enable");
        console.log("  aitrackdown sync auto --disable");
        console.log("  aitrackdown sync auto --status");
      }
    } catch (error) {
      console.error(Formatter.error("Auto-sync configuration failed:"));
      console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });
  return command;
}
var import_commander59;
var init_auto = __esm({
  "src/commands/sync/auto.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander59 = require("commander");
    init_formatter();
    init_config_manager();
    __name(createSyncAutoCommand, "createSyncAutoCommand");
  }
});

// src/commands/sync/bidirectional.ts
function createSyncBidirectionalCommand() {
  const command = new import_commander60.Command("bidirectional");
  command.description("Perform full bidirectional sync between local and GitHub").option("--dry-run", "Show what would be synced without making changes").option("--force", "Force sync even with conflicts").option("--verbose", "Show detailed progress information").option("--conflict-resolution <strategy>", "Override conflict resolution strategy", "config").action(async (options) => {
    var _a;
    try {
      const configManager = new ConfigManager2();
      const config = configManager.getConfig();
      if (!((_a = config.github_sync) == null ? void 0 : _a.enabled)) {
        console.log(Formatter.error('GitHub sync is not configured. Run "aitrackdown sync setup" first.'));
        process.exit(1);
      }
      console.log(Formatter.header("\u{1F504} Bidirectional GitHub Sync"));
      console.log(Formatter.info(`Repository: ${config.github_sync.repository}`));
      console.log(Formatter.info(`Conflict resolution: ${options.conflictResolution === "config" ? config.github_sync.conflict_resolution : options.conflictResolution}`));
      console.log("");
      const syncEngine = new GitHubSyncEngine(configManager);
      const spinner = (0, import_ora8.default)("Testing GitHub connection...").start();
      const testResult = await syncEngine.testConnection();
      if (!testResult.success) {
        spinner.fail("GitHub connection failed");
        console.log(Formatter.error(testResult.message));
        process.exit(1);
      }
      spinner.succeed("GitHub connection verified");
      const syncSpinner = (0, import_ora8.default)("Performing bidirectional sync...").start();
      try {
        const result = await syncEngine.bidirectionalSync();
        if (options.dryRun) {
          syncSpinner.succeed("Dry run completed");
          console.log(Formatter.info("Operations that would be performed:"));
        } else {
          syncSpinner.succeed("Bidirectional sync completed");
        }
        console.log("");
        console.log(Formatter.info("Sync Summary:"));
        console.log(`  Pushed: ${result.pushed_count} issues`);
        console.log(`  Pulled: ${result.pulled_count} issues`);
        console.log(`  Skipped: ${result.skipped_count} issues`);
        console.log(`  Conflicts: ${result.conflict_count} issues`);
        console.log(`  Errors: ${result.errors.length}`);
        if (result.success && result.conflict_count === 0) {
          console.log("");
          console.log(Formatter.success("\u2705 Bidirectional sync completed successfully!"));
        } else if (result.success && result.conflict_count > 0) {
          console.log("");
          console.log(Formatter.warning("\u26A0\uFE0F Sync completed with conflicts"));
        } else {
          console.log("");
          console.log(Formatter.error("\u274C Sync completed with errors"));
        }
        if (result.errors.length > 0) {
          console.log("");
          console.log(Formatter.error("Errors encountered:"));
          result.errors.forEach((error) => {
            console.log(`  \u2022 ${error}`);
          });
        }
        if (result.conflicts.length > 0) {
          console.log("");
          console.log(Formatter.warning("Conflicts detected:"));
          result.conflicts.forEach((conflict) => {
            console.log(`  \u2022 ${conflict.local_issue.title} (${conflict.local_issue.issue_id})`);
            console.log(`    Type: ${conflict.type}`);
            console.log(`    Reason: ${conflict.reason}`);
            if (conflict.github_issue) {
              console.log(`    GitHub: #${conflict.github_issue.number} - ${conflict.github_issue.html_url}`);
            }
          });
          if (!options.force) {
            console.log("");
            console.log(Formatter.info("Conflict resolution options:"));
            console.log('  \u2022 Use "aitrackdown sync bidirectional --force" to apply configured resolution strategy');
            console.log('  \u2022 Use "aitrackdown sync push --force" to force push local changes');
            console.log('  \u2022 Use "aitrackdown sync pull --force" to force pull remote changes');
            console.log("  \u2022 Manually resolve conflicts and sync again");
          }
        }
        if (options.verbose) {
          console.log("");
          console.log(Formatter.info("Detailed Operations:"));
          result.operations.forEach((op, index) => {
            var _a2, _b;
            const title = op.local_issue.title || ((_a2 = op.github_issue) == null ? void 0 : _a2.title) || "Unknown";
            const issueId = op.local_issue.issue_id || `#${(_b = op.github_issue) == null ? void 0 : _b.number}`;
            console.log(`  ${index + 1}. ${title} (${issueId})`);
            console.log(`     Type: ${op.type}`);
            console.log(`     Action: ${op.action}`);
            if (op.reason) {
              console.log(`     Reason: ${op.reason}`);
            }
            if (op.github_issue) {
              console.log(`     GitHub: #${op.github_issue.number} - ${op.github_issue.html_url}`);
            }
            if (op.local_issue.file_path) {
              console.log(`     Local: ${op.local_issue.file_path}`);
            }
            console.log("");
          });
        }
        if (result.success) {
          console.log("");
          console.log(Formatter.info("Next steps:"));
          if (result.pulled_count > 0) {
            console.log("  \u2022 Review pulled issues and assign to appropriate epics");
            console.log("  \u2022 Update AI context and token estimates for new issues");
          }
          if (result.pushed_count > 0) {
            console.log("  \u2022 Verify pushed issues appear correctly in GitHub");
            console.log("  \u2022 Check that labels, milestones, and assignees synced properly");
          }
          if (result.conflict_count > 0) {
            console.log("  \u2022 Review and resolve conflicts manually");
            console.log("  \u2022 Consider adjusting conflict resolution strategy");
          }
          if (config.github_sync.auto_sync) {
            console.log("  \u2022 Auto-sync is enabled - future changes will sync automatically");
          } else {
            console.log('  \u2022 Consider enabling auto-sync with "aitrackdown sync auto --enable"');
          }
        }
      } catch (error) {
        syncSpinner.fail("Bidirectional sync failed");
        throw error;
      }
    } catch (error) {
      console.error(Formatter.error("Bidirectional sync failed:"));
      console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
      process.exit(1);
    }
  });
  return command;
}
var import_commander60, import_ora8;
var init_bidirectional = __esm({
  "src/commands/sync/bidirectional.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander60 = require("commander");
    import_ora8 = __toESM(require("ora"), 1);
    init_formatter();
    init_config_manager();
    init_github_sync();
    __name(createSyncBidirectionalCommand, "createSyncBidirectionalCommand");
  }
});

// src/commands/sync.ts
function createSyncCommand2() {
  const command = new import_commander61.Command("sync");
  command.description("GitHub Issues sync management").addCommand(createSyncSetupCommand()).addCommand(createSyncPushCommand()).addCommand(createSyncPullCommand()).addCommand(createSyncStatusCommand()).addCommand(createSyncAutoCommand()).addCommand(createSyncBidirectionalCommand());
  command.action(() => {
    console.log("\u{1F504} GitHub Issues Sync Management");
    console.log("");
    console.log("Available commands:");
    console.log("  setup         Configure GitHub sync for the project");
    console.log("  push          Push local changes to GitHub");
    console.log("  pull          Pull GitHub changes to local");
    console.log("  bidirectional Perform full bidirectional sync");
    console.log("  status        Show sync status and conflicts");
    console.log("  auto          Enable/disable automatic sync");
    console.log("");
    console.log("Examples:");
    console.log("  aitrackdown sync setup --repository owner/repo --token ghp_xxx");
    console.log("  aitrackdown sync push --verbose");
    console.log("  aitrackdown sync pull --dry-run");
    console.log("  aitrackdown sync bidirectional");
    console.log("  aitrackdown sync status --verbose");
    console.log("  aitrackdown sync auto --enable");
    console.log("");
    console.log('Use "aitrackdown sync <command> --help" for more information about a command.');
  });
  return command;
}
var import_commander61;
var init_sync3 = __esm({
  "src/commands/sync.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander61 = require("commander");
    init_setup();
    init_push();
    init_pull();
    init_status2();
    init_auto();
    init_bidirectional();
    __name(createSyncCommand2, "createSyncCommand");
  }
});

// src/commands/migrate.ts
function createMigrateCommand() {
  return new import_commander62.Command("migrate").description("Migrate from legacy trackdown to ai-trackdown structure").option("-d, --dry-run", "Preview migration without making changes").option("-v, --verbose", "Show detailed migration progress").option("-b, --backup", "Create backup before migration").option("--source <dir>", "Source directory to migrate from", process.cwd()).action(async (options) => {
    const migrationTool = new MigrationTool();
    try {
      console.log(import_chalk2.default.bold.blue("AI-Trackdown Migration Tool"));
      console.log(import_chalk2.default.gray("Converting legacy structure to new ai-trackdown format\n"));
      const stats = await migrationTool.migrate(options.source, {
        dryRun: options.dryRun,
        verbose: options.verbose,
        backup: options.backup
      });
      if (options.dryRun) {
        console.log(import_chalk2.default.yellow("\nDry run completed. Use without --dry-run to perform actual migration."));
      }
      process.exit(0);
    } catch (error) {
      console.error(import_chalk2.default.red(`Migration failed: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
}
var fs30, path29, import_chalk2, import_ora9, import_commander62, YAML5, _MigrationTool, MigrationTool;
var init_migrate = __esm({
  "src/commands/migrate.ts"() {
    "use strict";
    init_cjs_shims();
    fs30 = __toESM(require("fs"), 1);
    path29 = __toESM(require("path"), 1);
    import_chalk2 = __toESM(require("chalk"), 1);
    import_ora9 = __toESM(require("ora"), 1);
    import_commander62 = require("commander");
    YAML5 = __toESM(require("yaml"), 1);
    init_frontmatter_parser();
    init_config_manager();
    init_simple_id_generator();
    _MigrationTool = class _MigrationTool {
      frontmatterParser = new FrontmatterParser();
      configManager = new ConfigManager2();
      idGenerator = new IdGenerator();
      stats = {
        configMigrated: false,
        filesProcessed: 0,
        epicsMigrated: 0,
        issuesMigrated: 0,
        tasksMigrated: 0,
        errors: []
      };
      /**
       * Main migration entry point
       */
      async migrate(sourceDir = process.cwd(), options = {}) {
        const spinner = (0, import_ora9.default)("Starting AI-Trackdown migration...").start();
        try {
          if (options.backup) {
            await this.createBackup(sourceDir);
            spinner.text = "Backup created";
          }
          spinner.text = "Migrating configuration...";
          await this.migrateConfiguration(sourceDir, options.dryRun);
          spinner.text = "Creating directory structure...";
          await this.createDirectoryStructure(sourceDir, options.dryRun);
          spinner.text = "Migrating files...";
          await this.migrateFiles(sourceDir, options.dryRun, options.verbose);
          spinner.text = "Cleaning up...";
          await this.cleanupLegacyFiles(sourceDir, options.dryRun);
          spinner.succeed("Migration completed successfully!");
          this.displaySummary();
        } catch (error) {
          spinner.fail(`Migration failed: ${error instanceof Error ? error.message : "Unknown error"}`);
          throw error;
        }
        return this.stats;
      }
      /**
       * Migrate .trackdownrc.json to .ai-trackdown/config.yaml
       */
      async migrateConfiguration(sourceDir, dryRun = false) {
        const legacyConfigPath = path29.join(sourceDir, ".trackdownrc.json");
        if (!fs30.existsSync(legacyConfigPath)) {
          console.log(import_chalk2.default.yellow("No legacy .trackdownrc.json found, creating default config"));
          return;
        }
        try {
          const legacyConfig = JSON.parse(
            fs30.readFileSync(legacyConfigPath, "utf8")
          );
          const newConfig = {
            version: "1.0.0",
            directory_root: legacyConfig.directory_root || ".ai-trackdown",
            defaults: {
              assignee: legacyConfig.default_assignee || "unassigned",
              priority: "medium",
              status: "todo"
            },
            templates: {
              epic: "default",
              issue: "default",
              task: "default"
            },
            integrations: {
              // Note: GitHub integration removed in new architecture
            },
            automation: {
              auto_assign_ids: true,
              auto_update_dates: true,
              auto_track_relationships: true
            }
          };
          if (!dryRun) {
            const configDir = path29.join(sourceDir, ".ai-trackdown");
            if (!fs30.existsSync(configDir)) {
              fs30.mkdirSync(configDir, { recursive: true });
            }
            const newConfigPath = path29.join(configDir, "config.yaml");
            fs30.writeFileSync(newConfigPath, YAML5.stringify(newConfig, { indent: 2 }));
            console.log(import_chalk2.default.green(`\u2713 Configuration migrated to ${newConfigPath}`));
          } else {
            console.log(import_chalk2.default.blue(`[DRY RUN] Would migrate config to .ai-trackdown/config.yaml`));
          }
          this.stats.configMigrated = true;
        } catch (error) {
          const errorMsg = `Failed to migrate configuration: ${error instanceof Error ? error.message : "Unknown error"}`;
          this.stats.errors.push(errorMsg);
          throw new Error(errorMsg);
        }
      }
      /**
       * Create the new directory structure
       */
      async createDirectoryStructure(sourceDir, dryRun = false) {
        const aiTrackdownDir = path29.join(sourceDir, ".ai-trackdown");
        const directories = [
          path29.join(aiTrackdownDir, "epics"),
          path29.join(aiTrackdownDir, "issues"),
          path29.join(aiTrackdownDir, "tasks"),
          path29.join(aiTrackdownDir, "templates")
        ];
        if (!dryRun) {
          for (const dir of directories) {
            if (!fs30.existsSync(dir)) {
              fs30.mkdirSync(dir, { recursive: true });
              console.log(import_chalk2.default.green(`\u2713 Created directory: ${dir}`));
            }
          }
        } else {
          console.log(import_chalk2.default.blue(`[DRY RUN] Would create directories: ${directories.join(", ")}`));
        }
      }
      /**
       * Migrate existing files from legacy structure
       */
      async migrateFiles(sourceDir, dryRun = false, verbose = false) {
        const legacyDirs = [
          path29.join(sourceDir, "active"),
          path29.join(sourceDir, "completed"),
          path29.join(sourceDir, "trackdown")
          // Handle existing trackdown folder
        ];
        for (const legacyDir of legacyDirs) {
          if (fs30.existsSync(legacyDir)) {
            await this.processLegacyDirectory(legacyDir, sourceDir, dryRun, verbose);
          }
        }
      }
      /**
       * Process a legacy directory and migrate its files
       */
      async processLegacyDirectory(legacyDir, sourceDir, dryRun = false, verbose = false) {
        const files = fs30.readdirSync(legacyDir).filter((file) => file.endsWith(".md"));
        for (const file of files) {
          const filePath = path29.join(legacyDir, file);
          try {
            await this.migrateFile(filePath, sourceDir, dryRun, verbose);
            this.stats.filesProcessed++;
          } catch (error) {
            const errorMsg = `Failed to migrate ${filePath}: ${error instanceof Error ? error.message : "Unknown error"}`;
            this.stats.errors.push(errorMsg);
            if (verbose) {
              console.log(import_chalk2.default.red(`\u2717 ${errorMsg}`));
            }
          }
        }
      }
      /**
       * Migrate a single file
       */
      async migrateFile(filePath, sourceDir, dryRun = false, verbose = false) {
        const content = fs30.readFileSync(filePath, "utf8");
        const filename = path29.basename(filePath, ".md");
        const { type, frontmatter, targetPath } = this.analyzeAndPrepareFile(
          filename,
          content,
          sourceDir
        );
        if (!dryRun) {
          const targetDir = path29.dirname(targetPath);
          if (!fs30.existsSync(targetDir)) {
            fs30.mkdirSync(targetDir, { recursive: true });
          }
          let migratedContent;
          switch (type) {
            case "epic":
              migratedContent = this.frontmatterParser.serializeEpic(
                frontmatter,
                this.extractContent(content)
              );
              this.stats.epicsMigrated++;
              break;
            case "issue":
              migratedContent = this.frontmatterParser.serializeIssue(
                frontmatter,
                this.extractContent(content)
              );
              this.stats.issuesMigrated++;
              break;
            case "task":
              migratedContent = this.frontmatterParser.serializeTask(
                frontmatter,
                this.extractContent(content)
              );
              this.stats.tasksMigrated++;
              break;
            default:
              throw new Error(`Unknown file type: ${type}`);
          }
          fs30.writeFileSync(targetPath, migratedContent);
          if (verbose) {
            console.log(import_chalk2.default.green(`\u2713 Migrated ${type}: ${filePath} \u2192 ${targetPath}`));
          }
        } else {
          console.log(import_chalk2.default.blue(`[DRY RUN] Would migrate ${type}: ${filePath} \u2192 ${targetPath}`));
        }
      }
      /**
       * Analyze a file and prepare frontmatter
       */
      analyzeAndPrepareFile(filename, content, sourceDir) {
        const aiTrackdownDir = path29.join(sourceDir, ".ai-trackdown");
        let type;
        let id;
        if (filename.startsWith("EPIC-") || filename.includes("epic")) {
          type = "epic";
          id = this.extractOrGenerateId(filename, "EP");
        } else if (filename.startsWith("ISSUE-") || filename.includes("issue")) {
          type = "issue";
          id = this.extractOrGenerateId(filename, "ISS");
        } else if (filename.startsWith("TASK-") || filename.includes("task") || filename.startsWith("TSK-")) {
          type = "task";
          id = this.extractOrGenerateId(filename, "TSK");
        } else {
          type = "issue";
          id = this.extractOrGenerateId(filename, "ISS");
        }
        const now = (/* @__PURE__ */ new Date()).toISOString();
        const title = this.extractTitle(content) || filename.replace(/-/g, " ");
        const baseFrontmatter = {
          title,
          status: "todo",
          priority: "medium",
          assignee: "unassigned",
          labels: [],
          created_date: now,
          updated_date: now
        };
        let frontmatter;
        let targetPath;
        switch (type) {
          case "epic":
            frontmatter = {
              epic_id: id,
              ...baseFrontmatter,
              story_points: 0,
              completion_percentage: 0
            };
            targetPath = path29.join(aiTrackdownDir, "epics", `${id}.md`);
            break;
          case "issue":
            const epicId = this.findOrCreateDefaultEpic(sourceDir);
            frontmatter = {
              issue_id: id,
              epic_id: epicId,
              ...baseFrontmatter,
              story_points: 1
            };
            targetPath = path29.join(aiTrackdownDir, "issues", `${id}.md`);
            break;
          case "task":
            const taskEpicId = this.findOrCreateDefaultEpic(sourceDir);
            const issueId = this.findOrCreateDefaultIssue(sourceDir, taskEpicId);
            frontmatter = {
              task_id: id,
              issue_id: issueId,
              epic_id: taskEpicId,
              ...baseFrontmatter,
              estimated_hours: 1,
              actual_hours: 0
            };
            targetPath = path29.join(aiTrackdownDir, "tasks", `${id}.md`);
            break;
        }
        return { type, frontmatter, targetPath };
      }
      /**
       * Extract or generate an ID from filename
       */
      extractOrGenerateId(filename, prefix) {
        const patterns = [
          new RegExp(`${prefix}-(\\d{4})`),
          new RegExp(`(${prefix.toLowerCase()}|${prefix})-(\\d+)`, "i"),
          /(\d{4})/
        ];
        for (const pattern of patterns) {
          const match = filename.match(pattern);
          if (match) {
            const num = match[1] || match[2];
            return `${prefix}-${num.padStart(4, "0")}`;
          }
        }
        switch (prefix) {
          case "EP":
            return this.idGenerator.generateEpicId("migrated");
          case "ISS":
            return this.idGenerator.generateIssueId("EP-0001", "migrated");
          case "TSK":
            return this.idGenerator.generateTaskId("ISS-0001", "migrated");
          default:
            return `${prefix}-0001`;
        }
      }
      /**
       * Extract title from content
       */
      extractTitle(content) {
        const titleMatch = content.match(/^#\s+(.+)$/m);
        if (titleMatch) {
          return titleMatch[1].trim();
        }
        const lines = content.split("\n").map((line) => line.trim()).filter((line) => line);
        if (lines.length > 0) {
          return lines[0].replace(/^#+\s*/, "");
        }
        return null;
      }
      /**
       * Extract content without title
       */
      extractContent(content) {
        var _a;
        const lines = content.split("\n");
        if ((_a = lines[0]) == null ? void 0 : _a.trim().startsWith("# ")) {
          return lines.slice(1).join("\n").trim();
        }
        return content.trim();
      }
      /**
       * Find or create default epic for migration
       */
      findOrCreateDefaultEpic(sourceDir) {
        return "EP-0001";
      }
      /**
       * Find or create default issue for migration
       */
      findOrCreateDefaultIssue(sourceDir, epicId) {
        return "ISS-0001";
      }
      /**
       * Create backup of source directory
       */
      async createBackup(sourceDir) {
        const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
        const backupDir = path29.join(sourceDir, `backup-${timestamp}`);
        this.copyDirectory(sourceDir, backupDir, [
          "node_modules",
          ".git",
          "backup-*"
        ]);
        console.log(import_chalk2.default.green(`\u2713 Backup created at ${backupDir}`));
      }
      /**
       * Copy directory recursively
       */
      copyDirectory(src, dest, exclude = []) {
        if (!fs30.existsSync(dest)) {
          fs30.mkdirSync(dest, { recursive: true });
        }
        const items = fs30.readdirSync(src);
        for (const item of items) {
          const srcPath = path29.join(src, item);
          const destPath = path29.join(dest, item);
          if (exclude.some((pattern) => item.match(new RegExp(pattern)))) {
            continue;
          }
          const stat3 = fs30.statSync(srcPath);
          if (stat3.isDirectory()) {
            this.copyDirectory(srcPath, destPath, exclude);
          } else {
            fs30.copyFileSync(srcPath, destPath);
          }
        }
      }
      /**
       * Cleanup legacy files after successful migration
       */
      async cleanupLegacyFiles(sourceDir, dryRun = false) {
        const legacyFiles = [
          path29.join(sourceDir, ".trackdownrc.json")
        ];
        const legacyDirs = [
          path29.join(sourceDir, "active"),
          path29.join(sourceDir, "completed")
        ];
        if (!dryRun) {
          for (const file of legacyFiles) {
            if (fs30.existsSync(file)) {
              fs30.unlinkSync(file);
              console.log(import_chalk2.default.green(`\u2713 Removed legacy file: ${file}`));
            }
          }
          for (const dir of legacyDirs) {
            if (fs30.existsSync(dir)) {
              const archiveDir = path29.join(sourceDir, `${path29.basename(dir)}-legacy`);
              fs30.renameSync(dir, archiveDir);
              console.log(import_chalk2.default.green(`\u2713 Archived legacy directory: ${dir} \u2192 ${archiveDir}`));
            }
          }
        } else {
          console.log(import_chalk2.default.blue(`[DRY RUN] Would cleanup legacy files and directories`));
        }
      }
      /**
       * Display migration summary
       */
      displaySummary() {
        console.log("\n" + import_chalk2.default.bold.green("Migration Summary:"));
        console.log(import_chalk2.default.green(`\u2713 Configuration migrated: ${this.stats.configMigrated}`));
        console.log(import_chalk2.default.green(`\u2713 Files processed: ${this.stats.filesProcessed}`));
        console.log(import_chalk2.default.green(`\u2713 Epics migrated: ${this.stats.epicsMigrated}`));
        console.log(import_chalk2.default.green(`\u2713 Issues migrated: ${this.stats.issuesMigrated}`));
        console.log(import_chalk2.default.green(`\u2713 Tasks migrated: ${this.stats.tasksMigrated}`));
        if (this.stats.errors.length > 0) {
          console.log(import_chalk2.default.red(`\u2717 Errors encountered: ${this.stats.errors.length}`));
          this.stats.errors.forEach((error) => {
            console.log(import_chalk2.default.red(`  - ${error}`));
          });
        }
        console.log("\n" + import_chalk2.default.bold.blue("Next Steps:"));
        console.log("1. Review migrated files in .ai-trackdown/ directory");
        console.log("2. Update .ai-trackdown/config.yaml as needed");
        console.log("3. Test the new system with: aitrackdown status");
        console.log("4. Archive or remove legacy files when satisfied");
      }
    };
    __name(_MigrationTool, "MigrationTool");
    MigrationTool = _MigrationTool;
    __name(createMigrateCommand, "createMigrateCommand");
  }
});

// src/commands/migrate-structure.ts
function createMigrateStructureCommand() {
  const cmd = new import_commander63.Command("migrate-structure");
  cmd.description("Migrate from separate root directories to unified structure").option("--dry-run", "show what would be migrated without making changes").option("--backup", "create backup before migration").option("--verbose", "verbose output").option("--force", "force migration even if target directories exist").option("--tasks-dir <path>", 'target tasks directory (default: from config or "tasks")').addHelpText("after", `
Examples:
  $ aitrackdown migrate-structure --dry-run
  $ aitrackdown migrate-structure --backup --verbose
  $ aitrackdown migrate-structure --tasks-dir work

Migration Process:
  1. Detects legacy directory structure (epics/, issues/, tasks/ at root)
  2. Creates unified structure under configurable root (default: tasks/)
  3. Moves files to new structure: epics/ -> tasks/epics/
  4. Updates configuration if needed
  5. Optionally creates backup of original structure

Before Migration:
  project/
  \u251C\u2500\u2500 epics/           # \u274C Separate root directory
  \u251C\u2500\u2500 issues/          # \u274C Separate root directory
  \u2514\u2500\u2500 tasks/           # \u274C Separate root directory

After Migration:
  project/
  \u2514\u2500\u2500 tasks/           # \u2705 Single configurable root
      \u251C\u2500\u2500 epics/
      \u251C\u2500\u2500 issues/
      \u251C\u2500\u2500 tasks/
      \u251C\u2500\u2500 prs/
      \u2514\u2500\u2500 templates/
`).action(async (options) => {
    try {
      await migrateStructure(options);
    } catch (error) {
      console.error(Formatter.error(`Migration failed: ${error instanceof Error ? error.message : "Unknown error"}`));
      process.exit(1);
    }
  });
  return cmd;
}
async function migrateStructure(options) {
  const projectRoot = process.cwd();
  try {
    const configManager = new ConfigManager2(projectRoot);
    if (!configManager.isProjectDirectory(projectRoot)) {
      throw new Error('Not an AI-Trackdown project. Run "aitrackdown init" first.');
    }
    const config = configManager.getConfig();
    const cliTasksDir = options.tasksDir || process.env.CLI_TASKS_DIR;
    const pathResolver = new UnifiedPathResolver(config, projectRoot, cliTasksDir);
    const legacy = pathResolver.detectLegacyStructure();
    if (!legacy.hasLegacy) {
      console.log(Formatter.success("\u2705 No legacy directory structure detected. Project already uses unified structure."));
      pathResolver.showStructureInfo();
      return;
    }
    console.log(Formatter.warning("\u{1F50D} Legacy directory structure detected:"));
    legacy.legacyDirs.forEach((dir) => {
      console.log(Formatter.info(`   \u2022 ${path30.relative(projectRoot, dir)}`));
    });
    const targetPaths = pathResolver.getUnifiedPaths();
    const targetTasksRoot = path30.relative(projectRoot, targetPaths.tasksRoot);
    console.log(Formatter.info(`
\u{1F4CB} Migration Plan:`));
    console.log(Formatter.info(`   Target structure: ${targetTasksRoot}/`));
    const migrationPlan = planMigration(projectRoot, legacy.legacyDirs, pathResolver);
    if (migrationPlan.length === 0) {
      console.log(Formatter.warning("No files to migrate."));
      return;
    }
    console.log(Formatter.info(`
\u{1F4C1} Files to migrate: ${migrationPlan.length}`));
    if (options.verbose || options.dryRun) {
      migrationPlan.forEach((item) => {
        const sourcePath = path30.relative(projectRoot, item.source);
        const targetPath = path30.relative(projectRoot, item.target);
        console.log(Formatter.debug(`   ${sourcePath} \u2192 ${targetPath}`));
      });
    }
    if (options.dryRun) {
      console.log(Formatter.info("\n\u{1F50D} Dry run completed. Use without --dry-run to perform migration."));
      return;
    }
    const conflicts = migrationPlan.filter((item) => fs31.existsSync(item.target));
    if (conflicts.length > 0 && !options.force) {
      console.log(Formatter.error("\n\u274C Migration conflicts detected:"));
      conflicts.forEach((item) => {
        const targetPath = path30.relative(projectRoot, item.target);
        console.log(Formatter.error(`   Target exists: ${targetPath}`));
      });
      console.log(Formatter.info("\n\u{1F4A1} Use --force to overwrite existing files or --backup to create backups first."));
      return;
    }
    if (options.backup) {
      await createBackup(projectRoot, legacy.legacyDirs);
    }
    console.log(Formatter.info("\n\u{1F680} Starting migration..."));
    await createTargetDirectories(pathResolver);
    let migratedCount = 0;
    for (const item of migrationPlan) {
      try {
        const targetDir = path30.dirname(item.target);
        if (!fs31.existsSync(targetDir)) {
          fs31.mkdirSync(targetDir, { recursive: true });
        }
        fs31.renameSync(item.source, item.target);
        migratedCount++;
        if (options.verbose) {
          const sourcePath = path30.relative(projectRoot, item.source);
          const targetPath = path30.relative(projectRoot, item.target);
          console.log(Formatter.success(`   \u2713 ${sourcePath} \u2192 ${targetPath}`));
        }
      } catch (error) {
        console.error(Formatter.error(`Failed to migrate ${item.source}: ${error instanceof Error ? error.message : "Unknown error"}`));
      }
    }
    await removeEmptyLegacyDirectories(legacy.legacyDirs);
    if (cliTasksDir && cliTasksDir !== config.tasks_directory) {
      configManager.updateConfig({ tasks_directory: cliTasksDir });
      console.log(Formatter.success(`\u2705 Updated configuration: tasks_directory = "${cliTasksDir}"`));
    }
    console.log(Formatter.success(`
\u{1F389} Migration completed successfully!`));
    console.log(Formatter.info(`   Files migrated: ${migratedCount}`));
    console.log(Formatter.info(`   Target structure: ${targetTasksRoot}/`));
    console.log(Formatter.info("\n\u{1F4C1} Final directory structure:"));
    pathResolver.showStructureInfo();
  } catch (error) {
    throw new Error(`Migration failed: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
function planMigration(projectRoot, legacyDirs, pathResolver) {
  const plan = [];
  const targetPaths = pathResolver.getUnifiedPaths();
  for (const legacyDir of legacyDirs) {
    if (!fs31.existsSync(legacyDir)) continue;
    const dirName = path30.basename(legacyDir);
    let targetDir;
    switch (dirName) {
      case "epics":
        targetDir = targetPaths.epicsDir;
        break;
      case "issues":
        targetDir = targetPaths.issuesDir;
        break;
      case "tasks":
        targetDir = targetPaths.tasksDir;
        break;
      case "templates":
        targetDir = targetPaths.templatesDir;
        break;
      case "trackdown":
        const subdirs = fs31.readdirSync(legacyDir, { withFileTypes: true }).filter((dirent) => dirent.isDirectory()).map((dirent) => dirent.name);
        for (const subdir of subdirs) {
          const sourceSubdir = path30.join(legacyDir, subdir);
          let targetSubdir;
          switch (subdir) {
            case "active":
            case "epics":
              targetSubdir = targetPaths.epicsDir;
              break;
            case "issues":
              targetSubdir = targetPaths.issuesDir;
              break;
            case "tasks":
              targetSubdir = targetPaths.tasksDir;
              break;
            case "templates":
              targetSubdir = targetPaths.templatesDir;
              break;
            default:
              continue;
          }
          if (fs31.existsSync(sourceSubdir)) {
            const files = fs31.readdirSync(sourceSubdir).filter((file) => file.endsWith(".md") || file.endsWith(".yaml"));
            for (const file of files) {
              plan.push({
                source: path30.join(sourceSubdir, file),
                target: path30.join(targetSubdir, file),
                type: subdir
              });
            }
          }
        }
        continue;
      default:
        continue;
    }
    if (fs31.existsSync(legacyDir)) {
      const files = fs31.readdirSync(legacyDir).filter((file) => file.endsWith(".md") || file.endsWith(".yaml"));
      for (const file of files) {
        plan.push({
          source: path30.join(legacyDir, file),
          target: path30.join(targetDir, file),
          type: dirName
        });
      }
    }
  }
  return plan;
}
async function createTargetDirectories(pathResolver) {
  const requiredDirs = pathResolver.getRequiredDirectories();
  for (const dir of requiredDirs) {
    if (!fs31.existsSync(dir)) {
      fs31.mkdirSync(dir, { recursive: true });
    }
  }
}
async function createBackup(projectRoot, legacyDirs) {
  const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  const backupDir = path30.join(projectRoot, `.backup-${timestamp}`);
  console.log(Formatter.info(`\u{1F4E6} Creating backup in ${path30.relative(projectRoot, backupDir)}...`));
  fs31.mkdirSync(backupDir, { recursive: true });
  for (const legacyDir of legacyDirs) {
    if (fs31.existsSync(legacyDir)) {
      const targetBackupDir = path30.join(backupDir, path30.basename(legacyDir));
      await copyDirectory(legacyDir, targetBackupDir);
    }
  }
  console.log(Formatter.success(`\u2705 Backup created: ${path30.relative(projectRoot, backupDir)}`));
}
async function copyDirectory(source, target) {
  if (!fs31.existsSync(target)) {
    fs31.mkdirSync(target, { recursive: true });
  }
  const items = fs31.readdirSync(source, { withFileTypes: true });
  for (const item of items) {
    const sourcePath = path30.join(source, item.name);
    const targetPath = path30.join(target, item.name);
    if (item.isDirectory()) {
      await copyDirectory(sourcePath, targetPath);
    } else {
      fs31.copyFileSync(sourcePath, targetPath);
    }
  }
}
async function removeEmptyLegacyDirectories(legacyDirs) {
  for (const dir of legacyDirs) {
    try {
      if (fs31.existsSync(dir)) {
        const items = fs31.readdirSync(dir);
        if (items.length === 0) {
          fs31.rmdirSync(dir);
          console.log(Formatter.success(`\u2705 Removed empty directory: ${path30.basename(dir)}`));
        }
      }
    } catch (error) {
    }
  }
}
var import_commander63, fs31, path30;
var init_migrate_structure = __esm({
  "src/commands/migrate-structure.ts"() {
    "use strict";
    init_cjs_shims();
    import_commander63 = require("commander");
    fs31 = __toESM(require("fs"), 1);
    path30 = __toESM(require("path"), 1);
    init_config_manager();
    init_unified_path_resolver();
    init_formatter();
    __name(createMigrateStructureCommand, "createMigrateStructureCommand");
    __name(migrateStructure, "migrateStructure");
    __name(planMigration, "planMigration");
    __name(createTargetDirectories, "createTargetDirectories");
    __name(createBackup, "createBackup");
    __name(copyDirectory, "copyDirectory");
    __name(removeEmptyLegacyDirectories, "removeEmptyLegacyDirectories");
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  main: () => main
});
function getVersion() {
  try {
    return VersionManager.getVersion().version;
  } catch (error) {
    console.warn("Warning: Could not read VERSION file, using fallback version");
    return "1.0.1";
  }
}
async function main() {
  const program = new import_commander64.Command();
  program.name("aitrackdown").description(packageInfo.description).version(packageInfo.version, "-v, --version", "display version number").helpOption("-h, --help", "display help for command");
  program.option("--verbose", "enable verbose output").option("--config <path>", "path to config file").option("--no-color", "disable colored output").option("--root-dir <path>", "root directory for trackdown files (default: tasks/)").option("--tasks-dir <path>", "alias for --root-dir").option("--project-dir <path>", "target project directory for anywhere-submit functionality");
  program.hook("preAction", (thisCommand) => {
    const opts = program.opts();
    if (opts.noColor) {
      process.env.FORCE_COLOR = "0";
    }
    if (opts.projectDir) {
      process.env.CLI_PROJECT_DIR = opts.projectDir;
      try {
        process.chdir(opts.projectDir);
      } catch (error) {
        console.error(Formatter.error(`Failed to change to project directory: ${opts.projectDir}`));
        console.error(Formatter.error(error instanceof Error ? error.message : "Unknown error"));
        process.exit(1);
      }
    }
    const tasksDir = opts.tasksDir || opts.rootDir;
    if (tasksDir) {
      process.env.CLI_TASKS_DIR = tasksDir;
    }
    if (opts.verbose) {
      console.log(Formatter.debug(`Running command: ${thisCommand.name()}`));
      console.log(Formatter.debug(`Arguments: ${JSON.stringify(thisCommand.args)}`));
      console.log(Formatter.debug(`Options: ${JSON.stringify(thisCommand.opts())}`));
      if (opts.projectDir) {
        console.log(Formatter.debug(`Project directory: ${opts.projectDir}`));
      }
      if (tasksDir) {
        console.log(Formatter.debug(`Tasks directory override: ${tasksDir}`));
      }
    }
  });
  program.addCommand(createInitCommand());
  program.addCommand(createTrackCommand());
  program.addCommand(createStatusCommand());
  program.addCommand(createStatusEnhancedCommand());
  program.addCommand(createBacklogCommand());
  program.addCommand(createBacklogEnhancedCommand());
  program.addCommand(createPortfolioCommand());
  program.addCommand(createExportCommand());
  program.addCommand(createVersionCommand());
  program.addCommand(createEpicCommand());
  program.addCommand(createIssueCommand());
  program.addCommand(createTaskCommand());
  program.addCommand(createPRCommand());
  program.addCommand(createAiCommand());
  program.addCommand(createSyncCommand2());
  program.addCommand(createMigrateCommand());
  program.addCommand(createMigrateStructureCommand());
  program.command("atd").alias("aitrackdown").description("alias for aitrackdown command").action(() => {
    console.log(Formatter.info('Use "aitrackdown --help" to see available commands'));
  });
  program.on("command:*", (operands) => {
    console.error(Formatter.error(`Unknown command: ${operands[0]}`));
    console.log(Formatter.info('Run "aitrackdown --help" to see available commands'));
    process.exit(1);
  });
  program.on("--help", () => {
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F680} AI-Trackdown CLI - Comprehensive Project Management Tool"));
    console.log("");
    console.log(import_chalk3.default.bold.yellow("\u{1F4CB} HIERARCHICAL STRUCTURE:"));
    console.log("  Epics \u2192 Issues \u2192 Tasks \u2192 PRs (Pull Requests)");
    console.log("  Each level tracks tokens, progress, and relationships");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F3D7}\uFE0F HIERARCHICAL COMMANDS:"));
    console.log("  Epic Management:");
    console.log('    $ aitrackdown epic create "User Authentication System"');
    console.log("    $ aitrackdown epic list --status active --show-progress");
    console.log("    $ aitrackdown epic show EP-0001 --with-issues");
    console.log("    $ aitrackdown epic complete EP-0001 --actual-tokens 1500");
    console.log("");
    console.log("  Issue Management:");
    console.log('    $ aitrackdown issue create "Implement login form" --epic EP-0001');
    console.log("    $ aitrackdown issue list --epic EP-0001 --status active");
    console.log("    $ aitrackdown issue complete ISS-0001 --actual-tokens 500");
    console.log("    $ aitrackdown issue assign ISS-0001 --assignee john");
    console.log("");
    console.log("  Task Management:");
    console.log('    $ aitrackdown task create "Create login UI" --issue ISS-0001');
    console.log("    $ aitrackdown task list --issue ISS-0001 --assignee john");
    console.log("    $ aitrackdown task complete TSK-0001 --time-spent 2h");
    console.log("    $ aitrackdown task update TSK-0001 --status active");
    console.log("");
    console.log("  PR Management:");
    console.log('    $ aitrackdown pr create "Add login functionality" --issue ISS-0001');
    console.log("    $ aitrackdown pr list --status open --assignee john");
    console.log("    $ aitrackdown pr merge PR-0001 --delete-branch");
    console.log('    $ aitrackdown pr review PR-0001 --approve --comment "LGTM"');
    console.log("");
    console.log("  GitHub Sync:");
    console.log("    $ aitrackdown sync setup --repository owner/repo --token ghp_xxx");
    console.log("    $ aitrackdown sync push --verbose");
    console.log("    $ aitrackdown sync pull --dry-run");
    console.log("    $ aitrackdown sync bidirectional");
    console.log("    $ aitrackdown sync status --verbose");
    console.log("    $ aitrackdown sync auto --enable");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F916} AI-SPECIFIC COMMANDS:"));
    console.log("  Token Tracking:");
    console.log("    $ aitrackdown ai track-tokens --report");
    console.log("    $ aitrackdown ai generate-llms-txt --format detailed");
    console.log('    $ aitrackdown ai context --item-id EP-0001 --add "context/requirements"');
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F3AF} ANYWHERE-SUBMIT FUNCTIONALITY:"));
    console.log("  Work with any project from anywhere:");
    console.log('    $ aitrackdown issue create "Fix bug" --project-dir ~/Projects/my-app');
    console.log("    $ aitrackdown task list --project-dir ~/Projects/managed/ai-power-rankings");
    console.log("    $ aitrackdown status --project-dir ~/Projects/another-project");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u2699\uFE0F CORE PROJECT COMMANDS:"));
    console.log("  Project Setup:");
    console.log("    $ aitrackdown init my-project");
    console.log("    $ aitrackdown status --verbose");
    console.log("    $ aitrackdown status --full");
    console.log("");
    console.log("  Data Management:");
    console.log("    $ aitrackdown backlog --with-issues");
    console.log("    $ aitrackdown portfolio --health");
    console.log("    $ aitrackdown export --format json");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F504} MIGRATION COMMANDS:"));
    console.log("  Legacy to Modern Structure:");
    console.log("    $ aitrackdown migrate --dry-run --verbose");
    console.log("    $ aitrackdown migrate --backup");
    console.log("    $ aitrackdown migrate-structure --dry-run");
    console.log("    $ aitrackdown migrate-structure --tasks-dir work");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u26A1 ALIASES & SHORTCUTS:"));
    console.log("  atd = aitrackdown (shorter command)");
    console.log("  issue = issues, task = tasks, pr = prs");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F527} GLOBAL OPTIONS:"));
    console.log("  --project-dir <path>    Target project directory (anywhere-submit)");
    console.log("  --root-dir <path>       Root directory for trackdown files");
    console.log("  --tasks-dir <path>      Alias for --root-dir");
    console.log("  --verbose               Enable verbose output");
    console.log("  --no-color              Disable colored output");
    console.log("  --config <path>         Path to config file");
    console.log("");
    console.log(import_chalk3.default.bold.cyan("\u{1F4D6} LEARN MORE:"));
    console.log("  Documentation: https://github.com/bobmatnyc/ai-trackdown-tools");
    console.log("  Issues: https://github.com/bobmatnyc/ai-trackdown-tools/issues");
    console.log("  Version: " + packageInfo.version);
  });
  process.on("uncaughtException", (error) => {
    console.error(Formatter.error(`Uncaught exception: ${error.message}`));
    if (program.opts().verbose) {
      console.error(error.stack);
    }
    process.exit(1);
  });
  process.on("unhandledRejection", (reason) => {
    console.error(Formatter.error(`Unhandled rejection: ${reason}`));
    if (program.opts().verbose && reason instanceof Error) {
      console.error(reason.stack);
    }
    process.exit(1);
  });
  try {
    await program.parseAsync(process.argv);
  } catch (error) {
    console.error(
      Formatter.error(`Command failed: ${error instanceof Error ? error.message : "Unknown error"}`)
    );
    if (error instanceof Error) {
      if (error.message.includes("EACCES")) {
        console.log(Formatter.info("Permission denied. Try running with appropriate permissions."));
      } else if (error.message.includes("ENOENT")) {
        console.log(Formatter.info("File or directory not found. Check the path and try again."));
      } else if (error.message.includes("EEXIST")) {
        console.log(Formatter.info("File or directory already exists. Use --force to overwrite."));
      } else if (program.opts().verbose) {
        console.error(error.stack);
      }
    }
    process.exit(1);
  }
}
var import_chalk3, import_commander64, packageInfo;
var init_src = __esm({
  "src/index.ts"() {
    "use strict";
    init_cjs_shims();
    import_chalk3 = __toESM(require("chalk"), 1);
    import_commander64 = require("commander");
    init_export();
    init_init();
    init_status();
    init_status_enhanced();
    init_backlog();
    init_backlog_enhanced();
    init_portfolio();
    init_track();
    init_version2();
    init_epic();
    init_issue();
    init_task();
    init_pr();
    init_ai();
    init_sync3();
    init_migrate();
    init_migrate_structure();
    init_version();
    init_formatter();
    __name(getVersion, "getVersion");
    packageInfo = {
      name: "ai-trackdown-tools",
      version: getVersion(),
      description: "Professional CLI tool for ai-trackdown functionality"
    };
    __name(main, "main");
  }
});

// src/cli.ts
init_cjs_shims();
async function runCLI() {
  try {
    const { main: main2 } = await Promise.resolve().then(() => (init_src(), src_exports));
    await main2();
  } catch (error) {
    console.error("CLI Error:", error instanceof Error ? error.message : String(error));
    if (process.env.DEBUG) {
      console.error(error instanceof Error ? error.stack : error);
    }
    process.exit(1);
  }
}
__name(runCLI, "runCLI");
runCLI();
//# sourceMappingURL=index.cjs.map