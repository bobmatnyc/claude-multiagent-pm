#!/usr/bin/env node

/**
 * Claude Multi-Agent PM Framework - Universal CLI Entry Point
 * 
 * This is the main entry point for the claude-pm command-line interface.
 * It provides universal access to the Claude PM Framework regardless of
 * installation location or platform.
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawn } = require('child_process');

// Universal version resolution for all deployment scenarios
function resolveVersion() {
    const fs = require('fs');
    const path = require('path');
    
    // Strategy 1: Try to find package.json relative to this script
    // Works for: source, npm global, npm local, deployed scenarios
    const packagePaths = [
        path.join(__dirname, '../package.json'),  // From bin/ directory (source, npm)
        path.join(__dirname, '../../package.json'), // One level up if needed
        path.join(__dirname, '../../../package.json') // Two levels up for deep npm installs
    ];
    
    for (const packagePath of packagePaths) {
        try {
            if (fs.existsSync(packagePath)) {
                const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                if (pkg.name === '@bobmatnyc/claude-multiagent-pm' && pkg.version) {
                    return pkg.version;
                }
            }
        } catch (e) {
            // Continue to next path
        }
    }
    
    // Strategy 2: Try VERSION file (source development scenario)
    const versionPaths = [
        path.join(__dirname, '../VERSION'),  // From bin/ directory (source)
        path.join(__dirname, '../../VERSION') // One level up
    ];
    
    for (const versionPath of versionPaths) {
        try {
            if (fs.existsSync(versionPath)) {
                return fs.readFileSync(versionPath, 'utf8').trim();
            }
        } catch (e) {
            // Continue to next path
        }
    }
    
    // Strategy 3: Check for NPM package in node_modules (new prioritized strategy)
    try {
        const nodeModulesPaths = [
            path.join(process.cwd(), 'node_modules', '@bobmatnyc', 'claude-multiagent-pm', 'package.json'),
            path.join(process.cwd(), '..', 'node_modules', '@bobmatnyc', 'claude-multiagent-pm', 'package.json'),
            path.join(require.resolve('@bobmatnyc/claude-multiagent-pm/package.json'))
        ];
        
        for (const npmPackagePath of nodeModulesPaths) {
            if (fs.existsSync(npmPackagePath)) {
                const pkg = JSON.parse(fs.readFileSync(npmPackagePath, 'utf8'));
                if (pkg.name === '@bobmatnyc/claude-multiagent-pm' && pkg.version) {
                    return pkg.version;
                }
            }
        }
    } catch (e) {
        // Continue to fallback
    }
    
    // Strategy 4: Use npm to resolve package version (if available)
    try {
        const { execSync } = require('child_process');
        const result = execSync('npm list @bobmatnyc/claude-multiagent-pm --depth=0 --json', { 
            encoding: 'utf8', 
            stdio: 'pipe',
            timeout: 5000 
        });
        const npmData = JSON.parse(result);
        if (npmData.dependencies && npmData.dependencies['@bobmatnyc/claude-multiagent-pm']) {
            return npmData.dependencies['@bobmatnyc/claude-multiagent-pm'].version;
        }
    } catch (e) {
        // npm command failed, continue
    }
    
    // If all strategies fail, throw error with helpful message
    throw new Error(
        'Could not resolve Claude PM Framework version. ' +
        'This may indicate a corrupted installation or unsupported deployment scenario. ' +
        'Please reinstall using: npm install -g @bobmatnyc/claude-multiagent-pm'
    );
}

const CLAUDE_PM_VERSION = resolveVersion();

/**
 * Claude PM Framework Deployment Detection System
 * 
 * Provides comprehensive detection and resolution of all deployment scenarios
 * including local source, npm global, npx, npm local, and deployed instances.
 */
class DeploymentDetector {
    constructor() {
        this.platform = os.platform();
        this.detectionResults = null;
        this.detectionCache = new Map();
        this.maxCacheSize = 10; // Limit cache size to prevent memory growth
        this.cacheCleanupTimer = null;
        this._setupMemoryCleanup();
    }

    /**
     * Setup automatic memory cleanup to prevent memory leaks
     */
    _setupMemoryCleanup() {
        // Clear cache periodically to prevent memory accumulation
        this.cacheCleanupTimer = setInterval(() => {
            if (this.detectionCache.size > this.maxCacheSize) {
                // Keep only the most recent entries
                const entries = Array.from(this.detectionCache.entries());
                const keepEntries = entries.slice(-this.maxCacheSize);
                this.detectionCache.clear();
                keepEntries.forEach(([key, value]) => {
                    this.detectionCache.set(key, value);
                });
            }
        }, 30000); // Clean up every 30 seconds

        // Cleanup on process exit
        process.on('exit', () => {
            this.cleanup();
        });
        process.on('SIGINT', () => {
            this.cleanup();
            process.exit(0);
        });
        process.on('SIGTERM', () => {
            this.cleanup();
            process.exit(0);
        });
    }

    /**
     * Clean up resources to prevent memory leaks
     */
    cleanup() {
        if (this.cacheCleanupTimer) {
            clearInterval(this.cacheCleanupTimer);
            this.cacheCleanupTimer = null;
        }
        this.detectionCache.clear();
        this.detectionResults = null;
    }

    /**
     * Detect deployment type and return configuration
     */
    detectDeployment() {
        // Check cache first
        const cacheKey = `${process.cwd()}_${__dirname}`;
        if (this.detectionCache.has(cacheKey)) {
            return this.detectionCache.get(cacheKey);
        }

        const deploymentConfig = this._performDetection();
        this.detectionCache.set(cacheKey, deploymentConfig);
        return deploymentConfig;
    }

    /**
     * Perform deployment detection logic
     */
    _performDetection() {
        // Strategy 1: NPM local installation (node_modules) - Prioritize over deployed instances
        const npmLocalResult = this._detectNpmLocal();
        if (npmLocalResult.found) {
            return this._buildConfig('npm_local', npmLocalResult);
        }

        // Strategy 2: NPM global installation
        const npmGlobalResult = this._detectNpmGlobal();
        if (npmGlobalResult.found) {
            return this._buildConfig('npm_global', npmGlobalResult);
        }

        // Strategy 3: NPX execution
        const npxResult = this._detectNpxExecution();
        if (npxResult.found) {
            return this._buildConfig('npx', npxResult);
        }

        // Strategy 4: Local source development (bin/claude-pm in source repo)
        const localSourceResult = this._detectLocalSource();
        if (localSourceResult.found) {
            return this._buildConfig('local_source', localSourceResult);
        }

        // Strategy 5: Deployed instance (from install/deploy.js) - Lower priority than NPM
        const deployedResult = this._detectDeployedInstance();
        if (deployedResult.found) {
            return this._buildConfig('deployed', deployedResult);
        }

        // Strategy 6: Environment-based detection
        const envResult = this._detectEnvironmentBased();
        if (envResult.found) {
            return this._buildConfig('environment', envResult);
        }

        // Strategy 7: Fallback detection
        const fallbackResult = this._detectFallback();
        if (fallbackResult.found) {
            return this._buildConfig('fallback', fallbackResult);
        }

        // No valid deployment found
        return this._buildConfig('not_found', { found: false, error: 'No valid Claude PM Framework deployment found' });
    }

    /**
     * Detect local source development scenario
     */
    _detectLocalSource() {
        try {
            // Check if we're in the source repository
            const sourceRoot = path.join(__dirname, '..');
            const claudePmPath = path.join(sourceRoot, 'claude_pm');
            const packageJsonPath = path.join(sourceRoot, 'package.json');
            
            if (fs.existsSync(claudePmPath) && fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                if (packageJson.name === '@bobmatnyc/claude-multiagent-pm') {
                    return {
                        found: true,
                        frameworkPath: sourceRoot,
                        claudePmPath: claudePmPath,
                        packageJson: packageJson,
                        confidence: 'high'
                    };
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect NPM global installation
     */
    _detectNpmGlobal() {
        try {
            const { execSync } = require('child_process');
            
            // Try to find global installation
            const globalPath = execSync('npm root -g', { encoding: 'utf8' }).trim();
            const globalClaudePm = path.join(globalPath, '@bobmatnyc', 'claude-multiagent-pm');
            const globalFrameworkPath = path.join(globalClaudePm, 'claude_pm');
            
            if (fs.existsSync(globalFrameworkPath)) {
                return {
                    found: true,
                    frameworkPath: globalClaudePm,
                    claudePmPath: globalFrameworkPath,
                    globalPath: globalPath,
                    confidence: 'high'
                };
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect NPX execution scenario
     */
    _detectNpxExecution() {
        try {
            // Check if we're running via npx
            const npxCache = process.env.npm_config_cache;
            const npxPrefix = process.env.npm_config_prefix;
            
            if (npxCache && (process.env.npm_execpath || process.env.npm_command)) {
                // Look for claude-pm in npx cache
                const npxCachePath = path.join(npxCache, '_npx');
                if (fs.existsSync(npxCachePath)) {
                    // Find the most recent claude-pm installation
                    const claudePmDirs = fs.readdirSync(npxCachePath)
                        .filter(dir => dir.includes('claude-multiagent-pm'))
                        .sort()
                        .reverse();
                    
                    if (claudePmDirs.length > 0) {
                        const latestDir = claudePmDirs[0];
                        const npxFrameworkPath = path.join(npxCachePath, latestDir, 'node_modules', '@bobmatnyc', 'claude-multiagent-pm');
                        const npxClaudePmPath = path.join(npxFrameworkPath, 'claude_pm');
                        
                        if (fs.existsSync(npxClaudePmPath)) {
                            return {
                                found: true,
                                frameworkPath: npxFrameworkPath,
                                claudePmPath: npxClaudePmPath,
                                npxCachePath: npxCachePath,
                                confidence: 'medium'
                            };
                        }
                    }
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect NPM local installation
     */
    _detectNpmLocal() {
        try {
            // Check current directory and parents for node_modules
            let currentDir = process.cwd();
            
            while (currentDir !== path.dirname(currentDir)) {
                const nodeModulesPath = path.join(currentDir, 'node_modules', '@bobmatnyc', 'claude-multiagent-pm');
                const localClaudePmPath = path.join(nodeModulesPath, 'claude_pm');
                
                if (fs.existsSync(localClaudePmPath)) {
                    return {
                        found: true,
                        frameworkPath: nodeModulesPath,
                        claudePmPath: localClaudePmPath,
                        projectRoot: currentDir,
                        confidence: 'medium'
                    };
                }
                
                currentDir = path.dirname(currentDir);
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect deployed instance (from install/deploy.js)
     */
    _detectDeployedInstance() {
        try {
            // Check standard deployment locations first
            const deploymentLocations = [
                path.join(os.homedir(), '.local'),
                path.join(os.homedir(), '.claude-pm'),
                process.cwd()
            ];

            for (const deploymentDir of deploymentLocations) {
                const deployedConfigPath = path.join(deploymentDir, '.claude-pm', 'config.json');
                const deployedClaudePmPath = path.join(deploymentDir, 'claude_pm');
                
                if (fs.existsSync(deployedConfigPath) && fs.existsSync(deployedClaudePmPath)) {
                    const deployedConfig = JSON.parse(fs.readFileSync(deployedConfigPath, 'utf8'));
                    
                    return {
                        found: true,
                        frameworkPath: deploymentDir,
                        claudePmPath: deployedClaudePmPath,
                        deployedConfig: deployedConfig,
                        confidence: deploymentDir === path.join(os.homedir(), '.local') ? 'high' : 'medium'
                    };
                }
            }

            // Check current directory for deployed instance
            const deployedConfigPath = path.join(process.cwd(), '.claude-pm', 'config.json');
            const deployedClaudePmPath = path.join(process.cwd(), 'claude_pm');
            
            if (fs.existsSync(deployedConfigPath) && fs.existsSync(deployedClaudePmPath)) {
                const deployedConfig = JSON.parse(fs.readFileSync(deployedConfigPath, 'utf8'));
                
                return {
                    found: true,
                    frameworkPath: process.cwd(),
                    claudePmPath: deployedClaudePmPath,
                    deployedConfig: deployedConfig,
                    confidence: 'high'
                };
            }

            // Check parent directories for deployed instances
            let currentDir = process.cwd();
            while (currentDir !== path.dirname(currentDir)) {
                const parentConfigPath = path.join(currentDir, '.claude-pm', 'config.json');
                const parentClaudePmPath = path.join(currentDir, 'claude_pm');
                
                if (fs.existsSync(parentConfigPath) && fs.existsSync(parentClaudePmPath)) {
                    const parentConfig = JSON.parse(fs.readFileSync(parentConfigPath, 'utf8'));
                    
                    return {
                        found: true,
                        frameworkPath: currentDir,
                        claudePmPath: parentClaudePmPath,
                        deployedConfig: parentConfig,
                        confidence: 'medium'
                    };
                }
                
                currentDir = path.dirname(currentDir);
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect environment-based configuration
     */
    _detectEnvironmentBased() {
        try {
            // Check environment variables
            const envPaths = [
                process.env.CLAUDE_MULTIAGENT_PM_ROOT,
                process.env.CLAUDE_PM_ROOT,
                process.env.CLAUDE_PM_FRAMEWORK_PATH
            ].filter(Boolean);
            
            for (const envPath of envPaths) {
                const envClaudePmPath = path.join(envPath, 'claude_pm');
                if (fs.existsSync(envClaudePmPath)) {
                    return {
                        found: true,
                        frameworkPath: envPath,
                        claudePmPath: envClaudePmPath,
                        environmentSource: envPath,
                        confidence: 'medium'
                    };
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect fallback scenarios
     */
    _detectFallback() {
        try {
            // Common fallback locations
            const fallbackPaths = [
                path.join(os.homedir(), '.claude-pm'),
                path.join(os.homedir(), 'Projects', 'claude-multiagent-pm'),
                path.join(os.homedir(), 'Projects', 'claude-pm'),
                '/usr/local/lib/claude-pm',
                '/opt/claude-pm'
            ];
            
            for (const fallbackPath of fallbackPaths) {
                const fallbackClaudePmPath = path.join(fallbackPath, 'claude_pm');
                if (fs.existsSync(fallbackClaudePmPath)) {
                    return {
                        found: true,
                        frameworkPath: fallbackPath,
                        claudePmPath: fallbackClaudePmPath,
                        fallbackPath: fallbackPath,
                        confidence: 'low'
                    };
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Build deployment configuration object
     */
    _buildConfig(type, detectionResult) {
        const config = {
            deploymentType: type,
            found: detectionResult.found,
            platform: this.platform,
            detectedAt: new Date().toISOString(),
            confidence: detectionResult.confidence || 'unknown'
        };

        if (detectionResult.found) {
            config.frameworkPath = detectionResult.frameworkPath;
            config.claudePmPath = detectionResult.claudePmPath;
            config.paths = {
                framework: detectionResult.frameworkPath,
                claudePm: detectionResult.claudePmPath,
                bin: path.join(detectionResult.frameworkPath, 'bin'),
                config: path.join(detectionResult.frameworkPath, '.claude-pm'),
                templates: path.join(detectionResult.frameworkPath, 'templates'),
                schemas: path.join(detectionResult.frameworkPath, 'schemas')
            };

            // Add type-specific metadata
            switch (type) {
                case 'local_source':
                    config.metadata = {
                        packageJson: detectionResult.packageJson,
                        isDevelopment: true
                    };
                    break;
                case 'npm_global':
                    config.metadata = {
                        globalPath: detectionResult.globalPath,
                        isGlobalInstall: true
                    };
                    break;
                case 'npx':
                    config.metadata = {
                        npxCachePath: detectionResult.npxCachePath,
                        isNpxExecution: true
                    };
                    break;
                case 'npm_local':
                    config.metadata = {
                        projectRoot: detectionResult.projectRoot,
                        isLocalInstall: true
                    };
                    break;
                case 'deployed':
                    config.metadata = {
                        deployedConfig: detectionResult.deployedConfig,
                        isDeployedInstance: true
                    };
                    break;
                case 'environment':
                    config.metadata = {
                        environmentSource: detectionResult.environmentSource,
                        isEnvironmentBased: true
                    };
                    break;
                case 'fallback':
                    config.metadata = {
                        fallbackPath: detectionResult.fallbackPath,
                        isFallback: true
                    };
                    break;
            }
        } else {
            config.error = detectionResult.error;
        }

        return config;
    }

    /**
     * Get deployment strategy for current context
     */
    getDeploymentStrategy() {
        const config = this.detectDeployment();
        
        if (!config.found) {
            return {
                strategy: 'install_required',
                recommendation: 'npm install -g @bobmatnyc/claude-multiagent-pm',
                config: config
            };
        }

        const strategies = {
            local_source: {
                strategy: 'development',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            npm_global: {
                strategy: 'global_npm',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            npx: {
                strategy: 'npx_execution',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            npm_local: {
                strategy: 'local_npm',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            deployed: {
                strategy: 'deployed_instance',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            environment: {
                strategy: 'environment_configured',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            fallback: {
                strategy: 'fallback_detected',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            }
        };

        return {
            ...strategies[config.deploymentType],
            config: config
        };
    }
}

// Create global detector instance
const deploymentDetector = new DeploymentDetector();

/**
 * Enhanced framework path detection with comprehensive deployment support
 */
function getFrameworkPath() {
    const deploymentStrategy = deploymentDetector.getDeploymentStrategy();
    
    if (deploymentStrategy.strategy === 'install_required') {
        console.error('❌ Claude PM Framework not found');
        console.error('Please install the framework:');
        console.error(`   ${deploymentStrategy.recommendation}`);
        console.error('');
        console.error('Detected deployment scenarios:');
        console.error('- No valid framework installation found');
        console.error('- Checked: local source, npm global, npx, npm local, deployed instances');
        process.exit(1);
    }
    
    return deploymentStrategy.config.frameworkPath;
}

/**
 * Get deployment configuration for advanced usage
 */
function getDeploymentConfig() {
    return deploymentDetector.getDeploymentStrategy();
}

/**
 * Validate Python environment
 */
function validatePython() {
    try {
        const pythonResult = require('child_process').execSync('python3 --version', { encoding: 'utf8' });
        const version = pythonResult.match(/Python (\d+)\.(\d+)/);
        
        if (!version || parseInt(version[1]) < 3 || (parseInt(version[1]) === 3 && parseInt(version[2]) < 8)) {
            console.error('❌ Python 3.8+ required. Found:', pythonResult.trim());
            process.exit(1);
        }
        
        return 'python3';
    } catch (error) {
        try {
            const pythonResult = require('child_process').execSync('python --version', { encoding: 'utf8' });
            const version = pythonResult.match(/Python (\d+)\.(\d+)/);
            
            if (!version || parseInt(version[1]) < 3 || (parseInt(version[1]) === 3 && parseInt(version[2]) < 8)) {
                console.error('❌ Python 3.8+ required. Found:', pythonResult.trim());
                process.exit(1);
            }
            
            return 'python';
        } catch (error) {
            console.error('❌ Python not found. Please install Python 3.8+');
            process.exit(1);
        }
    }
}

/**
 * Detect platform information including WSL2
 */
function detectPlatformInfo() {
    const platform = os.platform();
    let isWSL2 = false;
    let wslDistro = null;
    let display = platform;
    
    // WSL2 Detection
    if (platform === 'linux') {
        try {
            // Check environment variables
            wslDistro = process.env.WSL_DISTRO_NAME;
            const wslEnv = process.env.WSLENV;
            
            if (wslDistro || wslEnv) {
                // Check /proc/version for WSL2 specifically
                if (fs.existsSync('/proc/version')) {
                    const versionContent = fs.readFileSync('/proc/version', 'utf8');
                    isWSL2 = versionContent.includes('WSL2') || versionContent.includes('microsoft');
                    
                    if (isWSL2) {
                        display = `Linux (WSL2${wslDistro ? ` - ${wslDistro}` : ''})`;
                    } else {
                        display = `Linux (WSL1${wslDistro ? ` - ${wslDistro}` : ''})`;
                    }
                } else {
                    display = `Linux (WSL${wslDistro ? ` - ${wslDistro}` : ''})`;
                }
            }
        } catch (error) {
            // Fallback to standard Linux detection
        }
    }
    
    return {
        platform,
        isWSL2,
        wslDistro,
        display
    };
}

/**
 * Get npm global bin directory
 */
function getNpmGlobalBin() {
    try {
        const { execSync } = require('child_process');
        
        // Try multiple methods to get npm global bin
        const methods = [
            () => execSync('npm bin -g', { encoding: 'utf8', timeout: 3000 }).trim(),
            () => execSync('npm config get prefix', { encoding: 'utf8', timeout: 3000 }).trim() + '/bin',
            () => {
                // NVM-specific detection
                const nvmDir = process.env.NVM_DIR || path.join(os.homedir(), '.nvm');
                const nodeVersion = process.version;
                return path.join(nvmDir, 'versions', 'node', nodeVersion, 'bin');
            }
        ];
        
        for (const method of methods) {
            try {
                const binDir = method();
                if (binDir && fs.existsSync(binDir)) {
                    return binDir;
                }
            } catch (methodError) {
                // Try next method
            }
        }
        
        return null;
    } catch (error) {
        return null;
    }
}

/**
 * Analyze WSL2 PATH configuration for issues
 */
function analyzeWSL2Path() {
    const issues = [];
    let hasIssues = false;
    
    try {
        const currentPath = process.env.PATH || '';
        const npmGlobalBin = getNpmGlobalBin();
        
        // Check if npm global bin is in PATH
        if (npmGlobalBin && !currentPath.includes(npmGlobalBin)) {
            issues.push(`NPM global bin directory not in PATH: ${npmGlobalBin}`);
            hasIssues = true;
        }
        
        // Check for NVM-related PATH issues
        const nvmDir = process.env.NVM_DIR;
        if (nvmDir && !currentPath.includes('.nvm')) {
            issues.push('NVM paths may not be properly configured in PATH');
            hasIssues = true;
        }
        
        // Check if claude-pm is accessible
        try {
            const { execSync } = require('child_process');
            execSync('which claude-pm', { encoding: 'utf8', timeout: 3000 });
        } catch (error) {
            issues.push('claude-pm command not found in current PATH');
            hasIssues = true;
        }
        
        // Check if aitrackdown is accessible
        try {
            const { execSync } = require('child_process');
            execSync('which aitrackdown', { encoding: 'utf8', timeout: 3000 });
        } catch (error) {
            issues.push('aitrackdown command not found in current PATH');
            hasIssues = true;
        }
        
    } catch (error) {
        issues.push(`PATH analysis failed: ${error.message}`);
        hasIssues = true;
    }
    
    return { hasIssues, issues };
}

/**
 * Show enhanced help message with deployment detection
 */
function showHelp() {
    const deploymentConfig = deploymentDetector.getDeploymentStrategy();
    
    console.log(`
Claude Multi-Agent PM Framework v${CLAUDE_PM_VERSION}
Universal CLI for AI-driven project management

Usage: claude-pm [command] [options]

Commands:
  health              Health monitoring and status
  memory              Memory management operations  
  project             Project management operations
  service             Service management
  workflow            Workflow orchestration
  enforcement         Framework enforcement
  deploy-template     Deploy CLAUDE.md template to current directory
  --version           Show version information
  --deployment-info   Show deployment detection results
  --system-info       Show system information with CLAUDE.md version
  --manage-claude-md  Manage framework CLAUDE.md deployment tree
  --template-status   Show template management status (CMPM-102)
  --dependency-status Show dependency management status (CMPM-103)
  --parent-directory-status Show parent directory management status (CMPM-104)
  --claude-info       Show detailed Claude CLI validation and compatibility
  --env-status        Show comprehensive environment validation status
  --troubleshoot      Display troubleshooting guide for common issues
  --help              Show this help message

Framework Integration:
  This CLI provides universal access to the Claude PM Framework
  regardless of installation location or platform.

Current Deployment:
  Type: ${deploymentConfig.config.found ? deploymentConfig.config.deploymentType : 'not_found'}
  Path: ${deploymentConfig.config.found ? deploymentConfig.config.frameworkPath : 'N/A'}
  Confidence: ${deploymentConfig.config.found ? deploymentConfig.config.confidence : 'N/A'}

Examples:
  claude-pm health status
  claude-pm project create my-project
  claude-pm memory init
  claude-pm service start all
  claude-pm --deployment-info
  claude-pm --template-status
  claude-pm --dependency-status
  claude-pm --parent-directory-status
  claude-pm --claude-info
  claude-pm --env-status
  claude-pm --troubleshoot

For more information, visit:
https://github.com/bobmatnyc/claude-pm
`);
}

/**
 * Display comprehensive system information
 */
function displaySystemInfo() {
    const deploymentConfig = getDeploymentConfig();
    const today = new Date().toISOString().split('T')[0]; // 2025-07-11 format
    
    console.log('\n' + '='.repeat(70));
    console.log('🚀 CLAUDE PM FRAMEWORK - SYSTEM INFORMATION');
    console.log('='.repeat(70));
    console.log(`📅 System Status as of ${today}`);
    console.log('');
    
    // Framework Version - Show both package and deployed if different
    console.log(`📦 Claude PM Framework Version: v${CLAUDE_PM_VERSION}`);
    
    // Show deployment config version if different from package version
    try {
        if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
            const config = deploymentConfig.config;
            
            if (config.deploymentType === 'deployed' && config.metadata?.deployedConfig) {
                const deployedVersion = config.metadata.deployedConfig.version;
                if (deployedVersion !== CLAUDE_PM_VERSION) {
                    console.log(`⚙️  Deployed Config Version: v${deployedVersion} (will be updated)`);
                }
            }
        }
    } catch (error) {
        // Silent fallback
    }
    
    // Install Path
    if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
        console.log(`📁 Install Path: ${deploymentConfig.config.frameworkPath}`);
    } else {
        console.log(`📁 Install Path: Not detected`);
    }
    
    // Working Path
    console.log(`📂 Working Path: ${process.cwd()}`);
    
    // Platform Detection (including WSL2)
    const platformInfo = detectPlatformInfo();
    console.log(`🖥️  Platform: ${platformInfo.display}`);
    if (platformInfo.isWSL2) {
        console.log(`🐧 WSL2 Environment: ${platformInfo.wslDistro || 'Detected'}`);
        
        // WSL2-specific PATH diagnostics
        const pathDiagnostics = analyzeWSL2Path();
        if (pathDiagnostics.hasIssues) {
            console.log(`⚠️  WSL2 PATH Issues Detected:`);
            for (const issue of pathDiagnostics.issues) {
                console.log(`   • ${issue}`);
            }
            console.log(`💡 Run: ~/.claude-pm/wsl2-diagnostic.sh for detailed analysis`);
        }
    }
    
    // AI-trackdown-tools Version (with WSL2-aware checking)
    try {
        const { execSync } = require('child_process');
        const execOptions = {
            encoding: 'utf8',
            timeout: 5000
        };
        
        // For WSL2, try with extended PATH
        if (platformInfo.isWSL2) {
            const npmGlobalBin = getNpmGlobalBin();
            if (npmGlobalBin) {
                execOptions.env = {
                    ...process.env,
                    PATH: process.env.PATH + ':' + npmGlobalBin
                };
            }
        }
        
        const version = execSync('aitrackdown --version', execOptions).trim();
        console.log(`🔍 AI-trackdown-tools Version: v${version}`);
    } catch (error) {
        console.log(`🔍 AI-trackdown-tools Version: Not installed or not accessible`);
        if (platformInfo.isWSL2) {
            console.log(`   💡 WSL2 Tip: Try 'source ~/.bashrc' or check PATH configuration`);
        }
    }
    
    // Claude CLI Version and Compatibility
    try {
        const claudeCheck = quickClaudeCheck();
        if (claudeCheck.available) {
            const { execSync } = require('child_process');
            const claudeVersion = execSync('claude --version', { encoding: 'utf8', timeout: 3000 }).trim();
            const versionMatch = claudeVersion.match(/(\d+\.\d+\.\d+)/);
            const version = versionMatch ? versionMatch[1] : 'unknown';
            console.log(`🤖 Claude CLI Version: v${version} (compatible)`);
        } else {
            console.log(`🤖 Claude CLI Version: Not available - ${claudeCheck.suggestion}`);
        }
    } catch (error) {
        console.log(`🤖 Claude CLI Version: Error detecting (run --claude-info for details)`);
    }
    
    // Install Type
    if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
        const deploymentType = deploymentConfig.config.deploymentType;
        let installType = 'Unknown';
        
        switch (deploymentType) {
            case 'deployed':
                installType = 'Local Deploy';
                break;
            case 'npm_global':
                installType = 'Global NPM Installation';
                break;
            case 'npm_local':
                installType = 'Local NPM Installation';
                break;
            case 'npx':
                installType = 'NPX Execution';
                break;
            case 'local_source':
                installType = 'Local Source Development';
                break;
            default:
                installType = deploymentType;
        }
        
        console.log(`⚙️  Install Type: ${installType}`);
    } else {
        console.log(`⚙️  Install Type: Not detected`);
    }
    
    // Memory System Status - Use dedicated Python detection function
    try {
        const { execSync } = require('child_process');
        const frameworkPath = deploymentConfig && deploymentConfig.config && deploymentConfig.config.found 
            ? deploymentConfig.config.frameworkPath 
            : process.cwd();
        
        // Call the Python _detect_memory_manager_info() function directly
        const memoryInfo = execSync(`python3 -c "import sys; sys.path.insert(0, '${frameworkPath}'); from claude_pm.cli import _detect_memory_manager_info; print(_detect_memory_manager_info())"`, {
            cwd: frameworkPath,
            timeout: 2000,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();
        
        if (memoryInfo && memoryInfo !== 'error') {
            console.log(`🧠 Memory: ${memoryInfo}`);
        } else {
            // Fallback detection only if Python function fails
            const localMemoryJsonPath = path.join(process.cwd(), 'memory.json');
            const localMemoryDbPath = path.join(process.cwd(), 'memory.db');
            
            if (fs.existsSync(localMemoryJsonPath) || fs.existsSync(localMemoryDbPath)) {
                console.log(`🧠 Memory: Memory files detected`);
            } else {
                console.log(`🧠 Memory: No memory system detected`);
            }
        }
    } catch (error) {
        // Fallback detection if Python call fails
        const localMemoryJsonPath = path.join(process.cwd(), 'memory.json');
        const localMemoryDbPath = path.join(process.cwd(), 'memory.db');
        
        if (fs.existsSync(localMemoryJsonPath) || fs.existsSync(localMemoryDbPath)) {
            console.log(`🧠 Memory: Memory files detected`);
        } else {
            console.log(`🧠 Memory: Unable to determine status`);
        }
    }
    
    // CLAUDE.md Detection - Current Directory and Framework
    try {
        const currentDirClaudeMd = path.join(process.cwd(), 'CLAUDE.md');
        let foundCurrentDir = false;
        
        if (fs.existsSync(currentDirClaudeMd)) {
            const claudeMdContent = fs.readFileSync(currentDirClaudeMd, 'utf8');
            
            // Extract CLAUDE_MD_VERSION and FRAMEWORK_VERSION to combine them
            const claudeMdVersionMatch = claudeMdContent.match(/CLAUDE_MD_VERSION:\s*([\d\.-]+)/);
            const frameworkVersionMatch = claudeMdContent.match(/FRAMEWORK_VERSION:\s*(\d+)/);
            
            if (claudeMdVersionMatch && frameworkVersionMatch) {
                const claudeMdVersion = claudeMdVersionMatch[1];
                const frameworkVersion = frameworkVersionMatch[1];
                // Combine versions in format: CLAUDE_MD_VERSION-FRAMEWORK_VERSION
                console.log(`📄 CLAUDE.md (Current): v${claudeMdVersion}-${frameworkVersion}`);
            } else if (claudeMdVersionMatch) {
                const version = claudeMdVersionMatch[1];
                // Use framework version + serial format (legacy)
                if (version.includes('-')) {
                    const [, serial] = version.split('-', 2);
                    console.log(`📄 CLAUDE.md (Current): v${CLAUDE_PM_VERSION}-${serial}`);
                } else {
                    console.log(`📄 CLAUDE.md (Current): v${CLAUDE_PM_VERSION} (Legacy format)`);
                }
            } else {
                // No version metadata - treat as project documentation, show line count
                const lines = claudeMdContent.split('\n').length;
                console.log(`📄 Project CLAUDE.md: ${lines} lines`);
            }
            foundCurrentDir = true;
        }
        
        // Quick framework CLAUDE.md detection for system info - context-aware
        const cwd = process.cwd();
        const frameworkPaths = [];
        
        // If we're in the framework directory, prioritize framework's own CLAUDE.md
        if (cwd.includes('claude-multiagent-pm')) {
            frameworkPaths.push(
                path.join(cwd, 'CLAUDE.md'),                    // Current framework directory
                path.join(cwd, '..', 'CLAUDE.md'),              // Parent of framework
                '/Users/masa/Projects/CLAUDE.md'                // Top-level Projects
            );
        } else {
            // If we're outside framework, look in broader context
            frameworkPaths.push(
                path.join(cwd, 'CLAUDE.md'),                    // Current directory
                path.join(cwd, '..', 'CLAUDE.md'),              // Parent directory
                '/Users/masa/Projects/managed/CLAUDE.md',       // Managed template
                '/Users/masa/Projects/CLAUDE.md'                // Top-level Projects
            );
        }
        
        let foundFramework = false;
        for (const frameworkPath of frameworkPaths) {
            if (fs.existsSync(frameworkPath)) {
                try {
                    const content = fs.readFileSync(frameworkPath, 'utf8');
                    
                    // Check if it's a framework file
                    const isFramework = content.includes('template CLAUDE.md file for the Claude PM Framework') ||
                                      content.includes('Claude PM Framework Configuration - Deployment') ||
                                      content.includes('AI ASSISTANT ROLE DESIGNATION');
                    
                    if (isFramework) {
                        // Format path with ~ for home directory
                        const displayPath = frameworkPath.replace('/Users/masa', '~');
                        const claudeMdVersionMatch = content.match(/CLAUDE_MD_VERSION:\s*([\d\.-]+)/);
                        const frameworkVersionMatch = content.match(/FRAMEWORK_VERSION:\s*(\d+)/);
                        
                        if (claudeMdVersionMatch && frameworkVersionMatch) {
                            const claudeMdVersion = claudeMdVersionMatch[1];
                            const frameworkVersion = frameworkVersionMatch[1];
                            // Combine versions in format: CLAUDE_MD_VERSION-FRAMEWORK_VERSION
                            console.log(`📋 Framework CLAUDE.md: ${displayPath} (${claudeMdVersion}-${frameworkVersion})`);
                        } else if (claudeMdVersionMatch) {
                            const version = claudeMdVersionMatch[1];
                            // Use framework version + serial format (legacy)
                            if (version.includes('-')) {
                                const [, serial] = version.split('-', 2);
                                console.log(`📋 Framework CLAUDE.md: ${displayPath} (${CLAUDE_PM_VERSION}-${serial})`);
                            } else {
                                console.log(`📋 Framework CLAUDE.md: ${displayPath} (${CLAUDE_PM_VERSION})`);
                            }
                        } else {
                            console.log(`📋 Framework CLAUDE.md: ${displayPath}`);
                        }
                        foundFramework = true;
                        break;
                    }
                } catch (error) {
                    // Skip unreadable files
                }
            }
        }
        
        if (!foundCurrentDir) {
            console.log(`📄 User CLAUDE.md: not in working path`);
        }
        
    } catch (error) {
        console.log(`📄 CLAUDE.md: Unable to check (${error.message})`);
    }
    
    console.log('');
    console.log('='.repeat(70));
    console.log('🎯 Launching Claude with optimized settings...');
    console.log('='.repeat(70));
    console.log('');
}

/**
 * Framework CLAUDE.md Management - Safe cleanup of framework deployments
 */
async function manageFrameworkClaudeMd() {
    const fs = require('fs');
    const path = require('path');
    
    try {
        // Get current working directory
        const cwd = process.cwd();
        
        // Find the framework directory
        let frameworkDir = null;
        const possibleFrameworkPaths = [
            cwd, // If we're already in the framework
            path.join(cwd, 'claude-multiagent-pm'), // If framework is a subdirectory
            path.dirname(cwd) // If we're in a subdirectory of the framework area
        ];
        
        for (const testPath of possibleFrameworkPaths) {
            if (fs.existsSync(path.join(testPath, 'claude_pm')) && 
                fs.existsSync(path.join(testPath, 'framework', 'CLAUDE.md'))) {
                frameworkDir = testPath;
                break;
            }
        }
        
        // Find all CLAUDE.md files - use context-aware search like system info
        const claudeMdFiles = [];
        let searchRoot;
        
        if (!frameworkDir) {
            // Not in a framework context, search in broader area
            searchRoot = '/Users/masa/Projects';
        } else {
            // Framework context - only search within our working path, not external areas
            searchRoot = path.dirname(frameworkDir);
            
            // Context-aware file list - only look in our working path
            const cwd = process.cwd();
            const contextAwarePaths = [];
            
            // If we're in the framework directory, only check our immediate context
            if (cwd.includes('claude-multiagent-pm')) {
                contextAwarePaths.push(
                    path.join(cwd, 'CLAUDE.md'),                    // Current framework directory
                    path.join(cwd, '..', 'CLAUDE.md')               // Parent of framework
                );
            } else {
                contextAwarePaths.push(
                    path.join(cwd, 'CLAUDE.md'),                    // Current directory
                    path.join(cwd, '..', 'CLAUDE.md')               // Parent directory
                );
            }
            
            // Only add files that actually exist in our context
            for (const contextPath of contextAwarePaths) {
                if (fs.existsSync(contextPath)) {
                    claudeMdFiles.push(contextPath);
                }
            }
        }
        
        // Only do broader search if not in framework context
        if (!frameworkDir) {
            function findClaudeMdFiles(dir, maxDepth = 3, currentDepth = 0) {
                if (currentDepth >= maxDepth) return;
                
                try {
                    const items = fs.readdirSync(dir);
                    
                    for (const item of items) {
                        const itemPath = path.join(dir, item);
                        const stat = fs.statSync(itemPath);
                        
                        if (stat.isFile() && item === 'CLAUDE.md') {
                            claudeMdFiles.push(itemPath);
                        } else if (stat.isDirectory() && !item.startsWith('.') && 
                                  item !== 'node_modules' && item !== '_archive') {
                            findClaudeMdFiles(itemPath, maxDepth, currentDepth + 1);
                        }
                    }
                } catch (error) {
                    // Skip directories we can't read
                }
            }
            
            findClaudeMdFiles(searchRoot);
        }
        
        
        // Analyze each CLAUDE.md to determine if it's framework-generated
        const frameworkFiles = [];
        const userFiles = [];
        
        for (const filePath of claudeMdFiles) {
            try {
                const content = fs.readFileSync(filePath, 'utf8');
                
                // Framework indicators (be very conservative)
                const frameworkIndicators = [
                    'Claude PM Framework Configuration - Deployment',
                    'CLAUDE_MD_VERSION:',
                    'FRAMEWORK_VERSION:',
                    'AI ASSISTANT ROLE DESIGNATION',
                    'multi-agent orchestrator',
                    'template CLAUDE.md file for the Claude PM Framework',
                    'Deployment Root:',
                    'Generated:'
                ];
                
                // User/project indicators (these make it NOT a framework file)
                const userIndicators = [
                    'project-specific',
                    'custom instructions',
                    'my project',
                    'this project',
                    'application',
                    'repository',
                    'codebase'
                ];
                
                const hasFrameworkIndicators = frameworkIndicators.some(indicator => 
                    content.includes(indicator));
                const hasUserIndicators = userIndicators.some(indicator => 
                    content.toLowerCase().includes(indicator.toLowerCase()));
                
                // Strong framework indicators override weak user indicators
                const strongFrameworkIndicators = [
                    'Claude PM Framework Configuration - Deployment',
                    'AI ASSISTANT ROLE DESIGNATION',
                    'multi-agent orchestrator'
                ];
                
                const hasStrongFrameworkIndicators = strongFrameworkIndicators.some(indicator => 
                    content.includes(indicator));
                
                // If we have strong framework indicators, it's definitely a framework file
                const isFrameworkFile = hasStrongFrameworkIndicators || (hasFrameworkIndicators && !hasUserIndicators);
                
                if (isFrameworkFile) {
                    frameworkFiles.push({
                        path: filePath,
                        relativePath: path.relative(searchRoot, filePath),
                        content: content.substring(0, 200) // First 200 chars for analysis
                    });
                } else {
                    userFiles.push({
                        path: filePath,
                        relativePath: path.relative(searchRoot, filePath)
                    });
                }
            } catch (error) {
                // Skip files we can't read
            }
        }
        
        // Find the top-most directory that should have the framework CLAUDE.md
        const topLevel = searchRoot;
        const targetFrameworkFile = path.join(topLevel, 'CLAUDE.md');
        
        // Check if we have a proper framework CLAUDE.md at the top level
        const hasTopLevelFramework = frameworkFiles.some(f => f.path === targetFrameworkFile);
        
        if (!hasTopLevelFramework) {
            // Check if we have any framework files at other levels
            const activeFrameworkFile = frameworkFiles.length > 0 ? frameworkFiles[0] : null;
            
            return {
                action: 'no_action',
                reason: 'No framework CLAUDE.md at top level (normal)',
                frameworkFiles: frameworkFiles.length,
                userFiles: userFiles.length,
                activeFrameworkFile: activeFrameworkFile ? activeFrameworkFile.relativePath : null
            };
        }
        
        // We have a framework CLAUDE.md at top level, remove any duplicates below it
        const filesToRemove = frameworkFiles.filter(f => f.path !== targetFrameworkFile);
        
        if (filesToRemove.length === 0) {
            return {
                action: 'clean',
                reason: 'Framework CLAUDE.md structure is already clean',
                frameworkFiles: frameworkFiles.length,
                userFiles: userFiles.length,
                topLevelFile: path.relative(searchRoot, targetFrameworkFile)
            };
        }
        
        // Add 'old' suffix to duplicate framework files (VERY CAREFULLY)
        const processedFiles = [];
        for (const file of filesToRemove) {
            try {
                // CRITICAL PROTECTION: NEVER MODIFY framework/CLAUDE.md
                if (file.path.includes('framework/CLAUDE.md')) {
                    continue;
                }
                
                // Extra safety check - make sure it's really a framework file
                if (file.content.includes('Claude PM Framework') || 
                    file.content.includes('CLAUDE_MD_VERSION:')) {
                    const oldPath = file.path + '.old';
                    fs.renameSync(file.path, oldPath);
                    processedFiles.push(file.relativePath + ' → ' + path.basename(oldPath));
                }
            } catch (error) {
                console.error(`Warning: Could not rename ${file.path}: ${error.message}`);
            }
        }
        
        return {
            action: 'cleaned',
            reason: `Added 'old' suffix to ${processedFiles.length} duplicate framework CLAUDE.md files`,
            processedFiles,
            frameworkFiles: frameworkFiles.length,
            userFiles: userFiles.length,
            topLevelFile: path.relative(searchRoot, targetFrameworkFile)
        };
        
    } catch (error) {
        return {
            action: 'error',
            reason: error.message
        };
    }
}

/**
 * Claude CLI Version Detection and Compatibility System
 */
class ClaudeCliValidator {
    constructor() {
        this.versionCache = null;
        this.featureCache = new Map();
    }

    /**
     * Detect Claude CLI version
     */
    async detectClaudeVersion() {
        if (this.versionCache) {
            return this.versionCache;
        }

        try {
            const { execSync } = require('child_process');
            const versionOutput = execSync('claude --version', { 
                encoding: 'utf8', 
                stdio: 'pipe',
                timeout: 5000 
            }).trim();
            
            // Parse version from output
            const versionMatch = versionOutput.match(/(\d+\.\d+\.\d+)/);
            this.versionCache = {
                found: true,
                version: versionMatch ? versionMatch[1] : 'unknown',
                fullOutput: versionOutput
            };
            
            return this.versionCache;
        } catch (error) {
            this.versionCache = {
                found: false,
                error: error.message,
                version: null
            };
            return this.versionCache;
        }
    }

    /**
     * Test if Claude CLI supports specific feature
     */
    async testClaudeFeature(feature) {
        const cacheKey = feature;
        if (this.featureCache.has(cacheKey)) {
            return this.featureCache.get(cacheKey);
        }

        try {
            const { execSync } = require('child_process');
            
            // Test specific features
            let testCommand;
            switch (feature) {
                case 'model-option':
                    testCommand = 'claude --help';
                    break;
                case 'skip-permissions':
                    testCommand = 'claude --help';
                    break;
                default:
                    throw new Error(`Unknown feature: ${feature}`);
            }

            const helpOutput = execSync(testCommand, { 
                encoding: 'utf8', 
                stdio: 'pipe',
                timeout: 5000 
            });
            
            let supported = false;
            switch (feature) {
                case 'model-option':
                    supported = helpOutput.includes('--model') || helpOutput.includes('-m');
                    break;
                case 'skip-permissions':
                    supported = helpOutput.includes('--dangerously-skip-permissions');
                    break;
            }

            const result = { supported, tested: true };
            this.featureCache.set(cacheKey, result);
            return result;
            
        } catch (error) {
            const result = { supported: false, tested: false, error: error.message };
            this.featureCache.set(cacheKey, result);
            return result;
        }
    }

    /**
     * Get optimal Claude launch command with graceful fallback
     */
    async getOptimalLaunchCommand() {
        const version = await this.detectClaudeVersion();
        
        if (!version.found) {
            throw new Error(`Claude CLI not found: ${version.error}`);
        }

        // Test feature support
        const modelSupport = await this.testClaudeFeature('model-option');
        const skipPermissionsSupport = await this.testClaudeFeature('skip-permissions');

        const command = ['claude'];
        
        // Add skip permissions if supported
        if (skipPermissionsSupport.supported) {
            command.push('--dangerously-skip-permissions');
        }
        
        // Add model option if supported
        if (modelSupport.supported) {
            command.push('--model', 'sonnet');
        }

        return {
            command,
            version: version.version,
            features: {
                modelOption: modelSupport.supported,
                skipPermissions: skipPermissionsSupport.supported
            },
            fallbackReason: !modelSupport.supported ? 'Model option not supported by this Claude CLI version' : null
        };
    }

    /**
     * Validate Claude CLI environment
     */
    async validateEnvironment() {
        try {
            const launchConfig = await this.getOptimalLaunchCommand();
            return {
                valid: true,
                version: launchConfig.version,
                command: launchConfig.command,
                features: launchConfig.features,
                fallbackReason: launchConfig.fallbackReason
            };
        } catch (error) {
            // Enhanced error handling for WSL2
            const platformInfo = detectPlatformInfo();
            
            if (platformInfo.isWSL2 && error.message.includes('not found')) {
                // WSL2-specific PATH issue diagnosis
                const pathAnalysis = analyzeWSL2Path();
                const wsl2Guidance = this.getWSL2Guidance(pathAnalysis);
                
                return {
                    valid: false,
                    error: error.message,
                    troubleshooting: this.getTroubleshootingSteps(error.message),
                    wsl2Issues: pathAnalysis,
                    wsl2Guidance: wsl2Guidance,
                    isWSL2: true
                };
            }
            
            return {
                valid: false,
                error: error.message,
                troubleshooting: this.getTroubleshootingSteps(error.message),
                isWSL2: platformInfo.isWSL2
            };
        }
    }
    
    /**
     * Get WSL2-specific guidance for PATH issues
     */
    getWSL2Guidance(pathAnalysis) {
        const guidance = {
            immediate: [],
            permanent: [],
            diagnostic: []
        };
        
        // Immediate fixes
        if (pathAnalysis.hasIssues) {
            const npmGlobalBin = getNpmGlobalBin();
            if (npmGlobalBin) {
                guidance.immediate.push(`export PATH="${npmGlobalBin}:$PATH"`);
                guidance.immediate.push('source ~/.bashrc  # or ~/.zshrc');
            }
        }
        
        // Permanent fixes
        guidance.permanent.push('Add to ~/.bashrc or ~/.zshrc:');
        const npmGlobalBin = getNpmGlobalBin();
        if (npmGlobalBin) {
            guidance.permanent.push(`echo 'export PATH="${npmGlobalBin}:$PATH"' >> ~/.bashrc`);
        } else {
            guidance.permanent.push('echo \'export PATH="$(npm bin -g):$PATH"\' >> ~/.bashrc');
        }
        guidance.permanent.push('source ~/.bashrc');
        
        // Diagnostic tools
        guidance.diagnostic.push('~/.claude-pm/wsl2-diagnostic.sh');
        guidance.diagnostic.push('npm config get prefix');
        guidance.diagnostic.push('npm bin -g');
        guidance.diagnostic.push('echo $PATH');
        
        return guidance;
    }

    /**
     * Get troubleshooting steps for common issues
     */
    getTroubleshootingSteps(errorMessage) {
        const steps = [];
        
        if (errorMessage.includes('not found') || errorMessage.includes('command not found')) {
            steps.push('Install Claude CLI: Visit https://claude.ai/download');
            steps.push('Verify PATH: Ensure Claude CLI is in your system PATH');
            steps.push('Restart terminal: Close and reopen your terminal window');
        }
        
        if (errorMessage.includes('timeout') || errorMessage.includes('ETIMEDOUT')) {
            steps.push('Network connectivity: Check your internet connection');
            steps.push('Firewall settings: Ensure Claude CLI can access network');
            steps.push('Try again: Network issues may be temporary');
        }
        
        if (errorMessage.includes('permission') || errorMessage.includes('EACCES')) {
            steps.push('File permissions: Check Claude CLI executable permissions');
            steps.push('Run with elevated privileges if necessary');
            steps.push('Check installation directory permissions');
        }
        
        if (steps.length === 0) {
            steps.push('Update Claude CLI: Ensure you have the latest version');
            steps.push('Reinstall Claude CLI: Download and reinstall from https://claude.ai/download');
            steps.push('Check system compatibility: Verify your OS is supported');
        }
        
        return steps;
    }

    /**
     * Display helpful error information
     */
    displayErrorGuidance(validation) {
        console.error('\n🔧 Claude CLI Troubleshooting Guide:');
        console.error('=' .repeat(50));
        console.error(`❌ Error: ${validation.error}`);
        console.error('');
        
        // WSL2-specific guidance
        if (validation.isWSL2 && validation.wsl2Guidance) {
            console.error('🐧 WSL2-Specific Solutions:');
            console.error('');
            
            console.error('🚀 Quick Fix (try this first):');
            validation.wsl2Guidance.immediate.forEach((step, index) => {
                console.error(`   ${index + 1}. ${step}`);
            });
            console.error('');
            
            console.error('🔧 Permanent Fix:');
            validation.wsl2Guidance.permanent.forEach((step, index) => {
                console.error(`   ${index + 1}. ${step}`);
            });
            console.error('');
            
            console.error('🔍 Diagnostic Tools:');
            validation.wsl2Guidance.diagnostic.forEach((tool, index) => {
                console.error(`   ${index + 1}. ${tool}`);
            });
            console.error('');
            
            if (validation.wsl2Issues && validation.wsl2Issues.hasIssues) {
                console.error('⚠️  Detected WSL2 PATH Issues:');
                validation.wsl2Issues.issues.forEach((issue, index) => {
                    console.error(`   • ${issue}`);
                });
                console.error('');
            }
        }
        
        console.error('💡 General Solutions:');
        validation.troubleshooting.forEach((step, index) => {
            console.error(`   ${index + 1}. ${step}`);
        });
        console.error('');
        console.error('📚 Additional Resources:');
        console.error('   • Claude CLI Documentation: https://claude.ai/docs/cli');
        console.error('   • Installation Guide: https://claude.ai/download');
        console.error('   • GitHub Issues: https://github.com/anthropics/claude-cli/issues');
        if (validation.isWSL2) {
            console.error('   • WSL2 PATH Issues: https://github.com/bobmatnyc/claude-multiagent-pm/issues/1');
        }
        console.error('');
    }
}

/**
 * Enhanced main execution function with deployment detection and memory management
 */
async function main() {
    const args = process.argv.slice(2);
    
    // Memory monitoring and early exit for memory exhaustion
    const memoryThreshold = 3.5 * 1024 * 1024 * 1024; // 3.5GB threshold
    const checkMemory = () => {
        const usage = process.memoryUsage();
        if (usage.heapUsed > memoryThreshold) {
            console.error(`❌ Memory usage critical: ${Math.round(usage.heapUsed / 1024 / 1024)}MB`);
            console.error('Triggering garbage collection and cleanup...');
            if (global.gc) {
                global.gc();
            }
            // Force cleanup of deployment detector
            if (deploymentDetector) {
                deploymentDetector.cleanup();
            }
            return true;
        }
        return false;
    };
    
    // Monitor memory every 10 seconds during execution
    const memoryMonitor = setInterval(checkMemory, 10000);
    
    // Cleanup function for proper resource management
    const cleanup = () => {
        if (memoryMonitor) {
            clearInterval(memoryMonitor);
        }
        if (deploymentDetector) {
            deploymentDetector.cleanup();
        }
        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }
    };
    
    // Setup cleanup handlers
    process.on('exit', cleanup);
    process.on('SIGINT', () => {
        cleanup();
        process.exit(0);
    });
    process.on('SIGTERM', () => {
        cleanup();
        process.exit(0);
    });
    
    // Check memory immediately
    if (checkMemory()) {
        console.error('❌ Starting with high memory usage - may indicate memory leak');
    }
    
    // Handle special flags
    if (args.includes('--version') || args.includes('-v')) {
        console.log(`Claude Multi-Agent PM Framework v${CLAUDE_PM_VERSION}`);
        
        // Also show deployment config version if available
        try {
            const deploymentConfig = getDeploymentConfig();
            
            // Check if we have a deployed instance with config
            if (deploymentConfig && deploymentConfig.config && 
                deploymentConfig.config.deploymentType === 'deployed' && 
                deploymentConfig.config.metadata && 
                deploymentConfig.config.metadata.deployedConfig) {
                
                const deployedConfig = deploymentConfig.config.metadata.deployedConfig;
                console.log(`Deployment Config Version: v${deployedConfig.version}`);
                if (deployedConfig.deployedAt) {
                    console.log(`Deployed: ${new Date(deployedConfig.deployedAt).toLocaleString()}`);
                }
                console.log(`Deployment Type: ${deploymentConfig.config.deploymentType}`);
                console.log(`Framework Path: ${deploymentConfig.config.frameworkPath}`);
            } else {
                // Try to read deployment config directly from standard locations
                const deploymentConfigPaths = [
                    path.join(os.homedir(), '.local', '.claude-pm', 'config.json'),
                    path.join(os.homedir(), '.claude-pm', 'config.json'),
                    path.join(process.cwd(), '.claude-pm', 'config.json')
                ];
                
                for (const configPath of deploymentConfigPaths) {
                    if (fs.existsSync(configPath)) {
                        const deployedConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
                        console.log(`Deployment Config Version: v${deployedConfig.version}`);
                        if (deployedConfig.deployedAt) {
                            console.log(`Deployed: ${new Date(deployedConfig.deployedAt).toLocaleString()}`);
                        }
                        console.log(`Deployment Type: ${deploymentConfig.config.deploymentType}`);
                        console.log(`Framework Path: ${deploymentConfig.config.frameworkPath}`);
                        break;
                    }
                }
            }
        } catch (error) {
            // Silent fallback if deployment config is not available
        }
        
        process.exit(0);
    }
    
    if (args.includes('--help') || args.includes('-h')) {
        showHelp();
        process.exit(0);
    }
    
    // Handle no arguments case - display system info then launch Claude
    if (args.length === 0) {
        // Display comprehensive system information
        displaySystemInfo();
        
        // Manage framework CLAUDE.md deployment tree and show active framework file
        try {
            const frameworkResult = await manageFrameworkClaudeMd();
            if (frameworkResult.action === 'cleaned') {
                if (frameworkResult.processedFiles && frameworkResult.processedFiles.length > 0) {
                    console.log(`🧹 Framework cleanup: ${frameworkResult.reason}`);
                    console.log(`   Processed files: ${frameworkResult.processedFiles.join(', ')}`);
                }
            } else if (frameworkResult.action === 'error') {
                console.log(`⚠️  Framework cleanup warning: ${frameworkResult.reason}`);
            }
            
            // Note: Project CLAUDE.md info is already shown in the main system info section above
            // This section was creating duplicate display - removing to fix duplicate issue
        } catch (error) {
            console.log(`⚠️  Framework cleanup error: ${error.message}`);
        }
        
        try {
            // Create Claude CLI validator and validate environment
            const claudeValidator = new ClaudeCliValidator();
            console.log('🔍 Validating Claude CLI environment...');
            
            const validation = await claudeValidator.validateEnvironment();
            
            if (!validation.valid) {
                console.error('❌ Claude CLI validation failed');
                claudeValidator.displayErrorGuidance(validation);
                cleanup();
                process.exit(1);
            }
            
            // Display validation results
            console.log(`✅ Claude CLI v${validation.version} detected`);
            if (validation.fallbackReason) {
                console.log(`⚠️  ${validation.fallbackReason}`);
                console.log(`   → Using fallback command: ${validation.command.join(' ')}`);
            } else {
                console.log(`   → Using optimized command: ${validation.command.join(' ')}`);
            }
            
            // Add memory optimization to Claude launch
            const claudeEnv = {
                ...process.env,
                NODE_OPTIONS: '--max-old-space-size=8192'
            };
            
            // Use validated command
            const claudeProcess = spawn(validation.command[0], validation.command.slice(1), {
                stdio: 'inherit',
                env: claudeEnv
            });
            
            // Track Claude process for cleanup
            const claudeCleanup = () => {
                cleanup(); // Original cleanup
                if (claudeProcess && !claudeProcess.killed) {
                    try {
                        claudeProcess.kill('SIGTERM');
                        setTimeout(() => {
                            if (!claudeProcess.killed) {
                                claudeProcess.kill('SIGKILL');
                            }
                        }, 5000);
                    } catch (error) {
                        // Ignore cleanup errors
                    }
                }
            };
            
            // Update cleanup handlers for Claude process
            process.removeAllListeners('SIGINT');
            process.removeAllListeners('SIGTERM');
            process.on('SIGINT', () => {
                claudeCleanup();
                process.exit(0);
            });
            process.on('SIGTERM', () => {
                claudeCleanup();
                process.exit(0);
            });
            
            claudeProcess.on('close', (code) => {
                claudeCleanup();
                process.exit(code);
            });
            
            claudeProcess.on('error', (error) => {
                console.error('❌ Failed to launch Claude:', error.message);
                console.error('');
                
                // Enhanced WSL2 error handling
                const platformInfo = detectPlatformInfo();
                if (platformInfo.isWSL2 && error.message.includes('ENOENT')) {
                    console.error('🐧 WSL2 Environment Detected - PATH Issue Likely');
                    console.error('');
                    console.error('🚀 Quick WSL2 Fixes:');
                    
                    const npmGlobalBin = getNpmGlobalBin();
                    if (npmGlobalBin) {
                        console.error(`   1. export PATH="${npmGlobalBin}:$PATH"`);
                    } else {
                        console.error('   1. export PATH="$(npm bin -g):$PATH"');
                    }
                    console.error('   2. source ~/.bashrc');
                    console.error('   3. claude-pm  # try again');
                    console.error('');
                    console.error('🔧 Permanent WSL2 Fix:');
                    if (npmGlobalBin) {
                        console.error(`   echo 'export PATH="${npmGlobalBin}:$PATH"' >> ~/.bashrc`);
                    } else {
                        console.error('   echo \'export PATH="$(npm bin -g):$PATH"\' >> ~/.bashrc');
                    }
                    console.error('   source ~/.bashrc');
                    console.error('');
                    console.error('🔍 WSL2 Diagnostic:');
                    console.error('   ~/.claude-pm/wsl2-diagnostic.sh');
                    console.error('');
                }
                
                console.error('🔧 General Troubleshooting Steps:');
                console.error('   1. Verify Claude CLI is installed: claude --version');
                console.error('   2. Check PATH configuration: echo $PATH');
                console.error('   3. Reinstall Claude CLI: https://claude.ai/download');
                console.error('   4. Restart your terminal and try again');
                console.error('');
                claudeCleanup();
                process.exit(1);
            });
            
            return;
        } catch (error) {
            console.error('❌ Failed to launch Claude:', error.message);
            console.error('');
            
            // Enhanced WSL2 error handling for catch block
            const platformInfo = detectPlatformInfo();
            if (platformInfo.isWSL2) {
                console.error('🐧 WSL2 Environment Detected');
                console.error('');
                console.error('🚀 WSL2-Specific Solutions:');
                
                const npmGlobalBin = getNpmGlobalBin();
                if (npmGlobalBin) {
                    console.error(`   • export PATH="${npmGlobalBin}:$PATH"`);
                } else {
                    console.error('   • export PATH="$(npm bin -g):$PATH"');
                }
                console.error('   • source ~/.bashrc');
                console.error('   • Run: ~/.claude-pm/wsl2-diagnostic.sh');
                console.error('');
            }
            
            console.error('🔧 Common Solutions:');
            console.error('   • Install Claude CLI: https://claude.ai/download');
            console.error('   • Add Claude CLI to your PATH');
            console.error('   • Restart your terminal');
            console.error('   • Update to latest Claude CLI version');
            console.error('');
            cleanup();
            process.exit(1);
        }
    }
    
    // Handle deployment detection debug flag
    if (args.includes('--deployment-info')) {
        const deploymentConfig = getDeploymentConfig();
        console.log('\n🔍 Claude PM Framework Deployment Detection Results:');
        console.log('=' .repeat(60));
        console.log(JSON.stringify(deploymentConfig, null, 2));
        process.exit(0);
    }
    
    // Handle system info display flag
    if (args.includes('--system-info')) {
        displaySystemInfo();
        process.exit(0);
    }
    
    // Handle manual CLAUDE.md deployment command with enhanced diagnostics
    if (args.includes('deploy-template') || args.includes('--deploy-template')) {
        console.log('🚀 Manually deploying CLAUDE.md template...');
        const verbose = args.includes('--verbose') || args.includes('-v');
        
        try {
            const deployed = await handleAutomaticClaudeMdDeployment();
            if (deployed) {
                console.log('✅ CLAUDE.md template deployed successfully');
            } else {
                console.log('ℹ️  No deployment needed - checking why...');
                
                // Enhanced diagnostics
                const workingDir = process.cwd();
                const claudeMdPath = path.join(workingDir, 'CLAUDE.md');
                const globalConfigDir = path.join(os.homedir(), '.claude-pm');
                const globalDeploymentInfoPath = path.join(globalConfigDir, 'global-deployment.json');
                
                console.log('\n📊 Deployment Diagnostics:');
                console.log(`   • Working directory: ${workingDir}`);
                console.log(`   • CLAUDE.md exists: ${fs.existsSync(claudeMdPath)}`);
                console.log(`   • Global config exists: ${fs.existsSync(globalDeploymentInfoPath)}`);
                console.log(`   • Is project directory: ${isProjectDirectory(workingDir)}`);
                
                if (fs.existsSync(claudeMdPath)) {
                    const content = fs.readFileSync(claudeMdPath, 'utf8');
                    const isFramework = content.includes('Claude PM Framework Configuration') || 
                                       content.includes('AI ASSISTANT ROLE DESIGNATION');
                    console.log(`   • CLAUDE.md type: ${isFramework ? 'Framework template' : 'Custom/User file'}`);
                }
                
                if (fs.existsSync(globalDeploymentInfoPath)) {
                    try {
                        const globalInfo = JSON.parse(fs.readFileSync(globalDeploymentInfoPath, 'utf8'));
                        console.log(`   • Global deployment version: ${globalInfo.version || 'Unknown'}`);
                        console.log(`   • Framework template path: ${globalInfo.frameworkTemplatePath || 'Not set'}`);
                        console.log(`   • Template exists: ${fs.existsSync(globalInfo.frameworkTemplatePath || '')}`);
                    } catch (parseError) {
                        console.log(`   • Global config parse error: ${parseError.message}`);
                    }
                }
                
                console.log('\n💡 Troubleshooting suggestions:');
                if (!isProjectDirectory(workingDir)) {
                    console.log('   • Try running this command in a project directory (contains package.json, .git, etc.)');
                }
                
                if (fs.existsSync(claudeMdPath)) {
                    const content = fs.readFileSync(claudeMdPath, 'utf8');
                    const isFramework = content.includes('Claude PM Framework Configuration');
                    if (!isFramework) {
                        console.log('   • CLAUDE.md appears to be a custom file - deployment skipped to preserve it');
                        console.log('   • To force deployment, backup and delete the existing CLAUDE.md first');
                    } else {
                        console.log('   • CLAUDE.md appears to be up-to-date framework template');
                    }
                }
                
                if (!fs.existsSync(globalDeploymentInfoPath)) {
                    console.log('   • Global deployment info missing - try reinstalling: npm install -g @bobmatnyc/claude-multiagent-pm');
                } else {
                    const globalInfo = JSON.parse(fs.readFileSync(globalDeploymentInfoPath, 'utf8'));
                    if (!fs.existsSync(globalInfo.frameworkTemplatePath || '')) {
                        console.log('   • Framework template missing - try reinstalling: npm install -g @bobmatnyc/claude-multiagent-pm');
                    }
                }
                
                console.log('   • Try the failsafe script: ~/.claude-pm/deploy-claude-md.sh');
            }
        } catch (error) {
            console.error(`❌ Template deployment error: ${error.message}`);
            console.error('\n🔧 Fallback options:');
            console.error('   1. Try the failsafe script: ~/.claude-pm/deploy-claude-md.sh');
            console.error('   2. Reinstall the package: npm install -g @bobmatnyc/claude-multiagent-pm');
            console.error('   3. Check your npm global path: npm config get prefix');
            
            if (verbose) {
                console.error('\n📊 Error details:');
                console.error(`   • Error stack: ${error.stack}`);
            }
        }
        process.exit(0);
    }

    // Handle framework CLAUDE.md management flag
    if (args.includes('--manage-claude-md')) {
        console.log('🧹 Managing framework CLAUDE.md deployment tree...');
        try {
            const result = await manageFrameworkClaudeMd();
            console.log('\n📊 Framework CLAUDE.md Management Result:');
            console.log('=' .repeat(50));
            console.log(`Action: ${result.action}`);
            console.log(`Reason: ${result.reason}`);
            if (result.frameworkFiles !== undefined) {
                console.log(`Framework files found: ${result.frameworkFiles}`);
            }
            if (result.userFiles !== undefined) {
                console.log(`User files preserved: ${result.userFiles}`);
            }
            if (result.processedFiles) {
                console.log(`Processed files: ${result.processedFiles.join(', ')}`);
            }
            if (result.topLevelFile) {
                console.log(`Top-level framework file: ${result.topLevelFile}`);
            }
        } catch (error) {
            console.error(`❌ Framework management error: ${error.message}`);
        }
        process.exit(0);
    }
    
    // Handle CMPM-105 integrated commands
    if (args.includes('--template-status')) {
        const deploymentConfig = getDeploymentConfig();
        handleTemplateStatus(deploymentConfig);
        process.exit(0);
    }
    
    if (args.includes('--dependency-status')) {
        const deploymentConfig = getDeploymentConfig();
        handleDependencyStatus(deploymentConfig);
        process.exit(0);
    }
    
    if (args.includes('--parent-directory-status')) {
        const deploymentConfig = getDeploymentConfig();
        handleParentDirectoryStatus(deploymentConfig);
        process.exit(0);
    }

    // Handle Claude CLI validation command
    if (args.includes('--claude-info')) {
        console.log('🔍 Claude CLI Detailed Validation:');
        console.log('=' .repeat(50));
        
        const claudeValidator = new ClaudeCliValidator();
        
        try {
            const validation = await claudeValidator.validateEnvironment();
            
            if (validation.valid) {
                console.log(`✅ Claude CLI Status: Working`);
                console.log(`   Version: ${validation.version}`);
                console.log(`   Features:`);
                console.log(`     • Model Selection: ${validation.features.modelOption ? '✅' : '❌'}`);
                console.log(`     • Skip Permissions: ${validation.features.skipPermissions ? '✅' : '❌'}`);
                console.log(`   Command: ${validation.command.join(' ')}`);
                
                if (validation.fallbackReason) {
                    console.log(`   Fallback Reason: ${validation.fallbackReason}`);
                }
            } else {
                console.log('❌ Claude CLI Status: Not Working');
                claudeValidator.displayErrorGuidance(validation);
            }
        } catch (error) {
            console.error(`❌ Validation Error: ${error.message}`);
        }
        
        process.exit(0);
    }

    // Handle environment status command
    if (args.includes('--env-status')) {
        displayEnvironmentStatus();
        process.exit(0);
    }

    // Handle troubleshooting command
    if (args.includes('--troubleshoot')) {
        console.log('\n🔧 Claude PM Framework Troubleshooting Guide:');
        console.log('=' .repeat(60));
        console.log('');
        console.log('🚨 Common Issues and Solutions:');
        console.log('');
        console.log('1️⃣  Claude CLI Startup Errors:');
        console.log('   Problem: "Unknown option --model" or similar errors');
        console.log('   Solution: Update to latest Claude CLI version');
        console.log('   Command: Run --claude-info to check compatibility');
        console.log('');
        console.log('2️⃣  Installation Issues:');
        console.log('   Problem: "claude-pm command not found"');
        console.log('   Solution: Reinstall via npm: npm install -g @bobmatnyc/claude-multiagent-pm');
        console.log('   Verify: Run claude-pm --version');
        console.log('');
        console.log('3️⃣  Python Environment:');
        console.log('   Problem: Python-related errors during execution');
        console.log('   Solution: Ensure Python 3.8+ is installed');
        console.log('   Command: python3 --version');
        console.log('');
        console.log('4️⃣  Framework Detection:');
        console.log('   Problem: Framework not found or path issues');
        console.log('   Solution: Check deployment info');
        console.log('   Command: claude-pm --deployment-info');
        console.log('');
        console.log('5️⃣  Memory Issues:');
        console.log('   Problem: High memory usage or crashes');
        console.log('   Solution: Increase Node.js memory limit');
        console.log('   Command: export NODE_OPTIONS="--max-old-space-size=8192"');
        console.log('');
        console.log('📚 Additional Resources:');
        console.log('   • Framework Documentation: https://github.com/bobmatnyc/claude-pm');
        console.log('   • Claude CLI: https://claude.ai/download');
        console.log('   • Issue Reports: https://github.com/bobmatnyc/claude-pm/issues');
        console.log('');
        console.log('🔍 Diagnostic Commands:');
        console.log('   claude-pm --system-info     # System information');
        console.log('   claude-pm --env-status      # Environment validation');
        console.log('   claude-pm --claude-info     # Claude CLI details');
        console.log('   claude-pm --deployment-info # Deployment detection');
        console.log('');
        
        process.exit(0);
    }
    
    // Validate environment
    const pythonCmd = validatePython();
    const deploymentStrategy = deploymentDetector.getDeploymentStrategy();
    
    if (deploymentStrategy.strategy === 'install_required') {
        console.error('❌ Claude PM Framework not found');
        console.error('Please install the framework:');
        console.error(`   ${deploymentStrategy.recommendation}`);
        process.exit(1);
    }
    
    const frameworkPath = deploymentStrategy.config.frameworkPath;
    const cliModulePath = deploymentStrategy.config.claudePmPath;
    
    // Validate CLI module exists
    if (!fs.existsSync(cliModulePath)) {
        console.error(`❌ Framework CLI module not found at: ${cliModulePath}`);
        console.error(`   Deployment type: ${deploymentStrategy.config.deploymentType}`);
        console.error(`   Framework path: ${frameworkPath}`);
        console.error(`   Try running: claude-pm --deployment-info`);
        process.exit(1);
    }
    
    // Enhanced environment setup based on deployment strategy with memory optimization
    const enhancedEnv = {
        ...process.env,
        ...deploymentStrategy.environmentSetup,
        CLAUDE_PM_VERSION: CLAUDE_PM_VERSION,
        CLAUDE_PM_DEPLOYMENT_TYPE: deploymentStrategy.config.deploymentType,
        CLAUDE_PM_DEPLOYMENT_CONFIDENCE: deploymentStrategy.config.confidence,
        // FIXED: Add explicit deployment directory for Python integration
        CLAUDE_PM_DEPLOYMENT_DIR: frameworkPath,
        CLAUDE_PM_WORKING_DIR: process.cwd(),
        // Memory optimization flags
        NODE_OPTIONS: '--max-old-space-size=8192',
        // Enable garbage collection if available
        NODE_GC: '1'
    };
    
    // Ensure proper PYTHONPATH setup
    const pythonPath = enhancedEnv.PYTHONPATH;
    if (pythonPath && !pythonPath.includes(frameworkPath)) {
        enhancedEnv.PYTHONPATH = frameworkPath + (pythonPath ? ':' + pythonPath : '');
    } else if (!pythonPath) {
        enhancedEnv.PYTHONPATH = frameworkPath;
    }
    
    // FIXED: Handle automatic CLAUDE.md deployment for global installations
    await handleAutomaticClaudeMdDeployment();
    
    // FIXED: Handle Python script updates and deployment
    await handlePythonScriptDeployment(frameworkPath, enhancedEnv);
    
    // FIXED: Handle agent profile deployment
    await handleAgentProfileDeployment(frameworkPath, enhancedEnv);
    
    // FIXED: Handle project deployment completion
    await handleProjectDeployment(deploymentStrategy, args);
    
    // Execute Python CLI module with enhanced environment and memory management
    const pythonProcess = spawn(pythonCmd, ['-m', 'claude_pm.cli', ...args], {
        stdio: 'inherit',
        env: enhancedEnv,
        cwd: frameworkPath
    });
    
    // Track spawned process for cleanup
    const spawnedProcesses = [pythonProcess];
    
    // Enhanced cleanup function that includes spawned processes
    const enhancedCleanup = () => {
        cleanup(); // Original cleanup
        
        // Kill any spawned processes
        spawnedProcesses.forEach(proc => {
            if (proc && !proc.killed) {
                try {
                    proc.kill('SIGTERM');
                    // Force kill after timeout
                    setTimeout(() => {
                        if (!proc.killed) {
                            proc.kill('SIGKILL');
                        }
                    }, 5000);
                } catch (error) {
                    // Ignore errors when killing processes
                }
            }
        });
    };
    
    // Update cleanup handlers to include process cleanup
    process.removeAllListeners('SIGINT');
    process.removeAllListeners('SIGTERM');
    process.on('SIGINT', () => {
        enhancedCleanup();
        process.exit(0);
    });
    process.on('SIGTERM', () => {
        enhancedCleanup();
        process.exit(0);
    });
    
    pythonProcess.on('close', (code) => {
        enhancedCleanup();
        process.exit(code);
    });
    
    pythonProcess.on('error', (error) => {
        console.error('❌ Failed to execute Claude PM Framework:', error.message);
        console.error(`   Deployment type: ${deploymentStrategy.config.deploymentType}`);
        console.error(`   Framework path: ${frameworkPath}`);
        console.error(`   Python command: ${pythonCmd}`);
        console.error(`   Try running: claude-pm --deployment-info`);
        enhancedCleanup();
        process.exit(1);
    });
}

// Execute main function
if (require.main === module) {
    main().catch((error) => {
        console.error('❌ CLI execution error:', error.message);
        process.exit(1);
    });
}

/**
 * CMPM-105 Integration: Handle template management status
 */
function handleTemplateStatus(deploymentConfig) {
    console.log('\n📄 Template Management Status (CMPM-102):');
    console.log('=' .repeat(60));
    
    try {
        const pythonCmd = validatePython();
        const frameworkPath = deploymentConfig.config.frameworkPath;
        
        // Execute template manager status command
        const { spawn } = require('child_process');
        const templateProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.template_manager import TemplateManager
import asyncio
import json

async def get_status():
    try:
        manager = TemplateManager()
        await manager._initialize()
        templates = await manager.list_templates()
        status = {
            "initialized": True,
            "template_count": len(templates),
            "templates": templates[:5],  # Show first 5
            "deployment_type": "${deploymentConfig.config.deploymentType}"
        }
        print(json.dumps(status, indent=2, default=str))
    except Exception as e:
        print(json.dumps({"error": str(e), "initialized": False}, indent=2))

asyncio.run(get_status())
        `], {
            stdio: 'inherit',
            env: {
                ...process.env,
                PYTHONPATH: frameworkPath,
                CLAUDE_PM_FRAMEWORK_PATH: frameworkPath
            },
            cwd: frameworkPath
        });
        
        templateProcess.on('error', (error) => {
            console.error('❌ Template Manager Error:', error.message);
        });
        
    } catch (error) {
        console.error('❌ Template Status Error:', error.message);
    }
}

/**
 * CMPM-105 Integration: Handle dependency management status
 */
function handleDependencyStatus(deploymentConfig) {
    console.log('\n📦 Dependency Management Status (CMPM-103):');
    console.log('=' .repeat(60));
    
    try {
        const pythonCmd = validatePython();
        const frameworkPath = deploymentConfig.config.frameworkPath;
        
        // Execute dependency manager status command
        const { spawn } = require('child_process');
        const dependencyProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.dependency_manager import DependencyManager
import asyncio
import json

async def get_status():
    try:
        manager = DependencyManager()
        await manager._initialize()
        dependencies = manager.get_dependencies()
        report = await manager.generate_dependency_report()
        status = {
            "initialized": True,
            "dependencies_tracked": len(dependencies),
            "health_score": report.health_score,
            "missing_dependencies": report.missing_dependencies,
            "deployment_type": "${deploymentConfig.config.deploymentType}"
        }
        print(json.dumps(status, indent=2, default=str))
    except Exception as e:
        print(json.dumps({"error": str(e), "initialized": False}, indent=2))

asyncio.run(get_status())
        `], {
            stdio: 'inherit',
            env: {
                ...process.env,
                PYTHONPATH: frameworkPath,
                CLAUDE_PM_FRAMEWORK_PATH: frameworkPath
            },
            cwd: frameworkPath
        });
        
        dependencyProcess.on('error', (error) => {
            console.error('❌ Dependency Manager Error:', error.message);
        });
        
    } catch (error) {
        console.error('❌ Dependency Status Error:', error.message);
    }
}

/**
 * CMPM-105 Integration: Handle parent directory management status
 */
function handleParentDirectoryStatus(deploymentConfig) {
    console.log('\n📁 Parent Directory Management Status (CMPM-104):');
    console.log('=' .repeat(60));
    
    try {
        const pythonCmd = validatePython();
        const frameworkPath = deploymentConfig.config.frameworkPath;
        
        // Execute parent directory manager status command
        const { spawn } = require('child_process');
        const parentDirProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.parent_directory_manager import ParentDirectoryManager
import asyncio
import json

async def get_status():
    try:
        manager = ParentDirectoryManager()
        await manager._initialize()
        directories = await manager.list_managed_directories()
        status = {
            "initialized": True,
            "managed_directories": len(directories),
            "directories": directories[:3],  # Show first 3
            "deployment_type": "${deploymentConfig.config.deploymentType}"
        }
        print(json.dumps(status, indent=2, default=str))
    except Exception as e:
        print(json.dumps({"error": str(e), "initialized": False}, indent=2))

asyncio.run(get_status())
        `], {
            stdio: 'inherit',
            env: {
                ...process.env,
                PYTHONPATH: frameworkPath,
                CLAUDE_PM_FRAMEWORK_PATH: frameworkPath
            },
            cwd: frameworkPath
        });
        
        parentDirProcess.on('error', (error) => {
            console.error('❌ Parent Directory Manager Error:', error.message);
        });
        
    } catch (error) {
        console.error('❌ Parent Directory Status Error:', error.message);
    }
}

/**
 * Enhanced automatic CLAUDE.md deployment for global installations
 */
async function handleAutomaticClaudeMdDeployment() {
    try {
        const globalConfigDir = path.join(os.homedir(), '.claude-pm');
        const globalDeploymentInfoPath = path.join(globalConfigDir, 'global-deployment.json');
        
        // Check if we have global deployment info
        if (!fs.existsSync(globalDeploymentInfoPath)) {
            // Try to create global deployment info from current deployment config
            const deploymentConfig = deploymentDetector.getDeploymentStrategy();
            if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
                if (deploymentConfig.config.deploymentType === 'npm_global') {
                    await createGlobalDeploymentInfo(deploymentConfig.config.frameworkPath);
                    // Retry with newly created info
                    if (fs.existsSync(globalDeploymentInfoPath)) {
                        return await handleAutomaticClaudeMdDeployment();
                    }
                }
            }
            return false; // No global deployment info available
        }
        
        const globalInfo = JSON.parse(fs.readFileSync(globalDeploymentInfoPath, 'utf8'));
        const workingDir = process.cwd();
        const workingClaudemd = path.join(workingDir, 'CLAUDE.md');
        
        // Enhanced logic: Deploy if needed regardless of needsFirstRunDeployment flag
        const shouldDeploy = shouldDeployClaudemd(workingDir, workingClaudemd, globalInfo);
        
        if (!shouldDeploy) {
            return false;
        }
        
        // Enhanced framework template path resolution
        const frameworkTemplate = findFrameworkTemplate(globalInfo);
        if (!frameworkTemplate) {
            console.log('⚠️  Framework template not found for auto-deployment');
            return false;
        }
        
        // Deploy CLAUDE.md to working directory
        console.log('🚀 Auto-deploying CLAUDE.md from global installation...');
        
        let templateContent = fs.readFileSync(frameworkTemplate, 'utf8');
        const packageJsonPath = findPackageJson(frameworkTemplate);
        const packageJson = packageJsonPath ? require(packageJsonPath) : { version: '0.5.3' };
        
        const deploymentDate = new Date().toISOString();
        const deploymentId = Date.now();
        
        // Template variable replacements
        const replacements = {
            '{{CLAUDE_MD_VERSION}}': `${packageJson.version}-001`,
            '{{FRAMEWORK_VERSION}}': packageJson.version,
            '{{DEPLOYMENT_DATE}}': deploymentDate,
            '{{LAST_UPDATED}}': deploymentDate,
            '{{DEPLOYMENT_DIR}}': workingDir,
            '{{PLATFORM}}': os.platform(),
            '{{PYTHON_CMD}}': 'python3',
            '{{AI_TRACKDOWN_PATH}}': 'Global installation available',
            '{{DEPLOYMENT_ID}}': deploymentId,
            '{{PLATFORM_NOTES}}': getPlatformNotes(os.platform())
        };
        
        // Apply template variable substitutions
        for (const [placeholder, value] of Object.entries(replacements)) {
            const escapedPlaceholder = placeholder.replace(/[{}]/g, '\\$&');
            templateContent = templateContent.replace(new RegExp(escapedPlaceholder, 'g'), value);
        }
        
        // Write the deployed CLAUDE.md
        fs.writeFileSync(workingClaudemd, templateContent);
        console.log(`✅ Framework CLAUDE.md deployed to: ${workingClaudemd}`);
        
        // Update global deployment info
        globalInfo.lastDeploymentDate = deploymentDate;
        globalInfo.lastDeploymentDir = workingDir;
        globalInfo.deploymentCount = (globalInfo.deploymentCount || 0) + 1;
        
        fs.writeFileSync(globalDeploymentInfoPath, JSON.stringify(globalInfo, null, 2));
        
        return true;
        
    } catch (error) {
        console.log(`⚠️  Auto-deployment failed: ${error.message}`);
        return false;
    }
}

/**
 * Helper function to determine if CLAUDE.md should be deployed
 */
function shouldDeployClaudemd(workingDir, workingClaudemd, globalInfo) {
    // Check if we're in a project directory
    if (!isProjectDirectory(workingDir)) {
        return false;
    }
    
    // Check if CLAUDE.md already exists
    if (fs.existsSync(workingClaudemd)) {
        const content = fs.readFileSync(workingClaudemd, 'utf8');
        const isFrameworkFile = content.includes('Claude PM Framework Configuration - Deployment') || 
                              content.includes('AI ASSISTANT ROLE DESIGNATION');
        
        if (!isFrameworkFile) {
            // User has custom CLAUDE.md, don't override
            return false;
        }
        
        // It's a framework file - check if it needs updating
        const versionMatch = content.match(/CLAUDE_MD_VERSION:\s*([\d\.-]+)/);
        const currentVersion = versionMatch ? versionMatch[1] : null;
        const latestVersion = globalInfo.version || '0.5.3';
        
        if (currentVersion && currentVersion.startsWith(latestVersion)) {
            // Already up to date
            return false;
        }
    }
    
    return true;
}

/**
 * Helper function to check if directory is project-like
 */
function isProjectDirectory(dir) {
    try {
        const contents = fs.readdirSync(dir);
        const projectIndicators = [
            'package.json', '.git', 'README.md', 'src', 'lib', 'components', 
            'pages', 'app', 'server', 'client', 'public', 'assets'
        ];
        
        return projectIndicators.some(indicator => contents.includes(indicator));
    } catch (error) {
        return false;
    }
}

/**
 * Helper function to find framework template
 */
function findFrameworkTemplate(globalInfo) {
    const possiblePaths = [
        globalInfo.frameworkTemplatePath,
        path.join(globalInfo.packageRoot || '', 'framework', 'CLAUDE.md'),
        path.join(path.dirname(globalInfo.packageRoot || ''), 'framework', 'CLAUDE.md')
    ].filter(Boolean);
    
    for (const templatePath of possiblePaths) {
        if (fs.existsSync(templatePath)) {
            return templatePath;
        }
    }
    
    return null;
}

/**
 * Helper function to find package.json
 */
function findPackageJson(frameworkTemplatePath) {
    const possiblePaths = [
        path.join(path.dirname(frameworkTemplatePath), '..', 'package.json'),
        path.join(path.dirname(frameworkTemplatePath), 'package.json'),
        path.join(path.dirname(frameworkTemplatePath), '..', '..', 'package.json')
    ];
    
    for (const packagePath of possiblePaths) {
        if (fs.existsSync(packagePath)) {
            return packagePath;
        }
    }
    
    return null;
}

/**
 * Helper function to create global deployment info
 */
async function createGlobalDeploymentInfo(frameworkPath) {
    try {
        const globalConfigDir = path.join(os.homedir(), '.claude-pm');
        const globalDeploymentInfoPath = path.join(globalConfigDir, 'global-deployment.json');
        
        await fs.promises.mkdir(globalConfigDir, { recursive: true });
        
        const globalDeploymentInfo = {
            installationType: 'global',
            packageRoot: frameworkPath,
            npmPrefix: process.env.npm_config_prefix,
            frameworkTemplatePath: path.join(frameworkPath, 'framework', 'CLAUDE.md'),
            deploymentDate: new Date().toISOString(),
            version: CLAUDE_PM_VERSION,
            platform: os.platform(),
            needsFirstRunDeployment: true
        };
        
        fs.writeFileSync(globalDeploymentInfoPath, JSON.stringify(globalDeploymentInfo, null, 2));
        
    } catch (error) {
        // Silent failure - don't break CLI
    }
}

/**
 * Get platform-specific notes for template deployment
 */
function getPlatformNotes(platform) {
    switch (platform) {
        case 'darwin':
            return '**macOS-specific:**\n- Use `.sh` files for scripts\n- CLI wrappers: `bin/aitrackdown` and `bin/atd`\n- Health check: `scripts/health-check.sh`\n- May require Xcode Command Line Tools';
        case 'linux':
            return '**Linux-specific:**\n- Use `.sh` files for scripts\n- CLI wrappers: `bin/aitrackdown` and `bin/atd`\n- Health check: `scripts/health-check.sh`\n- Ensure proper file permissions';
        case 'win32':
            return '**Windows-specific:**\n- Use `.bat` files for scripts\n- CLI wrappers: `bin/aitrackdown.bat` and `bin/atd.bat`\n- Health check: `scripts/health-check.bat`\n- Path separators: Use backslashes in Windows paths';
        default:
            return `**Platform**: ${platform}\n- Use appropriate script extensions for your platform\n- Ensure proper file permissions on CLI wrappers`;
    }
}

/**
 * CMCP-105 Integration: Handle Python script deployment
 */
async function handlePythonScriptDeployment(frameworkPath, environment) {
    try {
        // Check if Python scripts need updates
        const pythonScriptPath = path.join(frameworkPath, 'claude_pm');
        
        if (!fs.existsSync(pythonScriptPath)) {
            console.log('⚠️  Python scripts not found, may need installation');
            return;
        }
        
        // Validate Python environment
        const pythonCmd = validatePython();
        
        // Check if Python dependencies are installed
        const { spawn } = require('child_process');
        const checkProcess = spawn(pythonCmd, ['-c', 'import claude_pm; print("OK")'], {
            env: environment,
            cwd: frameworkPath,
            stdio: 'pipe'
        });
        
        return new Promise((resolve) => {
            let output = '';
            
            checkProcess.stdout.on('data', (data) => {
                output += data.toString();
            });
            
            checkProcess.on('close', (code) => {
                if (code === 0 && output.includes('OK')) {
                    // Python integration is working
                    resolve();
                } else {
                    console.log('⚠️  Python integration may need setup');
                    resolve();
                }
            });
            
            // Timeout after 5 seconds
            setTimeout(() => {
                checkProcess.kill();
                resolve();
            }, 5000);
        });
        
    } catch (error) {
        // Silent failure - don't break CLI
        return;
    }
}

/**
 * CMPM-105 Integration: Handle project deployment completion
 */
async function handleProjectDeployment(deploymentConfig, args) {
    try {
        // Check if this is a project-specific operation
        const isProjectSpecific = args.some(arg => 
            ['project', 'init', 'setup', 'deploy'].includes(arg)
        );
        
        if (!isProjectSpecific) {
            return;
        }
        
        const frameworkPath = deploymentConfig.config.frameworkPath;
        const workingDir = process.cwd();
        
        // Create project-specific deployment structure if needed
        const projectClaudePmDir = path.join(workingDir, '.claude-pm');
        
        if (!fs.existsSync(projectClaudePmDir)) {
            fs.mkdirSync(projectClaudePmDir, { recursive: true });
            
            // Create basic project configuration
            const projectConfig = {
                project_type: "managed",
                framework_path: frameworkPath,
                deployment_date: new Date().toISOString(),
                version: deploymentConfig.config.version || "4.5.1"
            };
            
            fs.writeFileSync(
                path.join(projectClaudePmDir, 'config.json'),
                JSON.stringify(projectConfig, null, 2)
            );
        }
        
    } catch (error) {
        // Silent failure - don't break CLI
        return;
    }
}

/**
 * CMPM-105 Integration: Handle agent profile deployment
 */
async function handleAgentProfileDeployment(frameworkPath, environment) {
    try {
        const workingDir = process.cwd();
        
        // Check if agent profile loader service exists
        const profileLoaderPath = path.join(frameworkPath, 'claude_pm', 'services', 'agent_profile_loader.py');
        
        if (!fs.existsSync(profileLoaderPath)) {
            // Profile loader not available, skip deployment
            return;
        }
        
        // Validate Python environment
        const pythonCmd = validatePython();
        
        // Execute profile deployment
        const { spawn } = require('child_process');
        const profileProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.agent_profile_loader import AgentProfileLoader
import asyncio
import json
from pathlib import Path

async def deploy_profiles():
    try:
        loader = AgentProfileLoader(working_directory=Path('${workingDir}'))
        await loader.initialize()
        
        # Create profile deployment structure
        structure_results = await loader.create_profile_deployment_structure()
        
        # Deploy system profiles as project defaults
        deployment_results = await loader.deploy_system_profiles()
        
        # List available profiles
        available_profiles = await loader.list_available_profiles()
        
        results = {
            "structure_created": structure_results,
            "profiles_deployed": deployment_results,
            "available_profiles": {tier.value: profiles for tier, profiles in available_profiles.items()},
            "deployment_successful": True
        }
        
        print(json.dumps(results, indent=2, default=str))
        
    except Exception as e:
        error_result = {
            "deployment_successful": False,
            "error": str(e),
            "fallback": "Profile deployment skipped - will use runtime loading"
        }
        print(json.dumps(error_result, indent=2))

asyncio.run(deploy_profiles())
        `], {
            stdio: 'pipe',
            env: environment,
            cwd: frameworkPath,
            timeout: 15000  // 15 second timeout
        });
        
        return new Promise((resolve) => {
            let output = '';
            let errorOutput = '';
            
            profileProcess.stdout.on('data', (data) => {
                output += data.toString();
            });
            
            profileProcess.stderr.on('data', (data) => {
                errorOutput += data.toString();
            });
            
            profileProcess.on('close', (code) => {
                try {
                    if (code === 0 && output.trim()) {
                        const results = JSON.parse(output.trim());
                        
                        if (results.deployment_successful) {
                            const deployedCount = Object.values(results.profiles_deployed || {}).filter(Boolean).length;
                            if (deployedCount > 0) {
                                console.log(`🤖 Agent profiles deployed: ${deployedCount} system profiles available`);
                            }
                        }
                    }
                } catch (parseError) {
                    // Silent fallback - profile deployment is non-critical
                }
                
                resolve();
            });
            
            // Timeout fallback
            setTimeout(() => {
                if (!profileProcess.killed) {
                    profileProcess.kill();
                }
                resolve();
            }, 15000);
        });
        
    } catch (error) {
        // Silent failure - don't break CLI if profile deployment fails
        return;
    }
}

/**
 * Enhanced environment validation with Claude CLI compatibility checking
 */
function validateEnvironment() {
    const validation = {
        python: null,
        claude: null,
        overall: true,
        errors: [],
        warnings: []
    };
    
    // Validate Python
    try {
        validation.python = validatePython();
    } catch (error) {
        validation.python = null;
        validation.overall = false;
        validation.errors.push(`Python validation failed: ${error.message}`);
    }
    
    // Note: Claude validation is async and handled separately
    validation.warnings.push('Claude CLI validation requires async operation - use ClaudeCliValidator directly');
    
    return validation;
}

/**
 * Quick Claude CLI availability check (synchronous)
 */
function quickClaudeCheck() {
    try {
        const { execSync } = require('child_process');
        execSync('claude --version', { stdio: 'pipe', timeout: 3000 });
        return { available: true };
    } catch (error) {
        return { 
            available: false, 
            error: error.message,
            suggestion: 'Install Claude CLI from https://claude.ai/download'
        };
    }
}

/**
 * Display comprehensive environment status
 */
function displayEnvironmentStatus() {
    console.log('\n🔍 Environment Validation Summary:');
    console.log('=' .repeat(50));
    
    const validation = validateEnvironment();
    
    // Python status
    if (validation.python) {
        console.log(`✅ Python: ${validation.python} (compatible)`);
    } else {
        console.log('❌ Python: Not available or incompatible');
    }
    
    // Claude CLI status (quick check)
    const claudeCheck = quickClaudeCheck();
    if (claudeCheck.available) {
        console.log('✅ Claude CLI: Available (use --claude-info for detailed validation)');
    } else {
        console.log(`❌ Claude CLI: ${claudeCheck.error}`);
        console.log(`   → ${claudeCheck.suggestion}`);
    }
    
    // Overall status
    if (validation.overall && claudeCheck.available) {
        console.log('\n🎯 Environment Status: Ready for framework operations');
    } else {
        console.log('\n⚠️  Environment Status: Issues detected');
        validation.errors.forEach(error => {
            console.log(`   • ${error}`);
        });
    }
    
    console.log('');
}

module.exports = { 
    main, 
    getFrameworkPath, 
    getDeploymentConfig, 
    validatePython, 
    validateEnvironment,
    quickClaudeCheck,
    displayEnvironmentStatus,
    DeploymentDetector,
    ClaudeCliValidator,
    handleTemplateStatus,
    handleDependencyStatus,
    handleParentDirectoryStatus,
    handlePythonScriptDeployment,
    handleProjectDeployment,
    handleAgentProfileDeployment
};
