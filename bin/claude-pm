#!/usr/bin/env python3
"""
Claude Multi-Agent PM Framework - Pure Python CLI Entry Point

This is the pure Python implementation that replaces the mixed JavaScript/Python
architecture. All CLI functionality is now implemented in Python using Click.
"""

import sys
import os
import subprocess
from pathlib import Path

# Script version - tracks claude-pm script updates independently
def get_script_version():
    """Get script version from bin/VERSION file."""
    version_file = Path(__file__).parent / "VERSION"
    if version_file.exists():
        try:
            return version_file.read_text().strip()
        except OSError:
            pass
    return "1.0.0"  # Fallback

SCRIPT_VERSION = get_script_version()

# Add the framework path to Python path for imports
# For deployed scripts, look for framework in ~/.claude-pm/framework
if Path(__file__).parent == Path.home() / ".claude-pm" / "bin":
    # Deployed in ~/.claude-pm/bin - framework is at ~/.claude-pm/framework
    framework_path = Path.home() / ".claude-pm"
else:
    # Development mode - framework is parent directory
    framework_path = Path(__file__).parent.parent

sys.path.insert(0, str(framework_path))

try:
    import click
    from rich.console import Console
except ImportError:
    print("‚ùå Missing required dependencies. Please install:")
    print("   pip install click rich")
    sys.exit(1)

console = Console()


def get_framework_version():
    """Get framework version from multiple sources."""
    # For deployed version, check config.json first
    config_json = Path.home() / ".claude-pm" / "config.json"
    if config_json.exists():
        try:
            import json
            with open(config_json) as f:
                data = json.load(f)
                version = data.get("version")
                if version:
                    return version
        except (json.JSONDecodeError, KeyError):
            pass
    
    # Try package.json
    package_json = framework_path / "package.json"
    if package_json.exists():
        try:
            import json
            with open(package_json) as f:
                data = json.load(f)
                if data.get("name") == "@bobmatnyc/claude-multiagent-pm":
                    return data.get("version", "unknown")
        except (json.JSONDecodeError, KeyError):
            pass
    
    # Try VERSION file
    version_file = framework_path / "VERSION"
    if version_file.exists():
        try:
            return version_file.read_text().strip()
        except OSError:
            pass
    
    return "unknown"


def detect_deployment_type():
    """Detect the deployment type and framework path."""
    script_path = Path(__file__).resolve()
    
    # Check if this script is deployed in ~/.local/bin
    local_bin = Path.home() / ".local" / "bin"
    if script_path.parent == local_bin:
        return {
            "type": "deployed", 
            "framework_path": framework_path,
            "script_path": script_path.parent
        }
    
    # Check if this script is in the framework directory
    if "claude-multiagent-pm" in str(script_path):
        return {
            "type": "development",
            "framework_path": framework_path,
            "script_path": script_path.parent
        }
    
    # Default fallback
    return {
        "type": "unknown",
        "framework_path": framework_path,
        "script_path": script_path.parent
    }


def validate_framework_deployment():
    """Validate that Claude PM Framework is properly deployed per ISS-0112."""
    # Check for ~/.claude-pm/ directory
    claude_pm_dir = Path.home() / ".claude-pm"
    if not claude_pm_dir.exists():
        return False
    
    # Check for config.json with required keys
    config_file = claude_pm_dir / "config.json"
    if not config_file.exists():
        return False
    
    try:
        import json
        with open(config_file) as f:
            config = json.load(f)
        
        # ISS-0112: Check for required config keys
        required_keys = ["deployment_type", "version", "installationComplete"]
        for key in required_keys:
            if key not in config:
                return False
        
        # Check that installation is marked complete
        if not config.get("installationComplete", False):
            return False
        
        return True
        
    except (json.JSONDecodeError, OSError):
        return False


def attempt_auto_installation():
    """Attempt to automatically install the framework if postinstall didn't run."""
    console.print("[yellow]‚ö†Ô∏è  Framework not detected - attempting auto-installation...[/yellow]")
    
    # Check if we can find the postinstall script
    postinstall_paths = [
        framework_path / "install" / "postinstall.js",
        framework_path / "install" / "postinstall-enhanced.js"
    ]
    
    for postinstall_path in postinstall_paths:
        if postinstall_path.exists():
            console.print(f"[dim]Found postinstall script: {postinstall_path}[/dim]")
            
            try:
                # Run the postinstall script
                result = subprocess.run(
                    ["node", str(postinstall_path)], 
                    cwd=str(framework_path),
                    capture_output=True,
                    text=True,
                    timeout=120  # 2 minutes timeout
                )
                
                if result.returncode == 0:
                    console.print("[green]‚úÖ Auto-installation completed successfully![/green]")
                    return True
                else:
                    console.print(f"[red]‚ùå Auto-installation failed: {result.stderr}[/red]")
                    
            except subprocess.TimeoutExpired:
                console.print("[red]‚ùå Auto-installation timed out[/red]")
            except Exception as e:
                console.print(f"[red]‚ùå Auto-installation error: {e}[/red]")
                
            break
    
    # Alternative: Try to run npm install in the framework directory
    console.print("[yellow]Attempting alternative installation via npm...[/yellow]")
    try:
        result = subprocess.run(
            ["npm", "run", "install:unified"],
            cwd=str(framework_path),
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode == 0:
            console.print("[green]‚úÖ Alternative installation completed successfully![/green]")
            return True
        else:
            console.print(f"[red]‚ùå Alternative installation failed: {result.stderr}[/red]")
            
    except Exception as e:
        console.print(f"[red]‚ùå Alternative installation error: {e}[/red]")
    
    return False


def validate_claude_cli():
    """Validate that Claude CLI is available."""
    try:
        result = subprocess.run(
            ["claude", "--version"], 
            capture_output=True, 
            text=True, 
            timeout=5
        )
        if result.returncode == 0:
            return {
                "valid": True,
                "version": result.stdout.strip(),
                "command": ["claude"]
            }
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    
    return {
        "valid": False,
        "error": "Claude CLI not found or not accessible",
        "command": ["claude"]
    }


def show_help():
    """Display help information."""
    package_version = get_framework_version()
    
    # Get framework/CLAUDE.md version
    framework_version_file = framework_path / "framework" / "VERSION"
    framework_version = "unknown"
    if framework_version_file.exists():
        try:
            framework_version = framework_version_file.read_text().strip()
        except:
            pass
    
    console.print(f"""
[bold blue]Claude Multi-Agent PM Framework[/bold blue]
[dim]Package: v{package_version} | Script: {SCRIPT_VERSION} | Framework: {framework_version}[/dim]
Pure Python CLI for Claude-powered project management and task orchestration

[bold]üöÄ USAGE:[/bold]
  claude-pm [command] [options]

[bold]üìã COMMANDS:[/bold]
  --version               Show version information
  --help, -h              Show this help message
  --system-info           Display comprehensive system information
  --deployment-info       Show deployment detection results
  
[bold]üö® ENHANCED FLAGS (Pure Python Implementation):[/bold]
  --safe                  Enable safe mode with confirmations and backups
  --upgrade [VERSION]     Upgrade to latest or specified version
  --rollback VERSION      Rollback to specific version
  --dry-run              Show what would be done without executing

[bold]‚ö° YOLO Mode (Default):[/bold]
  claude-pm               Launch Claude CLI directly (YOLO mode - fast startup)

[bold]üö® TROUBLESHOOTING:[/bold]
  ‚Ä¢ Environment Issues: claude-pm --system-info
  ‚Ä¢ Deployment Problems: claude-pm --deployment-info

[bold]üìñ DOCUMENTATION:[/bold]
  ‚Ä¢ GitHub: https://github.com/bobmatnyc/claude-multiagent-pm

---
Made with ‚ù§Ô∏è  for AI-powered development workflows (Pure Python Edition)
""")


def display_system_info():
    """Display system information."""
    deployment_info = detect_deployment_type()
    framework_version = get_framework_version()
    
    console.print("[bold]üñ•Ô∏è  Claude Multi-Agent PM Framework System Information[/bold]")
    console.print("‚ïê" * 60)
    console.print(f"üì¶ Framework Version: v{framework_version}")
    console.print(f"üîß Script Version: {SCRIPT_VERSION}")
    console.print(f"üóÇÔ∏è  Deployment Type: {deployment_info['type']}")
    console.print(f"üìÅ Framework Path: {deployment_info['framework_path']}")
    console.print(f"üîß Platform: {sys.platform}")
    console.print(f"üêç Python: {sys.version.split()[0]}")
    console.print(f"üìç Script Path: {deployment_info['script_path']}")
    console.print("")


def display_deployment_info():
    """Display deployment detection results."""
    deployment_info = detect_deployment_type()
    console.print("\n[bold]üîç Deployment Detection Results:[/bold]")
    console.print("‚ïê" * 60)
    import json
    console.print(json.dumps(deployment_info, indent=2, default=str))


def display_comprehensive_status():
    """Display comprehensive framework status checks."""
    console.print("[bold blue]üîç Claude PM Framework Status Validation[/bold blue]")
    console.print("‚ïê" * 60)
    
    # Project version
    project_version = get_framework_version()
    console.print(f"üì¶ Project Version: [green]v{project_version}[/green]")
    console.print(f"üîß Script Version: [green]{SCRIPT_VERSION}[/green]")
    
    # Framework/CLAUDE.md version (serial number from framework/VERSION)
    framework_version_file = framework_path / "framework" / "VERSION"
    if framework_version_file.exists():
        try:
            framework_version = framework_version_file.read_text().strip()
            console.print(f"üìã Framework/CLAUDE.md Version: [green]{framework_version}[/green]")
        except:
            console.print("üìã Framework/CLAUDE.md Version: [yellow]read error[/yellow]")
    else:
        console.print("üìã Framework/CLAUDE.md Version: [yellow]not found[/yellow]")
    
    # Memory system status with mem0AI version and memory count
    memory_status = check_memory_status()
    memory_color = "green" if memory_status["healthy"] else "yellow" if memory_status["partial"] else "red"
    console.print(f"üß† Memory System: [{memory_color}]{memory_status['status']}[/{memory_color}]")
    
    # Framework deployment status
    deployment_valid = validate_framework_deployment()
    deploy_color = "green" if deployment_valid else "red"
    deploy_status = "‚úÖ Deployed" if deployment_valid else "‚ùå Not Deployed"
    console.print(f"üöÄ Framework Deployment: [{deploy_color}]{deploy_status}[/{deploy_color}]")
    
    # Claude CLI status
    claude_validation = validate_claude_cli()
    claude_color = "green" if claude_validation["valid"] else "red"
    claude_status = f"‚úÖ v{claude_validation.get('version', 'unknown')}" if claude_validation["valid"] else "‚ùå Not Found"
    console.print(f"ü§ñ Claude CLI: [{claude_color}]{claude_status}[/{claude_color}]")
    
    console.print("‚ïê" * 60)


def check_memory_status():
    """Check memory system status with mem0AI version and memory count."""
    try:
        # Check for mem0AI installation and version
        mem0_version = "not installed"
        memory_count = 0
        
        # Check if mem0AI is installed via pip
        try:
            import subprocess
            # Use python -m pip to avoid PATH issues
            result = subprocess.run([sys.executable, "-m", "pip", "show", "mem0ai"], capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                import re
                version_match = re.search(r'Version:\s*(\S+)', result.stdout)
                if version_match:
                    mem0_version = version_match.group(1)
        except:
            # Try alternative package names
            try:
                result = subprocess.run([sys.executable, "-m", "pip", "show", "mem0"], capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    import re
                    version_match = re.search(r'Version:\s*(\S+)', result.stdout)
                    if version_match:
                        mem0_version = version_match.group(1)
            except:
                pass
        
        # Check for memory storage locations and count memories
        memory_locations = [
            Path.home() / ".mem0",  # Default mem0 location
            Path.home() / ".claude-pm" / "memory",  # Framework memory location
            framework_path / "memory",  # Local memory storage
            framework_path / "logs" / "memory"  # Memory logs
        ]
        
        for loc in memory_locations:
            if loc.exists() and loc.is_dir():
                try:
                    # Count actual memory files (json, db, etc.)
                    memory_files = list(loc.glob("**/*.json")) + list(loc.glob("**/*.db")) + list(loc.glob("**/*.sqlite"))
                    memory_count += len(memory_files)
                    
                    # Also check for any files that might be memories
                    if memory_count == 0:
                        all_files = [f for f in loc.glob("**/*") if f.is_file()]
                        memory_count += len(all_files)
                except:
                    pass
        
        # Check if memory optimization files exist  
        memory_opt_files = [
            framework_path / "scripts" / "memory-optimization.js",
            framework_path / "scripts" / "memory-monitor.js",
            framework_path / "scripts" / "memory-dashboard.js"
        ]
        
        optimization_exists = any(f.exists() for f in memory_opt_files)
        
        # Check for mem0 service
        mem0_service_running = False
        try:
            # Check if mem0 service script exists
            mem0_service_script = framework_path / "scripts" / "mem0_service.py"
            if mem0_service_script.exists():
                mem0_service_running = True
        except:
            pass
        
        # Determine status based on findings
        if mem0_version != "not installed" and memory_count > 0:
            return {
                "healthy": True, 
                "partial": False,
                "status": f"‚úÖ mem0AI v{mem0_version} ({memory_count} memories)"
            }
        elif mem0_version != "not installed" and mem0_service_running:
            return {
                "healthy": True,
                "partial": False, 
                "status": f"‚úÖ mem0AI v{mem0_version} (service ready)"
            }
        elif mem0_version != "not installed":
            return {
                "healthy": False,
                "partial": True,
                "status": f"‚ö†Ô∏è mem0AI v{mem0_version} (no memories)"
            }
        elif optimization_exists:
            return {
                "healthy": False,
                "partial": True, 
                "status": f"‚ö†Ô∏è Optimization only (mem0AI: {mem0_version})"
            }
        else:
            return {
                "healthy": False,
                "partial": False,
                "status": "‚ùå Not configured"
            }
    except Exception as e:
        return {
            "healthy": False,
            "partial": False, 
            "status": f"‚ùå Error: {str(e)[:20]}..."
        }


def launch_claude_cli_yolo():
    """Launch Claude CLI in proper YOLO mode with essential flags."""
    validation = validate_claude_cli()
    
    if not validation["valid"]:
        console.print("[red]‚ùå Claude CLI validation failed[/red]")
        console.print(f"   Error: {validation['error']}")
        console.print("\n[bold]üîß Solutions:[/bold]")
        console.print("   ‚Ä¢ Install Claude CLI: https://claude.ai/download")
        console.print("   ‚Ä¢ Add Claude CLI to your PATH")
        console.print("   ‚Ä¢ Restart your terminal")
        sys.exit(1)
    
    # Launch Claude CLI with essential YOLO mode flags
    try:
        import shutil
        claude_path = shutil.which("claude")
        if not claude_path:
            console.print("[red]‚ùå Claude CLI not found in PATH[/red]")
            sys.exit(1)
        
        # Essential YOLO mode arguments
        claude_args = [
            "claude",
            "--model", "sonnet", 
            "--dangerously-skip-permissions"
        ]
        
        console.print(f"[dim]Launching Claude with: {' '.join(claude_args[1:])}[/dim]")
        
        # Use os.execvp for proper terminal handling in YOLO mode
        os.execvp("claude", claude_args)
        
    except Exception as e:
        console.print(f"[red]‚ùå Failed to launch Claude CLI: {e}[/red]")
        sys.exit(1)


def launch_claude_cli_with_args(args):
    """Launch Claude CLI with pass-through arguments."""
    validation = validate_claude_cli()
    
    if not validation["valid"]:
        console.print("[red]‚ùå Claude CLI validation failed[/red]")
        console.print(f"   Error: {validation['error']}")
        sys.exit(1)
    
    # Launch Claude CLI with pass-through args plus essential flags
    try:
        import shutil
        claude_path = shutil.which("claude")
        if not claude_path:
            console.print("[red]‚ùå Claude CLI not found in PATH[/red]")
            sys.exit(1)
        
        # Build command with essential flags + pass-through args
        claude_args = [
            "claude",
            "--model", "sonnet",
            "--dangerously-skip-permissions"
        ] + args
        
        console.print(f"[dim]Launching Claude with: {' '.join(claude_args[1:])}[/dim]")
        
        # Use os.execvp for proper terminal handling
        os.execvp("claude", claude_args)
        
    except Exception as e:
        console.print(f"[red]‚ùå Failed to launch Claude CLI: {e}[/red]")
        sys.exit(1)


def launch_claude_cli():
    """Launch Claude CLI directly (legacy method)."""
    validation = validate_claude_cli()
    
    if not validation["valid"]:
        console.print("[red]‚ùå Claude CLI validation failed[/red]")
        console.print(f"   Error: {validation['error']}")
        console.print("\n[bold]üîß Solutions:[/bold]")
        console.print("   ‚Ä¢ Install Claude CLI: https://claude.ai/download")
        console.print("   ‚Ä¢ Add Claude CLI to your PATH")
        console.print("   ‚Ä¢ Restart your terminal")
        sys.exit(1)
    
    # Launch Claude CLI
    try:
        os.execvp("claude", ["claude"])
    except FileNotFoundError:
        console.print("[red]‚ùå Failed to launch Claude CLI[/red]")
        sys.exit(1)


def handle_enhanced_flags():
    """Handle enhanced flags using pure Python implementation."""
    # Import the CLI flags module
    try:
        from claude_pm.cli_flags import cli_flags
        
        # Remove the script name from args and pass to Click
        sys.argv[0] = "claude-pm"
        cli_flags()
        
    except ImportError as e:
        console.print(f"[red]‚ùå Failed to import CLI flags module: {e}[/red]")
        console.print("Make sure the Claude PM Framework is properly installed.")
        sys.exit(1)


def main():
    """Main entry point with pure Python implementation."""
    args = sys.argv[1:]
    
    # Enhanced flags that trigger Python CLI system
    enhanced_flags = ["--safe", "--upgrade", "--rollback", "--dry-run"]
    version_flags = ["--version"]  # Removed -v to avoid conflict with verbose
    help_flags = ["--help", "-h"]
    
    # Check for enhanced flags
    has_enhanced_flags = any(
        arg in enhanced_flags or 
        arg.startswith("--format=") or
        any(flag in args for flag in enhanced_flags)
        for arg in args
    )
    
    # Handle enhanced version command (with additional options)
    if any(flag in args for flag in version_flags) and (
        "--components" in args or 
        "--git" in args or 
        "--format" in " ".join(args) or
        "--detailed" in args or
        has_enhanced_flags
    ):
        handle_enhanced_flags()
        return
    
    # Handle enhanced flags
    if has_enhanced_flags:
        handle_enhanced_flags()
        return
    
    # Handle basic flags
    if any(flag in args for flag in version_flags):
        package_version = get_framework_version()
        
        # Get framework/CLAUDE.md version using the framework_path defined above
        framework_version_file = framework_path / "framework" / "VERSION"
        framework_version = "unknown"
        if framework_version_file.exists():
            try:
                framework_version = framework_version_file.read_text().strip()
            except:
                pass
        
        console.print(f"[bold]claude-pm script version: {SCRIPT_VERSION}[/bold]")
        console.print(f"Package version: v{package_version}")
        console.print(f"Framework/CLAUDE.md version: {framework_version}")
        return
    
    if any(flag in args for flag in help_flags):
        show_help()
        return
    
    if "--system-info" in args:
        display_system_info()
        return
    
    if "--deployment-info" in args:
        display_deployment_info()
        return
    
    # Check for pass-through flags first
    passthrough_flags = ["--continue", "-c", "--resume", "-r"]
    if any(flag in args for flag in passthrough_flags):
        # Pass through continue/resume flags after validation
        display_comprehensive_status()
        
        if not validate_framework_deployment():
            console.print("[red]‚ùå Claude PM Framework not properly deployed![/red]")
            console.print("")
            
            # Attempt auto-installation first
            if attempt_auto_installation():
                console.print("[green]‚úÖ Framework auto-installation successful![/green]")
                
                # Re-validate after auto-installation
                if validate_framework_deployment():
                    console.print("[green]‚úÖ Framework deployment validated - proceeding...[/green]")
                else:
                    console.print("[red]‚ùå Framework deployment validation failed after auto-installation[/red]")
                    sys.exit(1)
            else:
                console.print("[bold]üö® Framework deployment required before operations[/bold]")
                console.print("Run one of the following commands to deploy the framework:")
                console.print("   ‚Ä¢ claude-pm setup")
                console.print("   ‚Ä¢ claude-pm deploy")
                console.print("   ‚Ä¢ cmpm-init")
                console.print("   ‚Ä¢ npm run install:unified (from framework directory)")
                console.print("")
                console.print(f"üìç Expected framework location: ~/.claude-pm")
                sys.exit(1)
        
        console.print("[green]‚úÖ All systems validated - launching Claude CLI with pass-through flags[/green]")
        console.print("")
        launch_claude_cli_with_args(args)
        return
    
    # Handle no arguments case - Framework validation required per ISS-0112
    if not args:
        # ISS-0112: Require framework deployment before ANY operations
        display_comprehensive_status()
        
        if not validate_framework_deployment():
            console.print("[red]‚ùå Claude PM Framework not properly deployed![/red]")
            console.print("")
            
            # Attempt auto-installation first
            if attempt_auto_installation():
                console.print("[green]‚úÖ Framework auto-installation successful![/green]")
                
                # Re-validate after auto-installation
                if validate_framework_deployment():
                    console.print("[green]‚úÖ Framework deployment validated - proceeding...[/green]")
                else:
                    console.print("[red]‚ùå Framework deployment validation failed after auto-installation[/red]")
                    sys.exit(1)
            else:
                console.print("[bold]üö® Framework deployment required before operations[/bold]")
                console.print("Run one of the following commands to deploy the framework:")
                console.print("   ‚Ä¢ claude-pm setup")
                console.print("   ‚Ä¢ claude-pm deploy")
                console.print("   ‚Ä¢ cmpm-init")
                console.print("   ‚Ä¢ npm run install:unified (from framework directory)")
                console.print("")
                console.print(f"üìç Expected framework location: ~/.claude-pm")
                sys.exit(1)
        
        console.print("[green]‚úÖ All systems validated - launching Claude CLI in YOLO mode[/green]")
        console.print("")
        # Framework validated - launch Claude CLI in proper YOLO mode
        launch_claude_cli_yolo()
        return
    
    # For other commands, delegate to Python framework
    deployment_info = detect_deployment_type()
    deployment_framework_path = deployment_info["framework_path"]
    
    try:
        # Use subprocess to call the Python CLI module
        cmd = [sys.executable, "-m", "claude_pm.cli"] + args
        result = subprocess.run(cmd, cwd=deployment_framework_path)
        sys.exit(result.returncode)
        
    except Exception as e:
        console.print(f"[red]‚ùå Failed to execute Claude PM Framework: {e}[/red]")
        console.print(f"   Framework path: {deployment_framework_path}")
        console.print(f"   Python command: {sys.executable}")
        sys.exit(1)


if __name__ == "__main__":
    main()