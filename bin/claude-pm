#!/usr/bin/env node

/**
 * Claude Multi-Agent PM Framework - Universal CLI Entry Point
 * 
 * This is the main entry point for the claude-pm command-line interface.
 * It provides universal access to the Claude PM Framework regardless of
 * installation location or platform.
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { spawn } = require('child_process');

// Universal version resolution for all deployment scenarios
function resolveVersion() {
    const fs = require('fs');
    const path = require('path');
    
    // Strategy 1: Try to find package.json relative to this script
    // Works for: source, npm global, npm local, deployed scenarios
    const packagePaths = [
        path.join(__dirname, '../package.json'),  // From bin/ directory (source, npm)
        path.join(__dirname, '../../package.json'), // One level up if needed
        path.join(__dirname, '../../../package.json') // Two levels up for deep npm installs
    ];
    
    for (const packagePath of packagePaths) {
        try {
            if (fs.existsSync(packagePath)) {
                const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
                if (pkg.name === '@bobmatnyc/claude-multiagent-pm' && pkg.version) {
                    return pkg.version;
                }
            }
        } catch (e) {
            // Continue to next path
        }
    }
    
    // Strategy 2: Try VERSION file (source development scenario)
    const versionPaths = [
        path.join(__dirname, '../VERSION'),  // From bin/ directory (source)
        path.join(__dirname, '../../VERSION') // One level up
    ];
    
    for (const versionPath of versionPaths) {
        try {
            if (fs.existsSync(versionPath)) {
                return fs.readFileSync(versionPath, 'utf8').trim();
            }
        } catch (e) {
            // Continue to next path
        }
    }
    
    // Strategy 3: Check for NPM package in node_modules (new prioritized strategy)
    try {
        const nodeModulesPaths = [
            path.join(process.cwd(), 'node_modules', '@bobmatnyc', 'claude-multiagent-pm', 'package.json'),
            path.join(process.cwd(), '..', 'node_modules', '@bobmatnyc', 'claude-multiagent-pm', 'package.json'),
            path.join(require.resolve('@bobmatnyc/claude-multiagent-pm/package.json'))
        ];
        
        for (const npmPackagePath of nodeModulesPaths) {
            if (fs.existsSync(npmPackagePath)) {
                const pkg = JSON.parse(fs.readFileSync(npmPackagePath, 'utf8'));
                if (pkg.name === '@bobmatnyc/claude-multiagent-pm' && pkg.version) {
                    return pkg.version;
                }
            }
        }
    } catch (e) {
        // Continue to fallback
    }
    
    // Strategy 4: Use npm to resolve package version (if available)
    try {
        const { execSync } = require('child_process');
        const result = execSync('npm list @bobmatnyc/claude-multiagent-pm --depth=0 --json', { 
            encoding: 'utf8', 
            stdio: 'pipe',
            timeout: 5000 
        });
        const npmData = JSON.parse(result);
        if (npmData.dependencies && npmData.dependencies['@bobmatnyc/claude-multiagent-pm']) {
            return npmData.dependencies['@bobmatnyc/claude-multiagent-pm'].version;
        }
    } catch (e) {
        // npm command failed, continue
    }
    
    // If all strategies fail, throw error with helpful message
    throw new Error(
        'Could not resolve Claude PM Framework version. ' +
        'This may indicate a corrupted installation or unsupported deployment scenario. ' +
        'Please reinstall using: npm install -g @bobmatnyc/claude-multiagent-pm'
    );
}

const CLAUDE_PM_VERSION = resolveVersion();

/**
 * Claude PM Framework Deployment Detection System
 * 
 * Provides comprehensive detection and resolution of all deployment scenarios
 * including local source, npm global, npx, npm local, and deployed instances.
 */
class DeploymentDetector {
    constructor() {
        this.platform = os.platform();
        this.detectionResults = null;
        this.detectionCache = new Map();
        this.maxCacheSize = 10; // Limit cache size to prevent memory growth
        this.cacheCleanupTimer = null;
        this._setupMemoryCleanup();
    }

    /**
     * Setup automatic memory cleanup to prevent memory leaks
     */
    _setupMemoryCleanup() {
        // Clear cache periodically to prevent memory accumulation
        this.cacheCleanupTimer = setInterval(() => {
            if (this.detectionCache.size > this.maxCacheSize) {
                // Keep only the most recent entries
                const entries = Array.from(this.detectionCache.entries());
                const keepEntries = entries.slice(-this.maxCacheSize);
                this.detectionCache.clear();
                keepEntries.forEach(([key, value]) => {
                    this.detectionCache.set(key, value);
                });
            }
        }, 30000); // Clean up every 30 seconds

        // Cleanup on process exit
        process.on('exit', () => {
            this.cleanup();
        });
        process.on('SIGINT', () => {
            this.cleanup();
            process.exit(0);
        });
        process.on('SIGTERM', () => {
            this.cleanup();
            process.exit(0);
        });
    }

    /**
     * Clean up resources to prevent memory leaks
     */
    cleanup() {
        if (this.cacheCleanupTimer) {
            clearInterval(this.cacheCleanupTimer);
            this.cacheCleanupTimer = null;
        }
        this.detectionCache.clear();
        this.detectionResults = null;
    }

    /**
     * Detect deployment type and return configuration
     */
    detectDeployment() {
        // Check cache first
        const cacheKey = `${process.cwd()}_${__dirname}`;
        if (this.detectionCache.has(cacheKey)) {
            return this.detectionCache.get(cacheKey);
        }

        const deploymentConfig = this._performDetection();
        this.detectionCache.set(cacheKey, deploymentConfig);
        return deploymentConfig;
    }

    /**
     * Perform deployment detection logic
     */
    _performDetection() {
        // Strategy 1: NPM local installation (node_modules) - Prioritize over deployed instances
        const npmLocalResult = this._detectNpmLocal();
        if (npmLocalResult.found) {
            return this._buildConfig('npm_local', npmLocalResult);
        }

        // Strategy 2: NPM global installation
        const npmGlobalResult = this._detectNpmGlobal();
        if (npmGlobalResult.found) {
            return this._buildConfig('npm_global', npmGlobalResult);
        }

        // Strategy 3: NPX execution
        const npxResult = this._detectNpxExecution();
        if (npxResult.found) {
            return this._buildConfig('npx', npxResult);
        }

        // Strategy 4: Local source development (bin/claude-pm in source repo)
        const localSourceResult = this._detectLocalSource();
        if (localSourceResult.found) {
            return this._buildConfig('local_source', localSourceResult);
        }

        // Strategy 5: Deployed instance (from install/deploy.js) - Lower priority than NPM
        const deployedResult = this._detectDeployedInstance();
        if (deployedResult.found) {
            return this._buildConfig('deployed', deployedResult);
        }

        // Strategy 6: Environment-based detection
        const envResult = this._detectEnvironmentBased();
        if (envResult.found) {
            return this._buildConfig('environment', envResult);
        }

        // Strategy 7: Fallback detection
        const fallbackResult = this._detectFallback();
        if (fallbackResult.found) {
            return this._buildConfig('fallback', fallbackResult);
        }

        // No valid deployment found
        return this._buildConfig('not_found', { found: false, error: 'No valid Claude PM Framework deployment found' });
    }

    /**
     * Detect local source development scenario
     */
    _detectLocalSource() {
        try {
            // Check if we're in the source repository
            const sourceRoot = path.join(__dirname, '..');
            const claudePmPath = path.join(sourceRoot, 'claude_pm');
            const packageJsonPath = path.join(sourceRoot, 'package.json');
            
            if (fs.existsSync(claudePmPath) && fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                if (packageJson.name === '@bobmatnyc/claude-multiagent-pm') {
                    return {
                        found: true,
                        frameworkPath: sourceRoot,
                        claudePmPath: claudePmPath,
                        packageJson: packageJson,
                        confidence: 'high'
                    };
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect NPM global installation
     */
    _detectNpmGlobal() {
        try {
            const { execSync } = require('child_process');
            
            // Try to find global installation
            const globalPath = execSync('npm root -g', { encoding: 'utf8' }).trim();
            const globalClaudePm = path.join(globalPath, '@bobmatnyc', 'claude-multiagent-pm');
            const globalFrameworkPath = path.join(globalClaudePm, 'claude_pm');
            
            if (fs.existsSync(globalFrameworkPath)) {
                return {
                    found: true,
                    frameworkPath: globalClaudePm,
                    claudePmPath: globalFrameworkPath,
                    globalPath: globalPath,
                    confidence: 'high'
                };
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect NPX execution scenario
     */
    _detectNpxExecution() {
        try {
            // Check if we're running via npx
            const npxCache = process.env.npm_config_cache;
            const npxPrefix = process.env.npm_config_prefix;
            
            if (npxCache && (process.env.npm_execpath || process.env.npm_command)) {
                // Look for claude-pm in npx cache
                const npxCachePath = path.join(npxCache, '_npx');
                if (fs.existsSync(npxCachePath)) {
                    // Find the most recent claude-pm installation
                    const claudePmDirs = fs.readdirSync(npxCachePath)
                        .filter(dir => dir.includes('claude-multiagent-pm'))
                        .sort()
                        .reverse();
                    
                    if (claudePmDirs.length > 0) {
                        const latestDir = claudePmDirs[0];
                        const npxFrameworkPath = path.join(npxCachePath, latestDir, 'node_modules', '@bobmatnyc', 'claude-multiagent-pm');
                        const npxClaudePmPath = path.join(npxFrameworkPath, 'claude_pm');
                        
                        if (fs.existsSync(npxClaudePmPath)) {
                            return {
                                found: true,
                                frameworkPath: npxFrameworkPath,
                                claudePmPath: npxClaudePmPath,
                                npxCachePath: npxCachePath,
                                confidence: 'medium'
                            };
                        }
                    }
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect NPM local installation
     */
    _detectNpmLocal() {
        try {
            // Check current directory and parents for node_modules
            let currentDir = process.cwd();
            
            while (currentDir !== path.dirname(currentDir)) {
                const nodeModulesPath = path.join(currentDir, 'node_modules', '@bobmatnyc', 'claude-multiagent-pm');
                const localClaudePmPath = path.join(nodeModulesPath, 'claude_pm');
                
                if (fs.existsSync(localClaudePmPath)) {
                    return {
                        found: true,
                        frameworkPath: nodeModulesPath,
                        claudePmPath: localClaudePmPath,
                        projectRoot: currentDir,
                        confidence: 'medium'
                    };
                }
                
                currentDir = path.dirname(currentDir);
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect deployed instance (from install/deploy.js)
     */
    _detectDeployedInstance() {
        try {
            // Check standard deployment locations first
            const deploymentLocations = [
                path.join(os.homedir(), '.local'),
                path.join(os.homedir(), '.claude-pm'),
                process.cwd()
            ];

            for (const deploymentDir of deploymentLocations) {
                const deployedConfigPath = path.join(deploymentDir, '.claude-pm', 'config.json');
                const deployedClaudePmPath = path.join(deploymentDir, 'claude_pm');
                
                if (fs.existsSync(deployedConfigPath) && fs.existsSync(deployedClaudePmPath)) {
                    const deployedConfig = JSON.parse(fs.readFileSync(deployedConfigPath, 'utf8'));
                    
                    return {
                        found: true,
                        frameworkPath: deploymentDir,
                        claudePmPath: deployedClaudePmPath,
                        deployedConfig: deployedConfig,
                        confidence: deploymentDir === path.join(os.homedir(), '.local') ? 'high' : 'medium'
                    };
                }
            }

            // Check current directory for deployed instance
            const deployedConfigPath = path.join(process.cwd(), '.claude-pm', 'config.json');
            const deployedClaudePmPath = path.join(process.cwd(), 'claude_pm');
            
            if (fs.existsSync(deployedConfigPath) && fs.existsSync(deployedClaudePmPath)) {
                const deployedConfig = JSON.parse(fs.readFileSync(deployedConfigPath, 'utf8'));
                
                return {
                    found: true,
                    frameworkPath: process.cwd(),
                    claudePmPath: deployedClaudePmPath,
                    deployedConfig: deployedConfig,
                    confidence: 'high'
                };
            }

            // Check parent directories for deployed instances
            let currentDir = process.cwd();
            while (currentDir !== path.dirname(currentDir)) {
                const parentConfigPath = path.join(currentDir, '.claude-pm', 'config.json');
                const parentClaudePmPath = path.join(currentDir, 'claude_pm');
                
                if (fs.existsSync(parentConfigPath) && fs.existsSync(parentClaudePmPath)) {
                    const parentConfig = JSON.parse(fs.readFileSync(parentConfigPath, 'utf8'));
                    
                    return {
                        found: true,
                        frameworkPath: currentDir,
                        claudePmPath: parentClaudePmPath,
                        deployedConfig: parentConfig,
                        confidence: 'medium'
                    };
                }
                
                currentDir = path.dirname(currentDir);
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect environment-based configuration
     */
    _detectEnvironmentBased() {
        try {
            // Check environment variables
            const envPaths = [
                process.env.CLAUDE_MULTIAGENT_PM_ROOT,
                process.env.CLAUDE_PM_ROOT,
                process.env.CLAUDE_PM_FRAMEWORK_PATH
            ].filter(Boolean);
            
            for (const envPath of envPaths) {
                const envClaudePmPath = path.join(envPath, 'claude_pm');
                if (fs.existsSync(envClaudePmPath)) {
                    return {
                        found: true,
                        frameworkPath: envPath,
                        claudePmPath: envClaudePmPath,
                        environmentSource: envPath,
                        confidence: 'medium'
                    };
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Detect fallback scenarios
     */
    _detectFallback() {
        try {
            // Common fallback locations
            const fallbackPaths = [
                path.join(os.homedir(), '.claude-pm'),
                path.join(os.homedir(), 'Projects', 'claude-multiagent-pm'),
                path.join(os.homedir(), 'Projects', 'claude-pm'),
                '/usr/local/lib/claude-pm',
                '/opt/claude-pm'
            ];
            
            for (const fallbackPath of fallbackPaths) {
                const fallbackClaudePmPath = path.join(fallbackPath, 'claude_pm');
                if (fs.existsSync(fallbackClaudePmPath)) {
                    return {
                        found: true,
                        frameworkPath: fallbackPath,
                        claudePmPath: fallbackClaudePmPath,
                        fallbackPath: fallbackPath,
                        confidence: 'low'
                    };
                }
            }
        } catch (error) {
            // Silent failure for detection
        }
        return { found: false };
    }

    /**
     * Build deployment configuration object
     */
    _buildConfig(type, detectionResult) {
        const config = {
            deploymentType: type,
            found: detectionResult.found,
            platform: this.platform,
            detectedAt: new Date().toISOString(),
            confidence: detectionResult.confidence || 'unknown'
        };

        if (detectionResult.found) {
            config.frameworkPath = detectionResult.frameworkPath;
            config.claudePmPath = detectionResult.claudePmPath;
            config.paths = {
                framework: detectionResult.frameworkPath,
                claudePm: detectionResult.claudePmPath,
                bin: path.join(detectionResult.frameworkPath, 'bin'),
                config: path.join(detectionResult.frameworkPath, '.claude-pm'),
                templates: path.join(detectionResult.frameworkPath, 'templates'),
                schemas: path.join(detectionResult.frameworkPath, 'schemas')
            };

            // Add type-specific metadata
            switch (type) {
                case 'local_source':
                    config.metadata = {
                        packageJson: detectionResult.packageJson,
                        isDevelopment: true
                    };
                    break;
                case 'npm_global':
                    config.metadata = {
                        globalPath: detectionResult.globalPath,
                        isGlobalInstall: true
                    };
                    break;
                case 'npx':
                    config.metadata = {
                        npxCachePath: detectionResult.npxCachePath,
                        isNpxExecution: true
                    };
                    break;
                case 'npm_local':
                    config.metadata = {
                        projectRoot: detectionResult.projectRoot,
                        isLocalInstall: true
                    };
                    break;
                case 'deployed':
                    config.metadata = {
                        deployedConfig: detectionResult.deployedConfig,
                        isDeployedInstance: true
                    };
                    break;
                case 'environment':
                    config.metadata = {
                        environmentSource: detectionResult.environmentSource,
                        isEnvironmentBased: true
                    };
                    break;
                case 'fallback':
                    config.metadata = {
                        fallbackPath: detectionResult.fallbackPath,
                        isFallback: true
                    };
                    break;
            }
        } else {
            config.error = detectionResult.error;
        }

        return config;
    }

    /**
     * Get deployment strategy for current context
     */
    getDeploymentStrategy() {
        const config = this.detectDeployment();
        
        if (!config.found) {
            return {
                strategy: 'install_required',
                recommendation: 'npm install -g @bobmatnyc/claude-multiagent-pm',
                config: config
            };
        }

        const strategies = {
            local_source: {
                strategy: 'development',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            npm_global: {
                strategy: 'global_npm',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            npx: {
                strategy: 'npx_execution',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            npm_local: {
                strategy: 'local_npm',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            deployed: {
                strategy: 'deployed_instance',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            environment: {
                strategy: 'environment_configured',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            },
            fallback: {
                strategy: 'fallback_detected',
                pythonPath: config.paths.claudePm,
                environmentSetup: {
                    PYTHONPATH: config.paths.framework,
                    CLAUDE_PM_FRAMEWORK_PATH: config.paths.framework
                }
            }
        };

        return {
            ...strategies[config.deploymentType],
            config: config
        };
    }
}

// Create global detector instance
const deploymentDetector = new DeploymentDetector();

/**
 * Enhanced framework path detection with comprehensive deployment support
 */
function getFrameworkPath() {
    const deploymentStrategy = deploymentDetector.getDeploymentStrategy();
    
    if (deploymentStrategy.strategy === 'install_required') {
        console.error('‚ùå Claude PM Framework not found');
        console.error('Please install the framework:');
        console.error(`   ${deploymentStrategy.recommendation}`);
        console.error('');
        console.error('Detected deployment scenarios:');
        console.error('- No valid framework installation found');
        console.error('- Checked: local source, npm global, npx, npm local, deployed instances');
        process.exit(1);
    }
    
    return deploymentStrategy.config.frameworkPath;
}

/**
 * Get deployment configuration for advanced usage
 */
function getDeploymentConfig() {
    return deploymentDetector.getDeploymentStrategy();
}

/**
 * Validate Python environment
 */
function validatePython() {
    try {
        const pythonResult = require('child_process').execSync('python3 --version', { encoding: 'utf8' });
        const version = pythonResult.match(/Python (\d+)\.(\d+)/);
        
        if (!version || parseInt(version[1]) < 3 || (parseInt(version[1]) === 3 && parseInt(version[2]) < 8)) {
            console.error('‚ùå Python 3.8+ required. Found:', pythonResult.trim());
            process.exit(1);
        }
        
        return 'python3';
    } catch (error) {
        try {
            const pythonResult = require('child_process').execSync('python --version', { encoding: 'utf8' });
            const version = pythonResult.match(/Python (\d+)\.(\d+)/);
            
            if (!version || parseInt(version[1]) < 3 || (parseInt(version[1]) === 3 && parseInt(version[2]) < 8)) {
                console.error('‚ùå Python 3.8+ required. Found:', pythonResult.trim());
                process.exit(1);
            }
            
            return 'python';
        } catch (error) {
            console.error('‚ùå Python not found. Please install Python 3.8+');
            process.exit(1);
        }
    }
}

/**
 * Show enhanced help message with deployment detection
 */
function showHelp() {
    const deploymentConfig = deploymentDetector.getDeploymentStrategy();
    
    console.log(`
Claude Multi-Agent PM Framework v${CLAUDE_PM_VERSION}
Universal CLI for AI-driven project management

Usage: claude-pm [command] [options]

Commands:
  health              Health monitoring and status
  memory              Memory management operations  
  project             Project management operations
  service             Service management
  workflow            Workflow orchestration
  enforcement         Framework enforcement
  deploy-template     Deploy CLAUDE.md template to current directory
  --version           Show version information
  --deployment-info   Show deployment detection results
  --system-info       Show system information with CLAUDE.md version
  --manage-claude-md  Manage framework CLAUDE.md deployment tree
  --template-status   Show template management status (CMPM-102)
  --dependency-status Show dependency management status (CMPM-103)
  --parent-directory-status Show parent directory management status (CMPM-104)
  --help              Show this help message

Framework Integration:
  This CLI provides universal access to the Claude PM Framework
  regardless of installation location or platform.

Current Deployment:
  Type: ${deploymentConfig.config.found ? deploymentConfig.config.deploymentType : 'not_found'}
  Path: ${deploymentConfig.config.found ? deploymentConfig.config.frameworkPath : 'N/A'}
  Confidence: ${deploymentConfig.config.found ? deploymentConfig.config.confidence : 'N/A'}

Examples:
  claude-pm health status
  claude-pm project create my-project
  claude-pm memory init
  claude-pm service start all
  claude-pm --deployment-info
  claude-pm --template-status
  claude-pm --dependency-status
  claude-pm --parent-directory-status

For more information, visit:
https://github.com/bobmatnyc/claude-pm
`);
}

/**
 * Display comprehensive system information
 */
function displaySystemInfo() {
    const deploymentConfig = getDeploymentConfig();
    const today = new Date().toISOString().split('T')[0]; // 2025-07-11 format
    
    console.log('\n' + '='.repeat(70));
    console.log('üöÄ CLAUDE PM FRAMEWORK - SYSTEM INFORMATION');
    console.log('='.repeat(70));
    console.log(`üìÖ System Status as of ${today}`);
    console.log('');
    
    // Framework Version - Show both package and deployed if different
    console.log(`üì¶ Claude PM Framework Version: v${CLAUDE_PM_VERSION}`);
    
    // Show deployment config version if different from package version
    try {
        if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
            const config = deploymentConfig.config;
            
            if (config.deploymentType === 'deployed' && config.metadata?.deployedConfig) {
                const deployedVersion = config.metadata.deployedConfig.version;
                if (deployedVersion !== CLAUDE_PM_VERSION) {
                    console.log(`‚öôÔ∏è  Deployed Config Version: v${deployedVersion} (will be updated)`);
                }
            }
        }
    } catch (error) {
        // Silent fallback
    }
    
    // Install Path
    if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
        console.log(`üìÅ Install Path: ${deploymentConfig.config.frameworkPath}`);
    } else {
        console.log(`üìÅ Install Path: Not detected`);
    }
    
    // Working Path
    console.log(`üìÇ Working Path: ${process.cwd()}`);
    
    // AI-trackdown-tools Version
    try {
        const { execSync } = require('child_process');
        const version = execSync('aitrackdown --version', { encoding: 'utf8' }).trim();
        console.log(`üîç AI-trackdown-tools Version: v${version}`);
    } catch (error) {
        console.log(`üîç AI-trackdown-tools Version: Not installed or not accessible`);
    }
    
    // Install Type
    if (deploymentConfig && deploymentConfig.config && deploymentConfig.config.found) {
        const deploymentType = deploymentConfig.config.deploymentType;
        let installType = 'Unknown';
        
        switch (deploymentType) {
            case 'deployed':
                installType = 'Local Deploy';
                break;
            case 'npm_global':
                installType = 'Global NPM Installation';
                break;
            case 'npm_local':
                installType = 'Local NPM Installation';
                break;
            case 'npx':
                installType = 'NPX Execution';
                break;
            case 'local_source':
                installType = 'Local Source Development';
                break;
            default:
                installType = deploymentType;
        }
        
        console.log(`‚öôÔ∏è  Install Type: ${installType}`);
    } else {
        console.log(`‚öôÔ∏è  Install Type: Not detected`);
    }
    
    // Memory System Status - Use dedicated Python detection function
    try {
        const { execSync } = require('child_process');
        const frameworkPath = deploymentConfig && deploymentConfig.config && deploymentConfig.config.found 
            ? deploymentConfig.config.frameworkPath 
            : process.cwd();
        
        // Call the Python _detect_memory_manager_info() function directly
        const memoryInfo = execSync(`python3 -c "import sys; sys.path.insert(0, '${frameworkPath}'); from claude_pm.cli import _detect_memory_manager_info; print(_detect_memory_manager_info())"`, {
            cwd: frameworkPath,
            timeout: 2000,
            encoding: 'utf8',
            stdio: 'pipe'
        }).trim();
        
        if (memoryInfo && memoryInfo !== 'error') {
            console.log(`üß† Memory: ${memoryInfo}`);
        } else {
            // Fallback detection only if Python function fails
            const localMemoryJsonPath = path.join(process.cwd(), 'memory.json');
            const localMemoryDbPath = path.join(process.cwd(), 'memory.db');
            
            if (fs.existsSync(localMemoryJsonPath) || fs.existsSync(localMemoryDbPath)) {
                console.log(`üß† Memory: Memory files detected`);
            } else {
                console.log(`üß† Memory: No memory system detected`);
            }
        }
    } catch (error) {
        // Fallback detection if Python call fails
        const localMemoryJsonPath = path.join(process.cwd(), 'memory.json');
        const localMemoryDbPath = path.join(process.cwd(), 'memory.db');
        
        if (fs.existsSync(localMemoryJsonPath) || fs.existsSync(localMemoryDbPath)) {
            console.log(`üß† Memory: Memory files detected`);
        } else {
            console.log(`üß† Memory: Unable to determine status`);
        }
    }
    
    // CLAUDE.md Detection - Current Directory and Framework
    try {
        const currentDirClaudeMd = path.join(process.cwd(), 'CLAUDE.md');
        let foundCurrentDir = false;
        
        if (fs.existsSync(currentDirClaudeMd)) {
            const claudeMdContent = fs.readFileSync(currentDirClaudeMd, 'utf8');
            
            // Extract CLAUDE_MD_VERSION and FRAMEWORK_VERSION to combine them
            const claudeMdVersionMatch = claudeMdContent.match(/CLAUDE_MD_VERSION:\s*([\d\.-]+)/);
            const frameworkVersionMatch = claudeMdContent.match(/FRAMEWORK_VERSION:\s*(\d+)/);
            
            if (claudeMdVersionMatch && frameworkVersionMatch) {
                const claudeMdVersion = claudeMdVersionMatch[1];
                const frameworkVersion = frameworkVersionMatch[1];
                // Combine versions in format: CLAUDE_MD_VERSION-FRAMEWORK_VERSION
                console.log(`üìÑ CLAUDE.md (Current): v${claudeMdVersion}-${frameworkVersion}`);
            } else if (claudeMdVersionMatch) {
                const version = claudeMdVersionMatch[1];
                // Use framework version + serial format (legacy)
                if (version.includes('-')) {
                    const [, serial] = version.split('-', 2);
                    console.log(`üìÑ CLAUDE.md (Current): v${CLAUDE_PM_VERSION}-${serial}`);
                } else {
                    console.log(`üìÑ CLAUDE.md (Current): v${CLAUDE_PM_VERSION} (Legacy format)`);
                }
            } else {
                // No version metadata - treat as project documentation, show line count
                const lines = claudeMdContent.split('\n').length;
                console.log(`üìÑ Project CLAUDE.md: ${lines} lines`);
            }
            foundCurrentDir = true;
        }
        
        // Quick framework CLAUDE.md detection for system info - context-aware
        const cwd = process.cwd();
        const frameworkPaths = [];
        
        // If we're in the framework directory, prioritize framework's own CLAUDE.md
        if (cwd.includes('claude-multiagent-pm')) {
            frameworkPaths.push(
                path.join(cwd, 'CLAUDE.md'),                    // Current framework directory
                path.join(cwd, '..', 'CLAUDE.md'),              // Parent of framework
                '/Users/masa/Projects/CLAUDE.md'                // Top-level Projects
            );
        } else {
            // If we're outside framework, look in broader context
            frameworkPaths.push(
                path.join(cwd, 'CLAUDE.md'),                    // Current directory
                path.join(cwd, '..', 'CLAUDE.md'),              // Parent directory
                '/Users/masa/Projects/managed/CLAUDE.md',       // Managed template
                '/Users/masa/Projects/CLAUDE.md'                // Top-level Projects
            );
        }
        
        let foundFramework = false;
        for (const frameworkPath of frameworkPaths) {
            if (fs.existsSync(frameworkPath)) {
                try {
                    const content = fs.readFileSync(frameworkPath, 'utf8');
                    
                    // Check if it's a framework file
                    const isFramework = content.includes('template CLAUDE.md file for the Claude PM Framework') ||
                                      content.includes('Claude PM Framework Configuration - Deployment') ||
                                      content.includes('AI ASSISTANT ROLE DESIGNATION');
                    
                    if (isFramework) {
                        // Format path with ~ for home directory
                        const displayPath = frameworkPath.replace('/Users/masa', '~');
                        const claudeMdVersionMatch = content.match(/CLAUDE_MD_VERSION:\s*([\d\.-]+)/);
                        const frameworkVersionMatch = content.match(/FRAMEWORK_VERSION:\s*(\d+)/);
                        
                        if (claudeMdVersionMatch && frameworkVersionMatch) {
                            const claudeMdVersion = claudeMdVersionMatch[1];
                            const frameworkVersion = frameworkVersionMatch[1];
                            // Combine versions in format: CLAUDE_MD_VERSION-FRAMEWORK_VERSION
                            console.log(`üìã Framework CLAUDE.md: ${displayPath} (${claudeMdVersion}-${frameworkVersion})`);
                        } else if (claudeMdVersionMatch) {
                            const version = claudeMdVersionMatch[1];
                            // Use framework version + serial format (legacy)
                            if (version.includes('-')) {
                                const [, serial] = version.split('-', 2);
                                console.log(`üìã Framework CLAUDE.md: ${displayPath} (${CLAUDE_PM_VERSION}-${serial})`);
                            } else {
                                console.log(`üìã Framework CLAUDE.md: ${displayPath} (${CLAUDE_PM_VERSION})`);
                            }
                        } else {
                            console.log(`üìã Framework CLAUDE.md: ${displayPath}`);
                        }
                        foundFramework = true;
                        break;
                    }
                } catch (error) {
                    // Skip unreadable files
                }
            }
        }
        
        if (!foundCurrentDir) {
            console.log(`üìÑ User CLAUDE.md: not in working path`);
        }
        
    } catch (error) {
        console.log(`üìÑ CLAUDE.md: Unable to check (${error.message})`);
    }
    
    console.log('');
    console.log('='.repeat(70));
    console.log('üéØ Launching Claude with optimized settings...');
    console.log('='.repeat(70));
    console.log('');
}

/**
 * Framework CLAUDE.md Management - Safe cleanup of framework deployments
 */
async function manageFrameworkClaudeMd() {
    const fs = require('fs');
    const path = require('path');
    
    try {
        // Get current working directory
        const cwd = process.cwd();
        
        // Find the framework directory
        let frameworkDir = null;
        const possibleFrameworkPaths = [
            cwd, // If we're already in the framework
            path.join(cwd, 'claude-multiagent-pm'), // If framework is a subdirectory
            path.dirname(cwd) // If we're in a subdirectory of the framework area
        ];
        
        for (const testPath of possibleFrameworkPaths) {
            if (fs.existsSync(path.join(testPath, 'claude_pm')) && 
                fs.existsSync(path.join(testPath, 'framework', 'CLAUDE.md'))) {
                frameworkDir = testPath;
                break;
            }
        }
        
        // Find all CLAUDE.md files - use context-aware search like system info
        const claudeMdFiles = [];
        let searchRoot;
        
        if (!frameworkDir) {
            // Not in a framework context, search in broader area
            searchRoot = '/Users/masa/Projects';
        } else {
            // Framework context - only search within our working path, not external areas
            searchRoot = path.dirname(frameworkDir);
            
            // Context-aware file list - only look in our working path
            const cwd = process.cwd();
            const contextAwarePaths = [];
            
            // If we're in the framework directory, only check our immediate context
            if (cwd.includes('claude-multiagent-pm')) {
                contextAwarePaths.push(
                    path.join(cwd, 'CLAUDE.md'),                    // Current framework directory
                    path.join(cwd, '..', 'CLAUDE.md')               // Parent of framework
                );
            } else {
                contextAwarePaths.push(
                    path.join(cwd, 'CLAUDE.md'),                    // Current directory
                    path.join(cwd, '..', 'CLAUDE.md')               // Parent directory
                );
            }
            
            // Only add files that actually exist in our context
            for (const contextPath of contextAwarePaths) {
                if (fs.existsSync(contextPath)) {
                    claudeMdFiles.push(contextPath);
                }
            }
        }
        
        // Only do broader search if not in framework context
        if (!frameworkDir) {
            function findClaudeMdFiles(dir, maxDepth = 3, currentDepth = 0) {
                if (currentDepth >= maxDepth) return;
                
                try {
                    const items = fs.readdirSync(dir);
                    
                    for (const item of items) {
                        const itemPath = path.join(dir, item);
                        const stat = fs.statSync(itemPath);
                        
                        if (stat.isFile() && item === 'CLAUDE.md') {
                            claudeMdFiles.push(itemPath);
                        } else if (stat.isDirectory() && !item.startsWith('.') && 
                                  item !== 'node_modules' && item !== '_archive') {
                            findClaudeMdFiles(itemPath, maxDepth, currentDepth + 1);
                        }
                    }
                } catch (error) {
                    // Skip directories we can't read
                }
            }
            
            findClaudeMdFiles(searchRoot);
        }
        
        
        // Analyze each CLAUDE.md to determine if it's framework-generated
        const frameworkFiles = [];
        const userFiles = [];
        
        for (const filePath of claudeMdFiles) {
            try {
                const content = fs.readFileSync(filePath, 'utf8');
                
                // Framework indicators (be very conservative)
                const frameworkIndicators = [
                    'Claude PM Framework Configuration - Deployment',
                    'CLAUDE_MD_VERSION:',
                    'FRAMEWORK_VERSION:',
                    'AI ASSISTANT ROLE DESIGNATION',
                    'multi-agent orchestrator',
                    'template CLAUDE.md file for the Claude PM Framework',
                    'Deployment Root:',
                    'Generated:'
                ];
                
                // User/project indicators (these make it NOT a framework file)
                const userIndicators = [
                    'project-specific',
                    'custom instructions',
                    'my project',
                    'this project',
                    'application',
                    'repository',
                    'codebase'
                ];
                
                const hasFrameworkIndicators = frameworkIndicators.some(indicator => 
                    content.includes(indicator));
                const hasUserIndicators = userIndicators.some(indicator => 
                    content.toLowerCase().includes(indicator.toLowerCase()));
                
                // Strong framework indicators override weak user indicators
                const strongFrameworkIndicators = [
                    'Claude PM Framework Configuration - Deployment',
                    'AI ASSISTANT ROLE DESIGNATION',
                    'multi-agent orchestrator'
                ];
                
                const hasStrongFrameworkIndicators = strongFrameworkIndicators.some(indicator => 
                    content.includes(indicator));
                
                // If we have strong framework indicators, it's definitely a framework file
                const isFrameworkFile = hasStrongFrameworkIndicators || (hasFrameworkIndicators && !hasUserIndicators);
                
                if (isFrameworkFile) {
                    frameworkFiles.push({
                        path: filePath,
                        relativePath: path.relative(searchRoot, filePath),
                        content: content.substring(0, 200) // First 200 chars for analysis
                    });
                } else {
                    userFiles.push({
                        path: filePath,
                        relativePath: path.relative(searchRoot, filePath)
                    });
                }
            } catch (error) {
                // Skip files we can't read
            }
        }
        
        // Find the top-most directory that should have the framework CLAUDE.md
        const topLevel = searchRoot;
        const targetFrameworkFile = path.join(topLevel, 'CLAUDE.md');
        
        // Check if we have a proper framework CLAUDE.md at the top level
        const hasTopLevelFramework = frameworkFiles.some(f => f.path === targetFrameworkFile);
        
        if (!hasTopLevelFramework) {
            // Check if we have any framework files at other levels
            const activeFrameworkFile = frameworkFiles.length > 0 ? frameworkFiles[0] : null;
            
            return {
                action: 'no_action',
                reason: 'No framework CLAUDE.md at top level (normal)',
                frameworkFiles: frameworkFiles.length,
                userFiles: userFiles.length,
                activeFrameworkFile: activeFrameworkFile ? activeFrameworkFile.relativePath : null
            };
        }
        
        // We have a framework CLAUDE.md at top level, remove any duplicates below it
        const filesToRemove = frameworkFiles.filter(f => f.path !== targetFrameworkFile);
        
        if (filesToRemove.length === 0) {
            return {
                action: 'clean',
                reason: 'Framework CLAUDE.md structure is already clean',
                frameworkFiles: frameworkFiles.length,
                userFiles: userFiles.length,
                topLevelFile: path.relative(searchRoot, targetFrameworkFile)
            };
        }
        
        // Add 'old' suffix to duplicate framework files (VERY CAREFULLY)
        const processedFiles = [];
        for (const file of filesToRemove) {
            try {
                // CRITICAL PROTECTION: NEVER MODIFY framework/CLAUDE.md
                if (file.path.includes('framework/CLAUDE.md')) {
                    continue;
                }
                
                // Extra safety check - make sure it's really a framework file
                if (file.content.includes('Claude PM Framework') || 
                    file.content.includes('CLAUDE_MD_VERSION:')) {
                    const oldPath = file.path + '.old';
                    fs.renameSync(file.path, oldPath);
                    processedFiles.push(file.relativePath + ' ‚Üí ' + path.basename(oldPath));
                }
            } catch (error) {
                console.error(`Warning: Could not rename ${file.path}: ${error.message}`);
            }
        }
        
        return {
            action: 'cleaned',
            reason: `Added 'old' suffix to ${processedFiles.length} duplicate framework CLAUDE.md files`,
            processedFiles,
            frameworkFiles: frameworkFiles.length,
            userFiles: userFiles.length,
            topLevelFile: path.relative(searchRoot, targetFrameworkFile)
        };
        
    } catch (error) {
        return {
            action: 'error',
            reason: error.message
        };
    }
}

/**
 * Enhanced main execution function with deployment detection and memory management
 */
async function main() {
    const args = process.argv.slice(2);
    
    // Memory monitoring and early exit for memory exhaustion
    const memoryThreshold = 3.5 * 1024 * 1024 * 1024; // 3.5GB threshold
    const checkMemory = () => {
        const usage = process.memoryUsage();
        if (usage.heapUsed > memoryThreshold) {
            console.error(`‚ùå Memory usage critical: ${Math.round(usage.heapUsed / 1024 / 1024)}MB`);
            console.error('Triggering garbage collection and cleanup...');
            if (global.gc) {
                global.gc();
            }
            // Force cleanup of deployment detector
            if (deploymentDetector) {
                deploymentDetector.cleanup();
            }
            return true;
        }
        return false;
    };
    
    // Monitor memory every 10 seconds during execution
    const memoryMonitor = setInterval(checkMemory, 10000);
    
    // Cleanup function for proper resource management
    const cleanup = () => {
        if (memoryMonitor) {
            clearInterval(memoryMonitor);
        }
        if (deploymentDetector) {
            deploymentDetector.cleanup();
        }
        // Force garbage collection if available
        if (global.gc) {
            global.gc();
        }
    };
    
    // Setup cleanup handlers
    process.on('exit', cleanup);
    process.on('SIGINT', () => {
        cleanup();
        process.exit(0);
    });
    process.on('SIGTERM', () => {
        cleanup();
        process.exit(0);
    });
    
    // Check memory immediately
    if (checkMemory()) {
        console.error('‚ùå Starting with high memory usage - may indicate memory leak');
    }
    
    // Handle special flags
    if (args.includes('--version') || args.includes('-v')) {
        console.log(`Claude Multi-Agent PM Framework v${CLAUDE_PM_VERSION}`);
        
        // Also show deployment config version if available
        try {
            const deploymentConfig = getDeploymentConfig();
            
            // Check if we have a deployed instance with config
            if (deploymentConfig && deploymentConfig.config && 
                deploymentConfig.config.deploymentType === 'deployed' && 
                deploymentConfig.config.metadata && 
                deploymentConfig.config.metadata.deployedConfig) {
                
                const deployedConfig = deploymentConfig.config.metadata.deployedConfig;
                console.log(`Deployment Config Version: v${deployedConfig.version}`);
                if (deployedConfig.deployedAt) {
                    console.log(`Deployed: ${new Date(deployedConfig.deployedAt).toLocaleString()}`);
                }
                console.log(`Deployment Type: ${deploymentConfig.config.deploymentType}`);
                console.log(`Framework Path: ${deploymentConfig.config.frameworkPath}`);
            } else {
                // Try to read deployment config directly from standard locations
                const deploymentConfigPaths = [
                    path.join(os.homedir(), '.local', '.claude-pm', 'config.json'),
                    path.join(os.homedir(), '.claude-pm', 'config.json'),
                    path.join(process.cwd(), '.claude-pm', 'config.json')
                ];
                
                for (const configPath of deploymentConfigPaths) {
                    if (fs.existsSync(configPath)) {
                        const deployedConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));
                        console.log(`Deployment Config Version: v${deployedConfig.version}`);
                        if (deployedConfig.deployedAt) {
                            console.log(`Deployed: ${new Date(deployedConfig.deployedAt).toLocaleString()}`);
                        }
                        console.log(`Deployment Type: ${deploymentConfig.config.deploymentType}`);
                        console.log(`Framework Path: ${deploymentConfig.config.frameworkPath}`);
                        break;
                    }
                }
            }
        } catch (error) {
            // Silent fallback if deployment config is not available
        }
        
        process.exit(0);
    }
    
    if (args.includes('--help') || args.includes('-h')) {
        showHelp();
        process.exit(0);
    }
    
    // Handle no arguments case - display system info then launch Claude
    if (args.length === 0) {
        // Display comprehensive system information
        displaySystemInfo();
        
        // Manage framework CLAUDE.md deployment tree and show active framework file
        try {
            const frameworkResult = await manageFrameworkClaudeMd();
            if (frameworkResult.action === 'cleaned') {
                if (frameworkResult.processedFiles && frameworkResult.processedFiles.length > 0) {
                    console.log(`üßπ Framework cleanup: ${frameworkResult.reason}`);
                    console.log(`   Processed files: ${frameworkResult.processedFiles.join(', ')}`);
                }
            } else if (frameworkResult.action === 'error') {
                console.log(`‚ö†Ô∏è  Framework cleanup warning: ${frameworkResult.reason}`);
            }
            
            // Note: Project CLAUDE.md info is already shown in the main system info section above
            // This section was creating duplicate display - removing to fix duplicate issue
        } catch (error) {
            console.log(`‚ö†Ô∏è  Framework cleanup error: ${error.message}`);
        }
        
        try {
            // Add memory optimization to Claude launch
            const claudeEnv = {
                ...process.env,
                NODE_OPTIONS: '--max-old-space-size=4096'
            };
            
            const claudeProcess = spawn('claude', ['--dangerously-skip-permissions', '--model', 'sonnet'], {
                stdio: 'inherit',
                env: claudeEnv
            });
            
            // Track Claude process for cleanup
            const claudeCleanup = () => {
                cleanup(); // Original cleanup
                if (claudeProcess && !claudeProcess.killed) {
                    try {
                        claudeProcess.kill('SIGTERM');
                        setTimeout(() => {
                            if (!claudeProcess.killed) {
                                claudeProcess.kill('SIGKILL');
                            }
                        }, 5000);
                    } catch (error) {
                        // Ignore cleanup errors
                    }
                }
            };
            
            // Update cleanup handlers for Claude process
            process.removeAllListeners('SIGINT');
            process.removeAllListeners('SIGTERM');
            process.on('SIGINT', () => {
                claudeCleanup();
                process.exit(0);
            });
            process.on('SIGTERM', () => {
                claudeCleanup();
                process.exit(0);
            });
            
            claudeProcess.on('close', (code) => {
                claudeCleanup();
                process.exit(code);
            });
            
            claudeProcess.on('error', (error) => {
                console.error('‚ùå Failed to launch Claude:', error.message);
                console.error('Make sure Claude CLI is installed and available in your PATH');
                claudeCleanup();
                process.exit(1);
            });
            
            return;
        } catch (error) {
            console.error('‚ùå Failed to launch Claude:', error.message);
            console.error('Make sure Claude CLI is installed and available in your PATH');
            cleanup();
            process.exit(1);
        }
    }
    
    // Handle deployment detection debug flag
    if (args.includes('--deployment-info')) {
        const deploymentConfig = getDeploymentConfig();
        console.log('\nüîç Claude PM Framework Deployment Detection Results:');
        console.log('=' .repeat(60));
        console.log(JSON.stringify(deploymentConfig, null, 2));
        process.exit(0);
    }
    
    // Handle system info display flag
    if (args.includes('--system-info')) {
        displaySystemInfo();
        process.exit(0);
    }
    
    // Handle manual CLAUDE.md deployment command
    if (args.includes('deploy-template') || args.includes('--deploy-template')) {
        console.log('üöÄ Manually deploying CLAUDE.md template...');
        try {
            const deployed = await handleAutomaticClaudeMdDeployment();
            if (deployed) {
                console.log('‚úÖ CLAUDE.md template deployed successfully');
            } else {
                console.log('‚ÑπÔ∏è  No deployment needed - CLAUDE.md already exists or no global deployment info available');
            }
        } catch (error) {
            console.error(`‚ùå Template deployment error: ${error.message}`);
        }
        process.exit(0);
    }

    // Handle framework CLAUDE.md management flag
    if (args.includes('--manage-claude-md')) {
        console.log('üßπ Managing framework CLAUDE.md deployment tree...');
        try {
            const result = await manageFrameworkClaudeMd();
            console.log('\nüìä Framework CLAUDE.md Management Result:');
            console.log('=' .repeat(50));
            console.log(`Action: ${result.action}`);
            console.log(`Reason: ${result.reason}`);
            if (result.frameworkFiles !== undefined) {
                console.log(`Framework files found: ${result.frameworkFiles}`);
            }
            if (result.userFiles !== undefined) {
                console.log(`User files preserved: ${result.userFiles}`);
            }
            if (result.processedFiles) {
                console.log(`Processed files: ${result.processedFiles.join(', ')}`);
            }
            if (result.topLevelFile) {
                console.log(`Top-level framework file: ${result.topLevelFile}`);
            }
        } catch (error) {
            console.error(`‚ùå Framework management error: ${error.message}`);
        }
        process.exit(0);
    }
    
    // Handle CMPM-105 integrated commands
    if (args.includes('--template-status')) {
        const deploymentConfig = getDeploymentConfig();
        handleTemplateStatus(deploymentConfig);
        process.exit(0);
    }
    
    if (args.includes('--dependency-status')) {
        const deploymentConfig = getDeploymentConfig();
        handleDependencyStatus(deploymentConfig);
        process.exit(0);
    }
    
    if (args.includes('--parent-directory-status')) {
        const deploymentConfig = getDeploymentConfig();
        handleParentDirectoryStatus(deploymentConfig);
        process.exit(0);
    }
    
    // Validate environment
    const pythonCmd = validatePython();
    const deploymentStrategy = deploymentDetector.getDeploymentStrategy();
    
    if (deploymentStrategy.strategy === 'install_required') {
        console.error('‚ùå Claude PM Framework not found');
        console.error('Please install the framework:');
        console.error(`   ${deploymentStrategy.recommendation}`);
        process.exit(1);
    }
    
    const frameworkPath = deploymentStrategy.config.frameworkPath;
    const cliModulePath = deploymentStrategy.config.claudePmPath;
    
    // Validate CLI module exists
    if (!fs.existsSync(cliModulePath)) {
        console.error(`‚ùå Framework CLI module not found at: ${cliModulePath}`);
        console.error(`   Deployment type: ${deploymentStrategy.config.deploymentType}`);
        console.error(`   Framework path: ${frameworkPath}`);
        console.error(`   Try running: claude-pm --deployment-info`);
        process.exit(1);
    }
    
    // Enhanced environment setup based on deployment strategy with memory optimization
    const enhancedEnv = {
        ...process.env,
        ...deploymentStrategy.environmentSetup,
        CLAUDE_PM_VERSION: CLAUDE_PM_VERSION,
        CLAUDE_PM_DEPLOYMENT_TYPE: deploymentStrategy.config.deploymentType,
        CLAUDE_PM_DEPLOYMENT_CONFIDENCE: deploymentStrategy.config.confidence,
        // FIXED: Add explicit deployment directory for Python integration
        CLAUDE_PM_DEPLOYMENT_DIR: frameworkPath,
        CLAUDE_PM_WORKING_DIR: process.cwd(),
        // Memory optimization flags
        NODE_OPTIONS: '--max-old-space-size=4096',
        // Enable garbage collection if available
        NODE_GC: '1'
    };
    
    // Ensure proper PYTHONPATH setup
    const pythonPath = enhancedEnv.PYTHONPATH;
    if (pythonPath && !pythonPath.includes(frameworkPath)) {
        enhancedEnv.PYTHONPATH = frameworkPath + (pythonPath ? ':' + pythonPath : '');
    } else if (!pythonPath) {
        enhancedEnv.PYTHONPATH = frameworkPath;
    }
    
    // FIXED: Handle automatic CLAUDE.md deployment for global installations
    await handleAutomaticClaudeMdDeployment();
    
    // FIXED: Handle Python script updates and deployment
    await handlePythonScriptDeployment(frameworkPath, enhancedEnv);
    
    // FIXED: Handle agent profile deployment
    await handleAgentProfileDeployment(frameworkPath, enhancedEnv);
    
    // FIXED: Handle project deployment completion
    await handleProjectDeployment(deploymentStrategy, args);
    
    // Execute Python CLI module with enhanced environment and memory management
    const pythonProcess = spawn(pythonCmd, ['-m', 'claude_pm.cli', ...args], {
        stdio: 'inherit',
        env: enhancedEnv,
        cwd: frameworkPath
    });
    
    // Track spawned process for cleanup
    const spawnedProcesses = [pythonProcess];
    
    // Enhanced cleanup function that includes spawned processes
    const enhancedCleanup = () => {
        cleanup(); // Original cleanup
        
        // Kill any spawned processes
        spawnedProcesses.forEach(proc => {
            if (proc && !proc.killed) {
                try {
                    proc.kill('SIGTERM');
                    // Force kill after timeout
                    setTimeout(() => {
                        if (!proc.killed) {
                            proc.kill('SIGKILL');
                        }
                    }, 5000);
                } catch (error) {
                    // Ignore errors when killing processes
                }
            }
        });
    };
    
    // Update cleanup handlers to include process cleanup
    process.removeAllListeners('SIGINT');
    process.removeAllListeners('SIGTERM');
    process.on('SIGINT', () => {
        enhancedCleanup();
        process.exit(0);
    });
    process.on('SIGTERM', () => {
        enhancedCleanup();
        process.exit(0);
    });
    
    pythonProcess.on('close', (code) => {
        enhancedCleanup();
        process.exit(code);
    });
    
    pythonProcess.on('error', (error) => {
        console.error('‚ùå Failed to execute Claude PM Framework:', error.message);
        console.error(`   Deployment type: ${deploymentStrategy.config.deploymentType}`);
        console.error(`   Framework path: ${frameworkPath}`);
        console.error(`   Python command: ${pythonCmd}`);
        console.error(`   Try running: claude-pm --deployment-info`);
        enhancedCleanup();
        process.exit(1);
    });
}

// Execute main function
if (require.main === module) {
    main().catch((error) => {
        console.error('‚ùå CLI execution error:', error.message);
        process.exit(1);
    });
}

/**
 * CMPM-105 Integration: Handle template management status
 */
function handleTemplateStatus(deploymentConfig) {
    console.log('\nüìÑ Template Management Status (CMPM-102):');
    console.log('=' .repeat(60));
    
    try {
        const pythonCmd = validatePython();
        const frameworkPath = deploymentConfig.config.frameworkPath;
        
        // Execute template manager status command
        const { spawn } = require('child_process');
        const templateProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.template_manager import TemplateManager
import asyncio
import json

async def get_status():
    try:
        manager = TemplateManager()
        await manager._initialize()
        templates = await manager.list_templates()
        status = {
            "initialized": True,
            "template_count": len(templates),
            "templates": templates[:5],  # Show first 5
            "deployment_type": "${deploymentConfig.config.deploymentType}"
        }
        print(json.dumps(status, indent=2, default=str))
    except Exception as e:
        print(json.dumps({"error": str(e), "initialized": False}, indent=2))

asyncio.run(get_status())
        `], {
            stdio: 'inherit',
            env: {
                ...process.env,
                PYTHONPATH: frameworkPath,
                CLAUDE_PM_FRAMEWORK_PATH: frameworkPath
            },
            cwd: frameworkPath
        });
        
        templateProcess.on('error', (error) => {
            console.error('‚ùå Template Manager Error:', error.message);
        });
        
    } catch (error) {
        console.error('‚ùå Template Status Error:', error.message);
    }
}

/**
 * CMPM-105 Integration: Handle dependency management status
 */
function handleDependencyStatus(deploymentConfig) {
    console.log('\nüì¶ Dependency Management Status (CMPM-103):');
    console.log('=' .repeat(60));
    
    try {
        const pythonCmd = validatePython();
        const frameworkPath = deploymentConfig.config.frameworkPath;
        
        // Execute dependency manager status command
        const { spawn } = require('child_process');
        const dependencyProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.dependency_manager import DependencyManager
import asyncio
import json

async def get_status():
    try:
        manager = DependencyManager()
        await manager._initialize()
        dependencies = manager.get_dependencies()
        report = await manager.generate_dependency_report()
        status = {
            "initialized": True,
            "dependencies_tracked": len(dependencies),
            "health_score": report.health_score,
            "missing_dependencies": report.missing_dependencies,
            "deployment_type": "${deploymentConfig.config.deploymentType}"
        }
        print(json.dumps(status, indent=2, default=str))
    except Exception as e:
        print(json.dumps({"error": str(e), "initialized": False}, indent=2))

asyncio.run(get_status())
        `], {
            stdio: 'inherit',
            env: {
                ...process.env,
                PYTHONPATH: frameworkPath,
                CLAUDE_PM_FRAMEWORK_PATH: frameworkPath
            },
            cwd: frameworkPath
        });
        
        dependencyProcess.on('error', (error) => {
            console.error('‚ùå Dependency Manager Error:', error.message);
        });
        
    } catch (error) {
        console.error('‚ùå Dependency Status Error:', error.message);
    }
}

/**
 * CMPM-105 Integration: Handle parent directory management status
 */
function handleParentDirectoryStatus(deploymentConfig) {
    console.log('\nüìÅ Parent Directory Management Status (CMPM-104):');
    console.log('=' .repeat(60));
    
    try {
        const pythonCmd = validatePython();
        const frameworkPath = deploymentConfig.config.frameworkPath;
        
        // Execute parent directory manager status command
        const { spawn } = require('child_process');
        const parentDirProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.parent_directory_manager import ParentDirectoryManager
import asyncio
import json

async def get_status():
    try:
        manager = ParentDirectoryManager()
        await manager._initialize()
        directories = await manager.list_managed_directories()
        status = {
            "initialized": True,
            "managed_directories": len(directories),
            "directories": directories[:3],  # Show first 3
            "deployment_type": "${deploymentConfig.config.deploymentType}"
        }
        print(json.dumps(status, indent=2, default=str))
    except Exception as e:
        print(json.dumps({"error": str(e), "initialized": False}, indent=2))

asyncio.run(get_status())
        `], {
            stdio: 'inherit',
            env: {
                ...process.env,
                PYTHONPATH: frameworkPath,
                CLAUDE_PM_FRAMEWORK_PATH: frameworkPath
            },
            cwd: frameworkPath
        });
        
        parentDirProcess.on('error', (error) => {
            console.error('‚ùå Parent Directory Manager Error:', error.message);
        });
        
    } catch (error) {
        console.error('‚ùå Parent Directory Status Error:', error.message);
    }
}

/**
 * Handle automatic CLAUDE.md deployment for global installations
 */
async function handleAutomaticClaudeMdDeployment() {
    try {
        const globalConfigDir = path.join(os.homedir(), '.claude-pm');
        const globalDeploymentInfoPath = path.join(globalConfigDir, 'global-deployment.json');
        
        // Check if we have global deployment info
        if (!fs.existsSync(globalDeploymentInfoPath)) {
            return false; // No global deployment info available
        }
        
        const globalInfo = JSON.parse(fs.readFileSync(globalDeploymentInfoPath, 'utf8'));
        
        // Only proceed if this is a global installation that needs first run deployment
        if (!globalInfo.needsFirstRunDeployment || globalInfo.installationType !== 'global') {
            return false;
        }
        
        const workingDir = process.cwd();
        const workingClaudemd = path.join(workingDir, 'CLAUDE.md');
        
        // Check if CLAUDE.md already exists in working directory
        if (fs.existsSync(workingClaudemd)) {
            const content = fs.readFileSync(workingClaudemd, 'utf8');
            const isFrameworkFile = content.includes('Claude PM Framework Configuration - Deployment') || 
                                  content.includes('AI ASSISTANT ROLE DESIGNATION');
            
            if (!isFrameworkFile) {
                // User has custom CLAUDE.md, don't override
                return false;
            }
        }
        
        // Check if framework template exists
        const frameworkTemplate = globalInfo.frameworkTemplatePath;
        if (!fs.existsSync(frameworkTemplate)) {
            console.log('‚ö†Ô∏è  Framework template not found for auto-deployment');
            return false;
        }
        
        // Deploy CLAUDE.md to working directory
        console.log('üöÄ Auto-deploying CLAUDE.md from global installation...');
        
        let templateContent = fs.readFileSync(frameworkTemplate, 'utf8');
        const packageJson = require(path.join(path.dirname(frameworkTemplate), '..', 'package.json'));
        
        const deploymentDate = new Date().toISOString();
        const deploymentId = Date.now();
        
        // Template variable replacements
        const replacements = {
            '{{CLAUDE_MD_VERSION}}': `${packageJson.version}-001`,
            '{{FRAMEWORK_VERSION}}': packageJson.version,
            '{{DEPLOYMENT_DATE}}': deploymentDate,
            '{{LAST_UPDATED}}': deploymentDate,
            '{{DEPLOYMENT_DIR}}': workingDir,
            '{{PLATFORM}}': os.platform(),
            '{{PYTHON_CMD}}': 'python3',
            '{{AI_TRACKDOWN_PATH}}': 'Global installation available',
            '{{DEPLOYMENT_ID}}': deploymentId,
            '{{PLATFORM_NOTES}}': getPlatformNotes(os.platform())
        };
        
        // Apply template variable substitutions
        for (const [placeholder, value] of Object.entries(replacements)) {
            const escapedPlaceholder = placeholder.replace(/[{}]/g, '\\$&');
            templateContent = templateContent.replace(new RegExp(escapedPlaceholder, 'g'), value);
        }
        
        // Write the deployed CLAUDE.md
        fs.writeFileSync(workingClaudemd, templateContent);
        console.log(`‚úÖ Framework CLAUDE.md deployed to: ${workingClaudemd}`);
        
        // Mark as deployed by removing the needsFirstRunDeployment flag
        globalInfo.needsFirstRunDeployment = false;
        globalInfo.lastDeploymentDate = deploymentDate;
        globalInfo.lastDeploymentDir = workingDir;
        
        fs.writeFileSync(globalDeploymentInfoPath, JSON.stringify(globalInfo, null, 2));
        
        return true;
        
    } catch (error) {
        console.log(`‚ö†Ô∏è  Auto-deployment failed: ${error.message}`);
        return false;
    }
}

/**
 * Get platform-specific notes for template deployment
 */
function getPlatformNotes(platform) {
    switch (platform) {
        case 'darwin':
            return '**macOS-specific:**\n- Use `.sh` files for scripts\n- CLI wrappers: `bin/aitrackdown` and `bin/atd`\n- Health check: `scripts/health-check.sh`\n- May require Xcode Command Line Tools';
        case 'linux':
            return '**Linux-specific:**\n- Use `.sh` files for scripts\n- CLI wrappers: `bin/aitrackdown` and `bin/atd`\n- Health check: `scripts/health-check.sh`\n- Ensure proper file permissions';
        case 'win32':
            return '**Windows-specific:**\n- Use `.bat` files for scripts\n- CLI wrappers: `bin/aitrackdown.bat` and `bin/atd.bat`\n- Health check: `scripts/health-check.bat`\n- Path separators: Use backslashes in Windows paths';
        default:
            return `**Platform**: ${platform}\n- Use appropriate script extensions for your platform\n- Ensure proper file permissions on CLI wrappers`;
    }
}

/**
 * CMCP-105 Integration: Handle Python script deployment
 */
async function handlePythonScriptDeployment(frameworkPath, environment) {
    try {
        // Check if Python scripts need updates
        const pythonScriptPath = path.join(frameworkPath, 'claude_pm');
        
        if (!fs.existsSync(pythonScriptPath)) {
            console.log('‚ö†Ô∏è  Python scripts not found, may need installation');
            return;
        }
        
        // Validate Python environment
        const pythonCmd = validatePython();
        
        // Check if Python dependencies are installed
        const { spawn } = require('child_process');
        const checkProcess = spawn(pythonCmd, ['-c', 'import claude_pm; print("OK")'], {
            env: environment,
            cwd: frameworkPath,
            stdio: 'pipe'
        });
        
        return new Promise((resolve) => {
            let output = '';
            
            checkProcess.stdout.on('data', (data) => {
                output += data.toString();
            });
            
            checkProcess.on('close', (code) => {
                if (code === 0 && output.includes('OK')) {
                    // Python integration is working
                    resolve();
                } else {
                    console.log('‚ö†Ô∏è  Python integration may need setup');
                    resolve();
                }
            });
            
            // Timeout after 5 seconds
            setTimeout(() => {
                checkProcess.kill();
                resolve();
            }, 5000);
        });
        
    } catch (error) {
        // Silent failure - don't break CLI
        return;
    }
}

/**
 * CMPM-105 Integration: Handle project deployment completion
 */
async function handleProjectDeployment(deploymentConfig, args) {
    try {
        // Check if this is a project-specific operation
        const isProjectSpecific = args.some(arg => 
            ['project', 'init', 'setup', 'deploy'].includes(arg)
        );
        
        if (!isProjectSpecific) {
            return;
        }
        
        const frameworkPath = deploymentConfig.config.frameworkPath;
        const workingDir = process.cwd();
        
        // Create project-specific deployment structure if needed
        const projectClaudePmDir = path.join(workingDir, '.claude-pm');
        
        if (!fs.existsSync(projectClaudePmDir)) {
            fs.mkdirSync(projectClaudePmDir, { recursive: true });
            
            // Create basic project configuration
            const projectConfig = {
                project_type: "managed",
                framework_path: frameworkPath,
                deployment_date: new Date().toISOString(),
                version: deploymentConfig.config.version || "4.5.1"
            };
            
            fs.writeFileSync(
                path.join(projectClaudePmDir, 'config.json'),
                JSON.stringify(projectConfig, null, 2)
            );
        }
        
    } catch (error) {
        // Silent failure - don't break CLI
        return;
    }
}

/**
 * CMPM-105 Integration: Handle agent profile deployment
 */
async function handleAgentProfileDeployment(frameworkPath, environment) {
    try {
        const workingDir = process.cwd();
        
        // Check if agent profile loader service exists
        const profileLoaderPath = path.join(frameworkPath, 'claude_pm', 'services', 'agent_profile_loader.py');
        
        if (!fs.existsSync(profileLoaderPath)) {
            // Profile loader not available, skip deployment
            return;
        }
        
        // Validate Python environment
        const pythonCmd = validatePython();
        
        // Execute profile deployment
        const { spawn } = require('child_process');
        const profileProcess = spawn(pythonCmd, ['-c', `
import sys
sys.path.insert(0, '${frameworkPath}')
from claude_pm.services.agent_profile_loader import AgentProfileLoader
import asyncio
import json
from pathlib import Path

async def deploy_profiles():
    try:
        loader = AgentProfileLoader(working_directory=Path('${workingDir}'))
        await loader.initialize()
        
        # Create profile deployment structure
        structure_results = await loader.create_profile_deployment_structure()
        
        # Deploy system profiles as project defaults
        deployment_results = await loader.deploy_system_profiles()
        
        # List available profiles
        available_profiles = await loader.list_available_profiles()
        
        results = {
            "structure_created": structure_results,
            "profiles_deployed": deployment_results,
            "available_profiles": {tier.value: profiles for tier, profiles in available_profiles.items()},
            "deployment_successful": True
        }
        
        print(json.dumps(results, indent=2, default=str))
        
    except Exception as e:
        error_result = {
            "deployment_successful": False,
            "error": str(e),
            "fallback": "Profile deployment skipped - will use runtime loading"
        }
        print(json.dumps(error_result, indent=2))

asyncio.run(deploy_profiles())
        `], {
            stdio: 'pipe',
            env: environment,
            cwd: frameworkPath,
            timeout: 15000  // 15 second timeout
        });
        
        return new Promise((resolve) => {
            let output = '';
            let errorOutput = '';
            
            profileProcess.stdout.on('data', (data) => {
                output += data.toString();
            });
            
            profileProcess.stderr.on('data', (data) => {
                errorOutput += data.toString();
            });
            
            profileProcess.on('close', (code) => {
                try {
                    if (code === 0 && output.trim()) {
                        const results = JSON.parse(output.trim());
                        
                        if (results.deployment_successful) {
                            const deployedCount = Object.values(results.profiles_deployed || {}).filter(Boolean).length;
                            if (deployedCount > 0) {
                                console.log(`ü§ñ Agent profiles deployed: ${deployedCount} system profiles available`);
                            }
                        }
                    }
                } catch (parseError) {
                    // Silent fallback - profile deployment is non-critical
                }
                
                resolve();
            });
            
            // Timeout fallback
            setTimeout(() => {
                if (!profileProcess.killed) {
                    profileProcess.kill();
                }
                resolve();
            }, 15000);
        });
        
    } catch (error) {
        // Silent failure - don't break CLI if profile deployment fails
        return;
    }
}

module.exports = { 
    main, 
    getFrameworkPath, 
    getDeploymentConfig, 
    validatePython, 
    DeploymentDetector,
    handleTemplateStatus,
    handleDependencyStatus,
    handleParentDirectoryStatus,
    handlePythonScriptDeployment,
    handleProjectDeployment,
    handleAgentProfileDeployment
};
