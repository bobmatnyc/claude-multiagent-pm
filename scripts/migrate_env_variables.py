#!/usr/bin/env python3
"""
Environment Variable Migration Script
====================================

Migrates legacy CLAUDE_PM_ environment variables to the new CLAUDE_MULTIAGENT_PM_ prefix.
This script handles shell configuration files, systemd services, and provides export commands.
"""

import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Tuple, Optional
import argparse
import json
import subprocess
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class EnvironmentVariableMigrator:
    """Handles migration of CLAUDE_PM_ environment variables to CLAUDE_MULTIAGENT_PM_ prefix."""
    
    LEGACY_PREFIX = "CLAUDE_PM_"
    NEW_PREFIX = "CLAUDE_MULTIAGENT_PM_"
    
    def __init__(self, dry_run: bool = False):
        self.dry_run = dry_run
        self.current_env_vars = self._get_current_env_vars()
        self.migration_map = self._create_migration_map()
        
    def _get_current_env_vars(self) -> Dict[str, str]:
        """Get all current CLAUDE_PM_ environment variables."""
        env_vars = {}
        for key, value in os.environ.items():
            if key.startswith(self.LEGACY_PREFIX):
                env_vars[key] = value
        return env_vars
    
    def _create_migration_map(self) -> Dict[str, str]:
        """Create mapping of old to new variable names."""
        migration_map = {}
        for old_var in self.current_env_vars.keys():
            new_var = old_var.replace(self.LEGACY_PREFIX, self.NEW_PREFIX, 1)
            migration_map[old_var] = new_var
        return migration_map
    
    def generate_export_commands(self) -> List[str]:
        """Generate export commands for the new environment variables."""
        commands = []
        commands.append("# Claude PM Framework Environment Variable Migration")
        commands.append("# Generated by migrate_env_variables.py")
        commands.append("")
        
        for old_var, new_var in self.migration_map.items():
            value = self.current_env_vars[old_var]
            commands.append(f'export {new_var}="{value}"')
        
        commands.append("")
        commands.append("# Unset legacy variables (optional)")
        for old_var in self.migration_map.keys():
            commands.append(f'unset {old_var}')
        
        return commands
    
    def find_shell_config_files(self) -> List[Path]:
        """Find shell configuration files that might contain environment variables."""
        home = Path.home()
        config_files = []
        
        # Common shell configuration files
        candidates = [
            ".bashrc",
            ".bash_profile",
            ".zshrc",
            ".zsh_profile",
            ".profile",
            ".env",
            ".envrc"
        ]
        
        for candidate in candidates:
            path = home / candidate
            if path.exists():
                config_files.append(path)
        
        return config_files
    
    def scan_config_files(self) -> List[Tuple[Path, List[str]]]:
        """Scan configuration files for CLAUDE_PM_ variables."""
        config_files = self.find_shell_config_files()
        found_vars = []
        
        for config_file in config_files:
            try:
                with open(config_file, 'r') as f:
                    content = f.read()
                    
                # Find lines with CLAUDE_PM_ variables
                lines_with_vars = []
                for line_num, line in enumerate(content.splitlines(), 1):
                    if self.LEGACY_PREFIX in line and ('export' in line or '=' in line):
                        lines_with_vars.append(f"Line {line_num}: {line.strip()}")
                
                if lines_with_vars:
                    found_vars.append((config_file, lines_with_vars))
                    
            except Exception as e:
                logger.warning(f"Could not read {config_file}: {e}")
        
        return found_vars
    
    def update_config_file(self, config_file: Path) -> bool:
        """Update a configuration file with new environment variables."""
        try:
            with open(config_file, 'r') as f:
                content = f.read()
            
            # Create backup
            backup_path = config_file.with_suffix(config_file.suffix + '.backup')
            if not self.dry_run:
                with open(backup_path, 'w') as f:
                    f.write(content)
                logger.info(f"Created backup: {backup_path}")
            
            # Replace CLAUDE_PM_ with CLAUDE_MULTIAGENT_PM_ in export statements
            updated_content = content
            changes_made = False
            
            for old_var, new_var in self.migration_map.items():
                # Pattern to match export statements
                export_pattern = rf'export\s+{re.escape(old_var)}\s*='
                if re.search(export_pattern, updated_content):
                    updated_content = re.sub(
                        export_pattern,
                        f'export {new_var}=',
                        updated_content
                    )
                    changes_made = True
                    logger.info(f"Replaced {old_var} with {new_var} in {config_file}")
                
                # Pattern to match direct assignment
                assign_pattern = rf'^{re.escape(old_var)}\s*='
                if re.search(assign_pattern, updated_content, re.MULTILINE):
                    updated_content = re.sub(
                        assign_pattern,
                        f'{new_var}=',
                        updated_content,
                        flags=re.MULTILINE
                    )
                    changes_made = True
                    logger.info(f"Replaced {old_var} with {new_var} in {config_file}")
            
            # Write updated content
            if changes_made and not self.dry_run:
                with open(config_file, 'w') as f:
                    f.write(updated_content)
                logger.info(f"Updated {config_file}")
            
            return changes_made
            
        except Exception as e:
            logger.error(f"Error updating {config_file}: {e}")
            return False
    
    def generate_migration_report(self) -> Dict:
        """Generate a comprehensive migration report."""
        report = {
            "timestamp": str(subprocess.check_output(['date'], text=True).strip()),
            "legacy_variables_found": len(self.current_env_vars),
            "migration_map": self.migration_map,
            "current_env_vars": self.current_env_vars,
            "shell_config_files": [],
            "export_commands": self.generate_export_commands()
        }
        
        # Scan configuration files
        config_file_results = self.scan_config_files()
        for config_file, lines_with_vars in config_file_results:
            report["shell_config_files"].append({
                "file": str(config_file),
                "lines_with_variables": lines_with_vars
            })
        
        return report
    
    def validate_migration(self) -> bool:
        """Validate that migration would work correctly."""
        validation_issues = []
        
        # Check if any new variables already exist
        for old_var, new_var in self.migration_map.items():
            if new_var in os.environ:
                existing_value = os.environ[new_var]
                legacy_value = self.current_env_vars[old_var]
                if existing_value != legacy_value:
                    validation_issues.append(
                        f"Conflict: {new_var} already exists with different value. "
                        f"Current: {existing_value}, Legacy: {legacy_value}"
                    )
        
        # Check for write permissions on config files
        config_files = self.find_shell_config_files()
        for config_file in config_files:
            if not os.access(config_file, os.W_OK):
                validation_issues.append(f"No write permission for {config_file}")
        
        if validation_issues:
            logger.error("Migration validation failed:")
            for issue in validation_issues:
                logger.error(f"  - {issue}")
            return False
        
        return True
    
    def run_migration(self) -> bool:
        """Execute the complete migration process."""
        logger.info("Starting Claude PM Framework environment variable migration...")
        
        if not self.current_env_vars:
            logger.info("No CLAUDE_PM_ environment variables found. Migration not needed.")
            return True
        
        logger.info(f"Found {len(self.current_env_vars)} legacy environment variables to migrate")
        
        # Validate migration
        if not self.validate_migration():
            logger.error("Migration validation failed. Aborting.")
            return False
        
        # Generate migration report
        report = self.generate_migration_report()
        
        # Save migration report
        report_path = Path("env_migration_report.json")
        if not self.dry_run:
            with open(report_path, 'w') as f:
                json.dump(report, f, indent=2)
            logger.info(f"Migration report saved to {report_path}")
        
        # Update configuration files
        config_file_results = self.scan_config_files()
        files_updated = 0
        
        for config_file, lines_with_vars in config_file_results:
            if self.update_config_file(config_file):
                files_updated += 1
        
        # Generate export commands file
        commands = self.generate_export_commands()
        export_file = Path("env_migration_commands.sh")
        if not self.dry_run:
            with open(export_file, 'w') as f:
                f.write('\n'.join(commands))
                f.write('\n')
            os.chmod(export_file, 0o755)
            logger.info(f"Export commands saved to {export_file}")
        
        logger.info(f"Migration completed. Updated {files_updated} configuration files.")
        
        if not self.dry_run:
            logger.info("To complete the migration:")
            logger.info(f"1. Source the new environment variables: source {export_file}")
            logger.info("2. Restart your shell or source your shell configuration files")
            logger.info("3. Test that the framework works with new variables")
            logger.info("4. Remove legacy variables once confirmed working")
        
        return True

def main():
    """Main entry point for the migration script."""
    parser = argparse.ArgumentParser(
        description="Migrate CLAUDE_PM_ environment variables to CLAUDE_MULTIAGENT_PM_ prefix"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be done without making changes"
    )
    parser.add_argument(
        "--report-only",
        action="store_true",
        help="Generate migration report only"
    )
    parser.add_argument(
        "--validate-only",
        action="store_true",
        help="Validate migration feasibility only"
    )
    
    args = parser.parse_args()
    
    # Create migrator instance
    migrator = EnvironmentVariableMigrator(dry_run=args.dry_run)
    
    if args.validate_only:
        logger.info("Validating migration feasibility...")
        is_valid = migrator.validate_migration()
        if is_valid:
            logger.info("Migration validation passed. Safe to proceed.")
            sys.exit(0)
        else:
            logger.error("Migration validation failed. Check issues above.")
            sys.exit(1)
    
    if args.report_only:
        logger.info("Generating migration report...")
        report = migrator.generate_migration_report()
        print(json.dumps(report, indent=2))
        return
    
    if args.dry_run:
        logger.info("Running in dry-run mode - no changes will be made")
    
    # Run migration
    success = migrator.run_migration()
    
    if success:
        logger.info("Migration completed successfully!")
        sys.exit(0)
    else:
        logger.error("Migration failed. Check logs for details.")
        sys.exit(1)

if __name__ == "__main__":
    main()